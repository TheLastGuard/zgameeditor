<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="14" ViewportRatio="2" FileVersion="2">
  <OnLoaded>
    <ZExternalLibrary ModuleName="kernel32.dll">
      <Source>
<![CDATA[//Import a DLL-library by setting ModuleName to name of the DLL
//and then declaring the function headers here. For example:
//
//  int SetWindowLongA(int hWnd, int nIndex, int dwNewLong) { }
//  int SetWindowTextA(int hWnd,string lpString) { }
int GetTickCount() { }]]>
      </Source>
    </ZExternalLibrary>
    <ZExternalLibrary Comment="OpenGL 4.0 graphics" ModuleName="opengl32" DefinitionsFile="opengl.txt">
      <BeforeInitExp>
<![CDATA[if(ANDROID) {
  if(App.GLBase==0)
    this.ModuleName="libGLESv1_CM.so";
  else
    this.ModuleName="libGLESv2.so";
}]]>
      </BeforeInitExp>
    </ZExternalLibrary>
    <ZLibrary Comment="util">
      <Source>
<![CDATA[int isKeyPressed(int key) {
  KeyTesterResult=0;
  KeyTester.CharCode=key;
  @CallComponent(Component : KeyTester);
  return KeyTesterResult;
}

private int nextScreenDumpFileName;

void saveScreenDump() {
  //Based on code by Kjell http://www.emix8.org/forum/viewtopic.php?f=1&t=1156&p=7242&hilit=save+image#p7242
  int w=App.ViewportWidth;
  int h=App.ViewportHeight;

  byte[18] header;

  header[2] = 2;
  header[16] = 32;
  header[17] = 8;

  header[12] = w;
  header[13] = w >> 8;

  header[14] = h;
  header[15] = h >> 8;

  byte[] image;
  image.SizeDim1=w*h*4;
  glReadPixels(App.ViewportX, App.ViewportY, w, h, 0x80E1, 0x1401, image);

  byte[] buffer;
  buffer.SizeDim1 = header.SizeDim1 + image.SizeDim1;

  int dst=0;
  for(int i=0; i<header.SizeDim1; i++)
    buffer[dst++]=header[i];
  for(int i=0; i<image.SizeDim1; i++)
    buffer[dst++]=image[i];

  string filename="t:\\pic" + intToStr(nextScreenDumpFileName++) + ".tga";
  @FileAction( File : @File(FileName : filename, Encoding : 1, TargetArray : buffer), Action : 1 );
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="jasper" HasInitializer="1">
      <Source>
<![CDATA[//Based on https://github.com/begoon/jasper

  const int DEBUGTRACE = 0;
  const int PROFILE = 0;
  const int ANALYSE = 0;
  const int ANALYSE_CHECK_HOTSPOTS = 0;
  const int ANALYSE_CHECK_PC = 0;

  int analyse_frameRenderIndicator = 0;
  int analyse_checkFrameWrites = 0;
  int[65536] analyse_HotSpots;
  int[65536] analyse_AddrFlags;

  private const float clockSpeed = 3.5;
  private const int tstatesPerInterrupt = ((clockSpeed * 1e6) / 50);


  int Keys_B_SPC  = 0xff;
  int Keys_H_ENT  = 0xff;
  int Keys_Y_P    = 0xff;
  int Keys_6_0    = 0xff;
  int Keys_1_5    = 0xff;
  int Keys_Q_T    = 0xff;
  int Keys_A_G    = 0xff;
  int Keys_CAPS_V = 0xff;
  int JoyState = 0;

  const int IM0 = 0;
  const int IM1 = 1;
  const int IM2 = 2;

  private const int F_C  = 0x01;
  private const int F_N  = 0x02;
  private const int F_PV = 0x04;
  private const int F_3  = 0x08;
  private const int F_H  = 0x10;
  private const int F_5  = 0x20;
  private const int F_Z  = 0x40;
  private const int F_S  = 0x80;

  private const int PF = F_PV;
  private const int p_ = 0;

  private int[256] parity;

  private const int true = 1;
  private const int false = 0;

  int getSignedByte(int b) {
    if(b&0x80)
      return 0-((b^255) +1);
    else
      return b;
  }

  {
    for ( int i = 0; i < 256; i++ ) {
      int p = true;
      for ( int j = 0; j < 8; j++ ) {
        if ( (i & (1<<j)) != 0 ) {
          p = p ? false : true;
        }
      }
      parity[ i ] = p;
    }
  }

  /** Alternate registers */
   int        _AF_ = 0, _HL_ = 0, _BC_ = 0, _DE_ = 0;

  /** Index registers - ID used as temporary for ix/iy */
   int        _IX = 0, _IY = 0, _ID = 0;

  /** Stack Pointer and Program Counter */
   int        _SP = 0, _PC = 0;

  /** Interrupt and Refresh registers */
   int        _I = 0, _R = 0, _R7 = 0;

  /** Interrupt flip-flops */
   int    _IFF1 = true, _IFF2 = true;
   int        _IM = 2;

  /** Memory */
  byte[ 65536 ]  mem;

    /** Main registers */
   int        _A = 0, _HL = 0, _B = 0, _C = 0, _DE = 0;
   int    fS = false, fZ  = false, f5 = false, fH = false;
   int    f3 = false, fPV = false, fN = false, fC = false;

  /** Flag access */
    inline void setZ( int f ) { fZ = f; }
    inline void setC( int f ) { fC = f; }
    inline void setS( int f ) { fS = f; }
    inline void setH( int f ) { fH = f; }
    inline void setN( int f ) { fN = f; }
    inline void setPV( int f ) {fPV = f;}
    inline void set3( int f ) { f3 = f; }
    inline void set5( int f ) { f5 = f; }

    inline int Zset()  { return fZ; }
    inline int Cset()  { return fC; }
    inline int Sset()  { return fS; }
    inline int Hset()  { return fH; }
    inline int Nset()  { return fN; }
    inline int PVset() { return fPV; }


  /** 8 bit register access */
  inline int  A() { return _A; }

  inline void A( int bite ) {
    _A = bite;
  }

  inline int F() {
    return  (Sset()  ? F_S  : 0)  |
      (Zset()  ? F_Z  : 0)  |
      (f5      ? F_5  : 0)  |
      (Hset()  ? F_H  : 0)  |
      (f3      ? F_3  : 0)  |
      (PVset() ? F_PV : 0)  |
      (Nset()  ? F_N  : 0)  |
      (Cset()  ? F_C  : 0);
  }
  inline void F( int bite ) {
    fS  = (bite & F_S)  != 0;
    fZ  = (bite & F_Z)  != 0;
    f5  = (bite & F_5)  != 0;
    fH  = (bite & F_H)  != 0;
    f3  = (bite & F_3)  != 0;
    fPV = (bite & F_PV) != 0;
    fN  = (bite & F_N)  != 0;
    fC  = (bite & F_C)  != 0;
  }


  inline int  B() { return _B; }
  inline void B( int bite ) {
    _B = bite;
  }
  inline int  C() { return _C; }
  inline void C( int bite ) {
    _C = bite;
  }

  inline int D() { return (_DE >> 8); }
  inline void D( int bite ) {
    _DE = (bite << 8) | (_DE & 0x00ff);
  }
  inline int  E() { return (_DE & 0xff); }
  inline void E( int bite ) {
    _DE = (_DE & 0xff00) | bite;
  }

  inline int  H() { return (_HL >> 8); }

  inline void H( int bite ) {
    _HL = (bite << 8) | (_HL & 0x00ff);
  }

  inline int L() { return (_HL & 0xff); }
  inline void L( int bite ) {
    _HL = (_HL & 0xff00) | bite;
  }

  /** 16 bit register access */
  inline int AF() { return (A() << 8) | F(); }

  inline void AF( int word ) {
    A( word >> 8 );
    F( word & 0xff );
  }

  inline int BC() { return (B() << 8) | C(); }
  inline void BC( int word ) {
    B( word >> 8 );
    C( word & 0xff );
  }

  inline int  DE() { return _DE; }
  inline void DE( int word ) {
    _DE = word;
  }

  inline int  HL() { return _HL; }
  inline void HL( int word ) {
    _HL = word;
  }

  inline int PC() { return _PC; }

  inline void PC( int word ) {
    _PC = word;
  }

  inline int  SP() { return _SP; }
  inline void SP( int word ) {
    _SP = word;
  }

  inline int ID() { return _ID; }
  inline void ID( int word ) {
    _ID = word;
  }

  inline int IX() { return _IX; }
  inline void IX( int word ) {
    _IX = word;
  }

  inline int IY() { return _IY; }
  inline void IY( int word ) {
    _IY = word;
  }




  inline int  IDH() { return (_ID >> 8); }
  inline void IDH( int bite ) {
    _ID = (bite << 8) | (_ID & 0x00ff);
  }
  inline int  IDL() { return (_ID & 0xff); }
  inline void IDL( int bite ) {
    _ID = (_ID & 0xff00) | bite;
  }


  /** Memory refresh register */
  inline int  R7() { return _R7; }
  inline int  R() { return (_R & 0x7f) | _R7; }
  inline void R( int bite ) {
    _R  = bite;
    _R7 = bite & 0x80;
  }

  inline void REFRESH( int t ) {
    _R += t;
  }


  /** Interrupt modes/register */
  int  I() { return _I; }
  void I( int bite ) {
    _I = bite;
  }

  int IFF1() { return _IFF1; }
  void IFF1( int iff1 ) {
    _IFF1 = iff1;
  }

  int IFF2() { return _IFF2; }
  void IFF2( int iff2 ) {
    _IFF2 = iff2;
  }

  int IM() { return _IM; }
  void IM( int im ) {
    _IM = im;
  }



  /** Byte access */
  inline int peekb( int addr ) {
    return mem[ addr ];
  }

  void pokeb( int addr, int newByte ) {
    if ( addr < 16384 ) {
      return;
    }

    mem[ addr ] = newByte;

    if(ANALYSE) {
      //if(addr==50176)
      //  trace("mod: " + intToStr(_PC));

      if(analyse_checkFrameWrites && addr>16384 && addr<16384+6912) {
        analyse_frameRenderIndicator=1; //Trigger screen refresh on each byte written to video RAM
        if(ANALYSE_CHECK_HOTSPOTS)
          analyse_HotSpots[_PC]++;
      }
    }

  }


  /** Word access */
  void pokew( int addr, int word ) {
    pokeb( addr, word & 0xff );
    addr++;
    pokeb( addr & 0xffff, word >> 8 );
  }

  private  int peekw( int addr ) {
    int        t = peekb( addr );
    addr++;
    return t | (peekb( addr & 0xffff ) << 8);
  }


  /** Program access */
  int nxtpcb() {
    int pc = PC();
    int t = peekb( pc );
    PC( ++pc & 0xffff );
    return t;
  }
  private  int nxtpcw() {
    int pc = PC();
    int t = peekb( pc );
    t |= ( peekb( ++pc & 0xffff ) << 8 );
    PC( ++pc & 0xffff );
    return t;
  }

  /** Index register access */
  private  int ID_d() {
    return ((ID()+nxtpcb()) & 0xffff);
  }


  /** Stack access */
  void pushw( int word ) {
    int        sp = ((SP()-2) & 0xffff);
    SP( sp );
    pokew( sp, word );
  }

  int popw() {
    int sp = SP();
    int t  = peekb( sp );
      sp++;
      t |= (peekb( sp & 0xffff) << 8);
      SP( ++sp & 0xffff );
    return t;
  }


  /** Call stack */
  void pushpc() { pushw( PC() ); }
  void poppc()  { PC( popw() ); }



  int bordercolor;

  /** IO ports */
  void outb( int port, int bite, int tstates ) {
    if ( (port & 0x0001) == 0 ) {
      bordercolor = (bite & 0x07);
    }
  }

  int inb( int port ) {
    int res = 0xff;

    if((port & 31) == 31) {
      res=JoyState;
    } else if ( (port & 0x0001) == 0 ) {
      if ( (port & 0x8000) == 0 ) { res &= Keys_B_SPC; }
      if ( (port & 0x0800) == 0 ) { res &= Keys_1_5;   }
      if ( (port & 0x4000) == 0 ) { res &= Keys_H_ENT; }
      if ( (port & 0x1000) == 0 ) { res &= Keys_6_0;   }
      if ( (port & 0x2000) == 0 ) { res &= Keys_Y_P;   }
      if ( (port & 0x0200) == 0 ) { res &= Keys_A_G;   }
      if ( (port & 0x0400) == 0 ) { res &= Keys_Q_T;   }
      if ( (port & 0x0100) == 0 ) { res &= Keys_CAPS_V;}

      /*if ( (port & 0x8000) == 0 ) { res &= _B_SPC; }
      if ( (port & 0x4000) == 0 ) { res &= _H_ENT; }
      if ( (port & 0x1000) == 0 ) { res &= _6_0;   }
      if ( (port & 0x0800) == 0 ) { res &= _1_5;   }
      if ( (port & 0x0400) == 0 ) { res &= _Q_T;   }
      if ( (port & 0x0100) == 0 ) { res &= _CAPS_V;}*/
    }

    return(res);
  }

  /** Interrupt handlers */
  private inline int interruptTriggered( int tstates ) {
    return (tstates >= 0);
  }

   int interrupt() {
    // If not a non-maskable interrupt
    if ( !IFF1() ) {
      return 0;
    }

    switch( IM() ) {
    case IM0:
    case IM1:
      pushpc();
      IFF1( false );
      IFF2( false );
      PC( 56 );
      return 13;
    case IM2:
      pushpc();
      IFF1( false );
      IFF2( false );
      int t = (I()<<8) | 0x00ff;
      PC( peekw(t) );
      return 19;
    }

    return 0;
  }

  /** EX AF,AF' */
  void ex_af_af() {
    int   t;
    t = AF(); AF( _AF_ ); _AF_ = t;
  }

  /** Quick Increment : no flags */
  private inline int inc16( int a ) { return (a + 1) & 0xffff; }
  private inline int qinc8( int a ) { return (a + 1) & 0xff; }

  /** Quick Decrement : no flags */
  private inline int dec16( int a ) { return (a - 1) & 0xffff; }
  private inline int qdec8( int a ) { return (a - 1) & 0xff; }

  /** Bit toggling */
  private inline int res( int bit, int val ) { return val & ~bit; }
  private inline int set( int bit, int val ) { return val |  bit; }

  private  int in_bc() {
    int        ans = inb( BC() );

    setZ( ans == 0 );
    setS( (ans & F_S)!=0 );
    set3( (ans & F_3)!=0 );
    set5( (ans & F_5)!=0 );
    setPV( parity[ ans ] );
    setN( false );
    setH( false );

    return ans;
  }

  /** Add with carry - alters all flags (CHECKED) */
  private  void
  adc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a + b + c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f) + c) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Add - alters all flags (CHECKED) */
  private  void
  add_a( int b )
  {
    int a    = A();
    int wans = a + b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f)) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Subtract with carry - alters all flags (CHECKED) */
  private  void
  sbc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a - b - c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f) - c) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Subtract - alters all flags (CHECKED) */
  private  void
  sub_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Rotate Left - alters H N C 3 5 flags (CHECKED) */
  private  void
  rlc_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right - alters H N C 3 5 flags (CHECKED) */
  private  void
  rrc_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Left through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rl_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }

    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rr_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Compare - alters all flags (CHECKED) */
  private  void
  cp_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (b & F_3)   != 0 );
    set5( (b & F_5)   != 0 );
    setN( true );
    setZ( ans == 0 );
    setC( (wans & 0x100)!=0 );
    setH( (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
  }

  /** Bitwise and - alters all flags (CHECKED) */
  private  void
  and_a( int b )
  {
    int ans = A() & b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise or - alters all flags (CHECKED) */
  private  void
  or_a( int b )
  {
    int ans = A() | b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise exclusive or - alters all flags (CHECKED) */
  private  void
  xor_a( int b )
  {
    int ans = (A() ^ b) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Negate (Two's complement) - alters all flags (CHECKED) */
  private  void
  neg_a()
  {
    int t = A();

    A( 0 );
    sub_a(t);
  }

  /** One's complement - alters N H 3 5 flags (CHECKED) */
  private  void
  cpl_a()
  {
    int ans = A() ^ 0xff;

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setN( true );

    A( ans );
  }

  /** Decimal Adjust Accumulator - alters all flags (CHECKED) */
  private  void
  daa_a()
  {
    int        ans = A();
    int        incr = 0;
    int    carry = Cset();

    if ((Hset()) || ((ans & 0x0f) > 0x09)) {
      incr |= 0x06;
    }
    if (carry || (ans > 0x9f) || ((ans > 0x8f) && ((ans & 0x0f) > 0x09))) {
      incr |= 0x60;
    }
    if (ans > 0x99) {
      carry = true;
    }
    if (Nset()) {
      sub_a(incr);
    } else {
      add_a(incr);
    }

    ans = A();

    setC( carry );
    setPV( parity[ ans ] );
  }

  /** Load a with i - (NOT CHECKED) */
  private  void
  ld_a_i()
  {
    int ans = I();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Load a with r - (NOT CHECKED) */
  private  void
  ld_a_r()
  {
    int ans = R();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate right through a and (hl) - (NOT CHECKED) */
  private  void
  rrd_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t >> 4) | (ans << 4);
    ans = (ans & 0xf0) | (q & 0x0f);
    pokeb( HL(), t );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate left through a and (hl) - (NOT CHECKED) */
  private  void
  rld_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t << 4) | (ans & 0x0f);
    ans = (ans & 0xf0) | (q >> 4);
    pokeb( HL(), (t & 0xff) );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Test bit - alters all but C flag (CHECKED) */
  private  void
  bit( int b, int r )
  {
    int    bitSet = ((r & b) != 0);

    setN( false );
    setH( true );
    set3( (r & F_3) != 0 );
    set5( (r & F_5) != 0 );
    setS( (b == F_S) ? bitSet : false );
    setZ(  !bitSet );
    setPV( !bitSet );
  }

  /** Set carry flag - alters N H 3 5 C flags (CHECKED) */
  private  void
  scf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setH( false );
    setC( true );
  }

  /** Complement carry flag - alters N 3 5 C flags (CHECKED) */
  private  void
  ccf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setC( Cset() ? false : true );
  }

  /** Rotate left - alters all flags (CHECKED) */
  private  int
  rlc( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right - alters all flags (CHECKED) */
  private  int
  rrc( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate left through carry - alters all flags (CHECKED) */
  private  int
  rl( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right through carry - alters all flags (CHECKED) */
  private  int
  rr( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left Arithmetically - alters all flags (CHECKED) */
  private  int
  sla( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = (ans << 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left and Set - alters all flags (CHECKED) */
  private  int
  sls( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = ((ans << 1) | 0x01) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Arithmetically - alters all flags (CHECKED) */
  private  int
  sra( int ans )
  {
    int c = (ans & 0x01) != 0;
    ans = (ans >> 1) | (ans & 0x80);

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Logically - alters all flags (CHECKED) */
  private  int srl( int ans ) {
    int c = (ans & 0x01) != 0;
    ans = ans >> 1;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Decrement - alters all but C flag (CHECKED) */
  private  int dec8( int ans ) {
    int    pv = (ans == 0x80);
    int    h  = (((ans & 0x0f) - 1) & F_H) != 0;
    ans = (ans - 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( true );

    return(ans);
  }

  /** Increment - alters all but C flag (CHECKED) */
  private  int inc8( int ans ) {
    int    pv = (ans == 0x7f);
    int    h  = (((ans & 0x0f) + 1) & F_H) != 0;
    ans = (ans + 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int adc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a + b + c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff) + c) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add - (NOT CHECKED) */
  private  int add16( int a, int b ) {
    int lans = a + b;
    int ans  = lans & 0xffff;

    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setC( (lans & 0x10000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff)) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int sbc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a - b - c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) - (b & 0x0fff) - c) & 0x1000)!=0 );
    setN( true );

    return(ans);
  }

  /** EXX */
  void exx() {
    int t;

    t = HL();
    HL( _HL_ );
    _HL_ = t;

    t = DE();
    DE( _DE_ );
    _DE_ = t;

    t = BC();
    BC( _BC_ );
    _BC_ = t;
  }

  private  int execute_ed( int local_tstates ) {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case 0:  /* NOP */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:

    case 164:
    case 165:
    case 166:
    case 167:

    case 172:
    case 173:
    case 174:
    case 175:

    case 180:
    case 181:
    case 182:
    case 183:
    {
      return ( 8 );
    }

    /* IN r,(c) */
    case 64:  /* IN B,(c) */
    { B( in_bc() ); return ( 12 ); }
    case 72:  /* IN C,(c) */
    { C( in_bc() ); return ( 12 ); }
    case 80:  /* IN D,(c) */
    { D( in_bc() ); return ( 12 ); }
    case 88:  /* IN E,(c) */
    { E( in_bc() ); return ( 12 ); }
    case 96:  /* IN H,(c) */
    { H( in_bc() ); return ( 12 ); }
    case 104:  /* IN L,(c) */
    { L( in_bc() ); return ( 12 ); }
    case 112:  /* IN (c) */
    { in_bc(); return ( 12 ); }
    case 120:  /* IN A,(c) */
    { A( in_bc() ); return ( 12 ); }

    /* OUT (c),r */
    case 65:  /* OUT (c),B */
    { outb( BC(), B(), local_tstates ); return ( 12 ); }
    case 73:  /* OUT (c),C */
    { outb( BC(), C(), local_tstates ); return ( 12 ); }
    case 81:  /* OUT (c),D */
    { outb( BC(), D(), local_tstates ); return ( 12 ); }
    case 89:  /* OUT (c),E */
    { outb( BC(), E(), local_tstates ); return ( 12 ); }
    case 97:  /* OUT (c),H */
    { outb( BC(), H(), local_tstates ); return ( 12 ); }
    case 105:  /* OUT (c),L */
    { outb( BC(), L(), local_tstates ); return ( 12 ); }
    case 113:  /* OUT (c),0 */
    { outb( BC(), 0, local_tstates ); return ( 12 ); }
    case 121:  /* OUT (c),A */
    { outb( BC(), A(), local_tstates ); return ( 12 ); }

    /* SBC/ADC HL,ss */
    case 66:  /* SBC HL,BC */
    { HL( sbc16( HL(), BC() ) ); return ( 15 ); }
    case 74:  /* ADC HL,BC */
    { HL( adc16( HL(), BC() ) ); return ( 15 ); }
    case 82:  /* SBC HL,DE */
    { HL( sbc16( HL(), DE() ) ); return ( 15 ); }
    case 90:  /* ADC HL,DE */
    { HL( adc16( HL(), DE() ) ); return ( 15 ); }
    case 98:  /* SBC HL,HL */
    {
      int hl = HL();
      HL( sbc16( hl, hl ) );
      return ( 15 );
    }
    case 106:  /* ADC HL,HL */
    {
      int hl = HL();
      HL( adc16( hl, hl ) );
      return ( 15 );
    }
    case 114:  /* SBC HL,SP */
    { HL( sbc16( HL(), SP() ) ); return ( 15 ); }
    case 122:  /* ADC HL,SP */
    { HL( adc16( HL(), SP() ) ); return ( 15 ); }

    /* LD (nn),ss, LD ss,(nn) */
    case 67:  /* LD (nn),BC */
    { pokew( nxtpcw(), BC() ); return ( 20 ); }
    case 75:  /* LD BC(),(nn) */
    { BC( peekw( nxtpcw() ) ); return ( 20 ); }
    case 83:  /* LD (nn),DE */
    { pokew( nxtpcw(), DE() ); return ( 20 ); }
    case 91:  /* LD DE,(nn) */
    { DE( peekw( nxtpcw() ) ); return ( 20 ); }
    case 99:  /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); return ( 20 ); }
    case 107:  /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); return ( 20 ); }
    case 115:  /* LD (nn),SP */
    { pokew( nxtpcw(), SP() ); return ( 20 ); }
    case 123:  /* LD SP,(nn) */
    { SP( peekw( nxtpcw() ) ); return ( 20 ); }

    /* NEG */
    case 68:  /* NEG */
    case 76:  /* NEG */
    case 84:  /* NEG */
    case 92:  /* NEG */
    case 100:  /* NEG */
    case 108:  /* NEG */
    case 116:  /* NEG */
    case 124:  /* NEG */
    { neg_a(); return ( 8 ); }

    /* RETn */
    case 69:  /* RETN */
    case 85:  /* RETN */
    case 101:  /* RETN */
    case 117:  /* RETN */
    {
      IFF1( IFF2() );
      poppc();
      return ( 14 );
    }
    case 77:  /* RETI */
    case 93:  /* RETI */
    case 109:  /* RETI */
    case 125:  /* RETI */
    {
      poppc();
      return ( 14 );
    }

    /* IM x */
    case 70:  /* IM 0 */
    case 78:  /* IM 0 */
    case 102:  /* IM 0 */
    case 110:  /* IM 0 */
    { IM( IM0 ); return ( 8 ); }
    case 86:  /* IM 1 */
    case 118:  /* IM 1 */
    { IM( IM1 ); return ( 8 ); }
    case 94:  /* IM 2 */
    case 126:  /* IM 2 */
    { IM( IM2 ); return ( 8 ); }

    /* LD A,s / LD s,A / RxD */
    case 71:  /* LD I,A */
    { I( A() ); return ( 9 ); }
    case 79:  /* LD R,A */
    { R( A() ); return ( 9 ); }
    case 87:  /* LD A,I */
    { ld_a_i(); return ( 9 ); }
    case 95:  /* LD A,R */
    { ld_a_r(); return ( 9 ); }
    case 103:  /* RRD */
    { rrd_a(); return ( 18 ); }
    case 111:  /* RLD */
    { rld_a(); return ( 18 ); }

    /* xxI */
    case 160:  /* LDI */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( inc16( DE() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 161:  /* CPI */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 162:  /* INI */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 163:  /* OUTI */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxD */
    case 168:  /* LDD */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( dec16( DE() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 169:  /* CPD */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 170:  /* IND */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 171:  /* OUTD */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxIR */
    case 176:  /* LDIR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH( -2 );

      pokeb(dest, peekb(from) );
      from  = inc16( from );
      dest  = inc16( dest );
      count = dec16( count );

      _local_tstates += ( 21 );
      REFRESH( 2 );

      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 177:  /* CPIR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 178:  /* INIR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 179:  /* OTIR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    /* xxDR */
    case 184:  /* LDDR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH ( -2 );

      pokeb(dest, peekb(from));
      from  = dec16( from );
      dest  = dec16( dest );
      count = dec16( count );

      _local_tstates += ( 21 );
      REFRESH( 2 );

      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 185:  /* CPDR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 186:  /* INDR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 187:  /* OTDR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    } // end switch

    // NOP
    return ( 8 );
  }

  private  int execute_cb() {
    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case   0: /* RLC B */
    { B( rlc( B() ) ); return ( 8 ); }
    case   1: /* RLC C */
    { C( rlc( C() ) ); return ( 8 ); }
    case   2: /* RLC D */
    { D( rlc( D() ) ); return ( 8 ); }
    case   3: /* RLC E */
    { E( rlc( E() ) ); return ( 8 ); }
    case   4: /* RLC H */
    { H( rlc( H() ) ); return ( 8 ); }
    case   5: /* RLC L */
    { L( rlc( L() ) ); return ( 8 ); }
    case   6: /* RLC (HL) */
    {
      int hl = HL();
      pokeb( hl, rlc( peekb( hl ) ) );
      return ( 15 );
    }
    case   7: /* RLC A */
    { A( rlc( A() ) ); return ( 8 ); }

    case   8: /* RRC B */
    { B( rrc( B() ) ); return ( 8 ); }
    case   9: /* RRC C */
    { C( rrc( C() ) ); return ( 8 ); }
    case  10: /* RRC D */
    { D( rrc( D() ) ); return ( 8 ); }
    case  11: /* RRC E */
    { E( rrc( E() ) ); return ( 8 ); }
    case  12: /* RRC H */
    { H( rrc( H() ) ); return ( 8 ); }
    case  13: /* RRC L */
    { L( rrc( L() ) ); return ( 8 ); }
    case  14: /* RRC (HL) */
    {
      int hl = HL();
      pokeb( hl, rrc( peekb( hl ) ) );
      return ( 15 );
    }
    case  15: /* RRC A */
    { A( rrc( A() ) ); return ( 8 ); }

    case  16: /* RL B */
    { B( rl( B() ) ); return ( 8 ); }
    case  17: /* RL C */
    { C( rl( C() ) ); return ( 8 ); }
    case  18: /* RL D */
    { D( rl( D() ) ); return ( 8 ); }
    case  19: /* RL E */
    { E( rl( E() ) ); return ( 8 ); }
    case  20: /* RL H */
    { H( rl( H() ) ); return ( 8 ); }
    case  21: /* RL L */
    { L( rl( L() ) ); return ( 8 ); }
    case  22: /* RL (HL) */
    {
      int hl = HL();
      pokeb( hl, rl( peekb( hl ) ) );
      return ( 15 );
    }
    case  23: /* RL A */
    { A( rl( A() ) ); return ( 8 ); }

    case  24: /* RR B */
    { B( rr( B() ) ); return ( 8 ); }
    case  25: /* RR C */
    { C( rr( C() ) ); return ( 8 ); }
    case  26: /* RR D */
    { D( rr( D() ) ); return ( 8 ); }
    case  27: /* RR E */
    { E( rr( E() ) ); return ( 8 ); }
    case  28: /* RR H */
    { H( rr( H() ) ); return ( 8 ); }
    case  29: /* RR L */
    { L( rr( L() ) ); return ( 8 ); }
    case  30: /* RR (HL) */
    {
      int hl = HL();
      pokeb( hl, rr( peekb( hl ) ) );
      return ( 15 );
    }
    case  31: /* RR A */
    { A( rr( A() ) ); return ( 8 ); }

    case  32: /* SLA B */
    { B( sla( B() ) ); return ( 8 ); }
    case  33: /* SLA C */
    { C( sla( C() ) ); return ( 8 ); }
    case  34: /* SLA D */
    { D( sla( D() ) ); return ( 8 ); }
    case  35: /* SLA E */
    { E( sla( E() ) ); return ( 8 ); }
    case  36: /* SLA H */
    { H( sla( H() ) ); return ( 8 ); }
    case  37: /* SLA L */
    { L( sla( L() ) ); return ( 8 ); }
    case  38: /* SLA (HL) */
    {
      int hl = HL();
      pokeb( hl, sla( peekb( hl ) ) );
      return ( 15 );
    }
    case  39: /* SLA A */
    { A( sla( A() ) ); return ( 8 ); }

    case  40: /* SRA B */
    { B( sra( B() ) ); return ( 8 ); }
    case  41: /* SRA C */
    { C( sra( C() ) ); return ( 8 ); }
    case  42: /* SRA D */
    { D( sra( D() ) ); return ( 8 ); }
    case  43: /* SRA E */
    { E( sra( E() ) ); return ( 8 ); }
    case  44: /* SRA H */
    { H( sra( H() ) ); return ( 8 ); }
    case  45: /* SRA L */
    { L( sra( L() ) ); return ( 8 ); }
    case  46: /* SRA (HL) */
    {
      int hl = HL();
      pokeb( hl, sra( peekb( hl ) ) );
      return ( 15 );
    }
    case  47: /* SRA A */
    { A( sra( A() ) ); return ( 8 ); }

    case  48: /* SLS B */
    { B( sls( B() ) ); return ( 8 ); }
    case  49: /* SLS C */
    { C( sls( C() ) ); return ( 8 ); }
    case  50: /* SLS D */
    { D( sls( D() ) ); return ( 8 ); }
    case  51: /* SLS E */
    { E( sls( E() ) ); return ( 8 ); }
    case  52: /* SLS H */
    { H( sls( H() ) ); return ( 8 ); }
    case  53: /* SLS L */
    { L( sls( L() ) ); return ( 8 ); }
    case  54: /* SLS (HL) */
    {
      int hl = HL();
      pokeb( hl, sls( peekb( hl ) ) );
      return ( 15 );
    }
    case  55: /* SLS A */
    { A( sls( A() ) ); return ( 8 ); }

    case  56: /* SRL B */
    { B( srl( B() ) ); return ( 8 ); }
    case  57: /* SRL C */
    { C( srl( C() ) ); return ( 8 ); }
    case  58: /* SRL D */
    { D( srl( D() ) ); return ( 8 ); }
    case  59: /* SRL E */
    { E( srl( E() ) ); return ( 8 ); }
    case  60: /* SRL H */
    { H( srl( H() ) ); return ( 8 ); }
    case  61: /* SRL L */
    { L( srl( L() ) ); return ( 8 ); }
    case  62: /* SRL (HL) */
    {
      int hl = HL();
      pokeb( hl, srl( peekb( hl ) ) );
      return ( 15 );
    }
    case  63: /* SRL A */
    { A( srl( A() ) ); return ( 8 ); }

    case  64: /* BIT 0,B */
    { bit( 0x01, B() ); return ( 8 ); }
    case  65: /* BIT 0,C */
    { bit( 0x01, C() ); return ( 8 ); }
    case  66: /* BIT 0,D */
    { bit( 0x01, D() ); return ( 8 ); }
    case  67: /* BIT 0,E */
    { bit( 0x01, E() ); return ( 8 ); }
    case  68: /* BIT 0,H */
    { bit( 0x01, H() ); return ( 8 ); }
    case  69: /* BIT 0,L */
    { bit( 0x01, L() ); return ( 8 ); }
    case  70: /* BIT 0,(HL) */
    { bit( 0x01, peekb( HL() ) ); return ( 12 ); }
    case  71: /* BIT 0,A */
    { bit( 0x01, A() ); return ( 8 ); }

    case  72: /* BIT 1,B */
    { bit( 0x02, B() ); return ( 8 ); }
    case  73: /* BIT 1,C */
    { bit( 0x02, C() ); return ( 8 ); }
    case  74: /* BIT 1,D */
    { bit( 0x02, D() ); return ( 8 ); }
    case  75: /* BIT 1,E */
    { bit( 0x02, E() ); return ( 8 ); }
    case  76: /* BIT 1,H */
    { bit( 0x02, H() ); return ( 8 ); }
    case  77: /* BIT 1,L */
    { bit( 0x02, L() ); return ( 8 ); }
    case  78: /* BIT 1,(HL) */
    { bit( 0x02, peekb( HL() ) ); return ( 12 ); }
    case  79: /* BIT 1,A */
    { bit( 0x02, A() ); return ( 8 ); }

    case  80: /* BIT 2,B */
    { bit( 0x04, B() ); return ( 8 ); }
    case  81: /* BIT 2,C */
    { bit( 0x04, C() ); return ( 8 ); }
    case  82: /* BIT 2,D */
    { bit( 0x04, D() ); return ( 8 ); }
    case  83: /* BIT 2,E */
    { bit( 0x04, E() ); return ( 8 ); }
    case  84: /* BIT 2,H */
    { bit( 0x04, H() ); return ( 8 ); }
    case  85: /* BIT 2,L */
    { bit( 0x04, L() ); return ( 8 ); }
    case  86: /* BIT 2,(HL) */
    { bit( 0x04, peekb( HL() ) ); return ( 12 ); }
    case  87: /* BIT 2,A */
    { bit( 0x04, A() ); return ( 8 ); }

    case  88: /* BIT 3,B */
    { bit( 0x08, B() ); return ( 8 ); }
    case  89: /* BIT 3,C */
    { bit( 0x08, C() ); return ( 8 ); }
    case  90: /* BIT 3,D */
    { bit( 0x08, D() ); return ( 8 ); }
    case  91: /* BIT 3,E */
    { bit( 0x08, E() ); return ( 8 ); }
    case  92: /* BIT 3,H */
    { bit( 0x08, H() ); return ( 8 ); }
    case  93: /* BIT 3,L */
    { bit( 0x08, L() ); return ( 8 ); }
    case  94: /* BIT 3,(HL) */
    { bit( 0x08, peekb( HL() ) ); return ( 12 ); }
    case  95: /* BIT 3,A */
    { bit( 0x08, A() ); return ( 8 ); }

    case  96: /* BIT 4,B */
    { bit( 0x10, B() ); return ( 8 ); }
    case  97: /* BIT 4,C */
    { bit( 0x10, C() ); return ( 8 ); }
    case  98: /* BIT 4,D */
    { bit( 0x10, D() ); return ( 8 ); }
    case  99: /* BIT 4,E */
    { bit( 0x10, E() ); return ( 8 ); }
    case 100: /* BIT 4,H */
    { bit( 0x10, H() ); return ( 8 ); }
    case 101: /* BIT 4,L */
    { bit( 0x10, L() ); return ( 8 ); }
    case 102: /* BIT 4,(HL) */
    { bit( 0x10, peekb( HL() ) ); return ( 12 ); }
    case 103: /* BIT 4,A */
    { bit( 0x10, A() ); return ( 8 ); }

    case 104: /* BIT 5,B */
    { bit( 0x20, B() ); return ( 8 ); }
    case 105: /* BIT 5,C */
    { bit( 0x20, C() ); return ( 8 ); }
    case 106: /* BIT 5,D */
    { bit( 0x20, D() ); return ( 8 ); }
    case 107: /* BIT 5,E */
    { bit( 0x20, E() ); return ( 8 ); }
    case 108: /* BIT 5,H */
    { bit( 0x20, H() ); return ( 8 ); }
    case 109: /* BIT 5,L */
    { bit( 0x20, L() ); return ( 8 ); }
    case 110: /* BIT 5,(HL) */
    { bit( 0x20, peekb( HL() ) ); return ( 12 ); }
    case 111: /* BIT 5,A */
    { bit( 0x20, A() ); return ( 8 ); }

    case 112: /* BIT 6,B */
    { bit( 0x40, B() ); return ( 8 ); }
    case 113: /* BIT 6,C */
    { bit( 0x40, C() ); return ( 8 ); }
    case 114: /* BIT 6,D */
    { bit( 0x40, D() ); return ( 8 ); }
    case 115: /* BIT 6,E */
    { bit( 0x40, E() ); return ( 8 ); }
    case 116: /* BIT 6,H */
    { bit( 0x40, H() ); return ( 8 ); }
    case 117: /* BIT 6,L */
    { bit( 0x40, L() ); return ( 8 ); }
    case 118: /* BIT 6,(HL) */
    { bit( 0x40, peekb( HL() ) ); return ( 12 ); }
    case 119: /* BIT 6,A */
    { bit( 0x40, A() ); return ( 8 ); }

    case 120: /* BIT 7,B */
    { bit( 0x80, B() ); return ( 8 ); }
    case 121: /* BIT 7,C */
    { bit( 0x80, C() ); return ( 8 ); }
    case 122: /* BIT 7,D */
    { bit( 0x80, D() ); return ( 8 ); }
    case 123: /* BIT 7,E */
    { bit( 0x80, E() ); return ( 8 ); }
    case 124: /* BIT 7,H */
    { bit( 0x80, H() ); return ( 8 ); }
    case 125: /* BIT 7,L */
    { bit( 0x80, L() ); return ( 8 ); }
    case 126: /* BIT 7,(HL) */
    { bit( 0x80, peekb( HL() ) ); return ( 12 ); }
    case 127: /* BIT 7,A */
    { bit( 0x80, A() ); return ( 8 ); }

    case 128: /* RES 0,B */
    { B( res( 0x01, B() ) ); return ( 8 ); }
    case 129: /* RES 0,C */
    { C( res( 0x01, C() ) ); return ( 8 ); }
    case 130: /* RES 0,D */
    { D( res( 0x01, D() ) ); return ( 8 ); }
    case 131: /* RES 0,E */
    { E( res( 0x01, E() ) ); return ( 8 ); }
    case 132: /* RES 0,H */
    { H( res( 0x01, H() ) ); return ( 8 ); }
    case 133: /* RES 0,L */
    { L( res( 0x01, L() ) ); return ( 8 ); }
    case 134: /* RES 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 135: /* RES 0,A */
    { A( res( 0x01, A() ) ); return ( 8 ); }

    case 136: /* RES 1,B */
    { B( res( 0x02, B() ) ); return ( 8 ); }
    case 137: /* RES 1,C */
    { C( res( 0x02, C() ) ); return ( 8 ); }
    case 138: /* RES 1,D */
    { D( res( 0x02, D() ) ); return ( 8 ); }
    case 139: /* RES 1,E */
    { E( res( 0x02, E() ) ); return ( 8 ); }
    case 140: /* RES 1,H */
    { H( res( 0x02, H() ) ); return ( 8 ); }
    case 141: /* RES 1,L */
    { L( res( 0x02, L() ) ); return ( 8 ); }
    case 142: /* RES 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 143: /* RES 1,A */
    { A( res( 0x02, A() ) ); return ( 8 ); }

    case 144: /* RES 2,B */
    { B( res( 0x04, B() ) ); return ( 8 ); }
    case 145: /* RES 2,C */
    { C( res( 0x04, C() ) ); return ( 8 ); }
    case 146: /* RES 2,D */
    { D( res( 0x04, D() ) ); return ( 8 ); }
    case 147: /* RES 2,E */
    { E( res( 0x04, E() ) ); return ( 8 ); }
    case 148: /* RES 2,H */
    { H( res( 0x04, H() ) ); return ( 8 ); }
    case 149: /* RES 2,L */
    { L( res( 0x04, L() ) ); return ( 8 ); }
    case 150: /* RES 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 151: /* RES 2,A */
    { A( res( 0x04, A() ) ); return ( 8 ); }

    case 152: /* RES 3,B */
    { B( res( 0x08, B() ) ); return ( 8 ); }
    case 153: /* RES 3,C */
    { C( res( 0x08, C() ) ); return ( 8 ); }
    case 154: /* RES 3,D */
    { D( res( 0x08, D() ) ); return ( 8 ); }
    case 155: /* RES 3,E */
    { E( res( 0x08, E() ) ); return ( 8 ); }
    case 156: /* RES 3,H */
    { H( res( 0x08, H() ) ); return ( 8 ); }
    case 157: /* RES 3,L */
    { L( res( 0x08, L() ) ); return ( 8 ); }
    case 158: /* RES 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 159: /* RES 3,A */
    { A( res( 0x08, A() ) ); return ( 8 ); }

    case 160: /* RES 4,B */
    { B( res( 0x10, B() ) ); return ( 8 ); }
    case 161: /* RES 4,C */
    { C( res( 0x10, C() ) ); return ( 8 ); }
    case 162: /* RES 4,D */
    { D( res( 0x10, D() ) ); return ( 8 ); }
    case 163: /* RES 4,E */
    { E( res( 0x10, E() ) ); return ( 8 ); }
    case 164: /* RES 4,H */
    { H( res( 0x10, H() ) ); return ( 8 ); }
    case 165: /* RES 4,L */
    { L( res( 0x10, L() ) ); return ( 8 ); }
    case 166: /* RES 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 167: /* RES 4,A */
    { A( res( 0x10, A() ) ); return ( 8 ); }

    case 168: /* RES 5,B */
    { B( res( 0x20, B() ) ); return ( 8 ); }
    case 169: /* RES 5,C */
    { C( res( 0x20, C() ) ); return ( 8 ); }
    case 170: /* RES 5,D */
    { D( res( 0x20, D() ) ); return ( 8 ); }
    case 171: /* RES 5,E */
    { E( res( 0x20, E() ) ); return ( 8 ); }
    case 172: /* RES 5,H */
    { H( res( 0x20, H() ) ); return ( 8 ); }
    case 173: /* RES 5,L */
    { L( res( 0x20, L() ) ); return ( 8 ); }
    case 174: /* RES 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 175: /* RES 5,A */
    { A( res( 0x20, A() ) ); return ( 8 ); }

    case 176: /* RES 6,B */
    { B( res( 0x40, B() ) ); return ( 8 ); }
    case 177: /* RES 6,C */
    { C( res( 0x40, C() ) ); return ( 8 ); }
    case 178: /* RES 6,D */
    { D( res( 0x40, D() ) ); return ( 8 ); }
    case 179: /* RES 6,E */
    { E( res( 0x40, E() ) ); return ( 8 ); }
    case 180: /* RES 6,H */
    { H( res( 0x40, H() ) ); return ( 8 ); }
    case 181: /* RES 6,L */
    { L( res( 0x40, L() ) ); return ( 8 ); }
    case 182: /* RES 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 183: /* RES 6,A */
    { A( res( 0x40, A() ) ); return ( 8 ); }

    case 184: /* RES 7,B */
    { B( res( 0x80, B() ) ); return ( 8 ); }
    case 185: /* RES 7,C */
    { C( res( 0x80, C() ) ); return ( 8 ); }
    case 186: /* RES 7,D */
    { D( res( 0x80, D() ) ); return ( 8 ); }
    case 187: /* RES 7,E */
    { E( res( 0x80, E() ) ); return ( 8 ); }
    case 188: /* RES 7,H */
    { H( res( 0x80, H() ) ); return ( 8 ); }
    case 189: /* RES 7,L */
    { L( res( 0x80, L() ) ); return ( 8 ); }
    case 190: /* RES 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 191: /* RES 7,A */
    { A( res( 0x80, A() ) ); return ( 8 ); }

    case 192: /* SET 0,B */
    { B( set( 0x01, B() ) ); return ( 8 ); }
    case 193: /* SET 0,C */
    { C( set( 0x01, C() ) ); return ( 8 ); }
    case 194: /* SET 0,D */
    { D( set( 0x01, D() ) ); return ( 8 ); }
    case 195: /* SET 0,E */
    { E( set( 0x01, E() ) ); return ( 8 ); }
    case 196: /* SET 0,H */
    { H( set( 0x01, H() ) ); return ( 8 ); }
    case 197: /* SET 0,L */
    { L( set( 0x01, L() ) ); return ( 8 ); }
    case 198: /* SET 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 199: /* SET 0,A */
    { A( set( 0x01, A() ) ); return ( 8 ); }

    case 200: /* SET 1,B */
    { B( set( 0x02, B() ) ); return ( 8 ); }
    case 201: /* SET 1,C */
    { C( set( 0x02, C() ) ); return ( 8 ); }
    case 202: /* SET 1,D */
    { D( set( 0x02, D() ) ); return ( 8 ); }
    case 203: /* SET 1,E */
    { E( set( 0x02, E() ) ); return ( 8 ); }
    case 204: /* SET 1,H */
    { H( set( 0x02, H() ) ); return ( 8 ); }
    case 205: /* SET 1,L */
    { L( set( 0x02, L() ) ); return ( 8 ); }
    case 206: /* SET 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 207: /* SET 1,A */
    { A( set( 0x02, A() ) ); return ( 8 ); }

    case 208: /* SET 2,B */
    { B( set( 0x04, B() ) ); return ( 8 ); }
    case 209: /* SET 2,C */
    { C( set( 0x04, C() ) ); return ( 8 ); }
    case 210: /* SET 2,D */
    { D( set( 0x04, D() ) ); return ( 8 ); }
    case 211: /* SET 2,E */
    { E( set( 0x04, E() ) ); return ( 8 ); }
    case 212: /* SET 2,H */
    { H( set( 0x04, H() ) ); return ( 8 ); }
    case 213: /* SET 2,L */
    { L( set( 0x04, L() ) ); return ( 8 ); }
    case 214: /* SET 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 215: /* SET 2,A */
    { A( set( 0x04, A() ) ); return ( 8 ); }

    case 216: /* SET 3,B */
    { B( set( 0x08, B() ) ); return ( 8 ); }
    case 217: /* SET 3,C */
    { C( set( 0x08, C() ) ); return ( 8 ); }
    case 218: /* SET 3,D */
    { D( set( 0x08, D() ) ); return ( 8 ); }
    case 219: /* SET 3,E */
    { E( set( 0x08, E() ) ); return ( 8 ); }
    case 220: /* SET 3,H */
    { H( set( 0x08, H() ) ); return ( 8 ); }
    case 221: /* SET 3,L */
    { L( set( 0x08, L() ) ); return ( 8 ); }
    case 222: /* SET 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 223: /* SET 3,A */
    { A( set( 0x08, A() ) ); return ( 8 ); }

    case 224: /* SET 4,B */
    { B( set( 0x10, B() ) ); return ( 8 ); }
    case 225: /* SET 4,C */
    { C( set( 0x10, C() ) ); return ( 8 ); }
    case 226: /* SET 4,D */
    { D( set( 0x10, D() ) ); return ( 8 ); }
    case 227: /* SET 4,E */
    { E( set( 0x10, E() ) ); return ( 8 ); }
    case 228: /* SET 4,H */
    { H( set( 0x10, H() ) ); return ( 8 ); }
    case 229: /* SET 4,L */
    { L( set( 0x10, L() ) ); return ( 8 ); }
    case 230: /* SET 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 231: /* SET 4,A */
    { A( set( 0x10, A() ) ); return ( 8 ); }

    case 232: /* SET 5,B */
    { B( set( 0x20, B() ) ); return ( 8 ); }
    case 233: /* SET 5,C */
    { C( set( 0x20, C() ) ); return ( 8 ); }
    case 234: /* SET 5,D */
    { D( set( 0x20, D() ) ); return ( 8 ); }
    case 235: /* SET 5,E */
    { E( set( 0x20, E() ) ); return ( 8 ); }
    case 236: /* SET 5,H */
    { H( set( 0x20, H() ) ); return ( 8 ); }
    case 237: /* SET 5,L */
    { L( set( 0x20, L() ) ); return ( 8 ); }
    case 238: /* SET 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 239: /* SET 5,A */
    { A( set( 0x20, A() ) ); return ( 8 ); }

    case 240: /* SET 6,B */
    { B( set( 0x40, B() ) ); return ( 8 ); }
    case 241: /* SET 6,C */
    { C( set( 0x40, C() ) ); return ( 8 ); }
    case 242: /* SET 6,D */
    { D( set( 0x40, D() ) ); return ( 8 ); }
    case 243: /* SET 6,E */
    { E( set( 0x40, E() ) ); return ( 8 ); }
    case 244: /* SET 6,H */
    { H( set( 0x40, H() ) ); return ( 8 ); }
    case 245: /* SET 6,L */
    { L( set( 0x40, L() ) ); return ( 8 ); }
    case 246: /* SET 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 247: /* SET 6,A */
    { A( set( 0x40, A() ) ); return ( 8 ); }

    case 248: /* SET 7,B */
    { B( set( 0x80, B() ) ); return ( 8 ); }
    case 249: /* SET 7,C */
    { C( set( 0x80, C() ) ); return ( 8 ); }
    case 250: /* SET 7,D */
    { D( set( 0x80, D() ) ); return ( 8 ); }
    case 251: /* SET 7,E */
    { E( set( 0x80, E() ) ); return ( 8 ); }
    case 252: /* SET 7,H */
    { H( set( 0x80, H() ) ); return ( 8 ); }
    case 253: /* SET 7,L */
    { L( set( 0x80, L() ) ); return ( 8 ); }
    case 254: /* SET 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 255: /* SET 7,A */
    { A( set( 0x80, A() ) ); return ( 8 ); }

    } // end switch

    return 0;
  }

  private  void execute_id_cb(int op, int z) {

    switch ( op ) {

    case   0: /* RLC B */
    { B( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   1: /* RLC C */
    { C( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   2: /* RLC D */
    { D( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   3: /* RLC E */
    { E( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   4: /* RLC H */
    { H( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   5: /* RLC L */
    { L( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   6: /* RLC (HL) */
    { pokeb( z, rlc( peekb( z ) ) ); return; }
    case   7: /* RLC A */
    { A( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }

    case   8: /* RRC B */
    { B( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   9: /* RRC C */
    { C( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  10: /* RRC D */
    { D( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  11: /* RRC E */
    { E( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  12: /* RRC H */
    { H( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  13: /* RRC L */
    { L( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  14: /* RRC (HL) */
    { pokeb( z, rrc( peekb( z ) ) ); return; }
    case  15: /* RRC A */
    { A( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }

    case  16: /* RL B */
    { B( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  17: /* RL C */
    { C( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  18: /* RL D */
    { D( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  19: /* RL E */
    { E( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  20: /* RL H */
    { H( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  21: /* RL L */
    { L( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  22: /* RL (HL) */
    { pokeb( z, rl( peekb( z ) ) ); return; }
    case  23: /* RL A */
    { A( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  24: /* RR B */
    { B( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  25: /* RR C */
    { C( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  26: /* RR D */
    { D( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  27: /* RR E */
    { E( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  28: /* RR H */
    { H( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  29: /* RR L */
    { L( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  30: /* RR (HL) */
    { pokeb( z, rr( peekb( z ) ) ); return; }
    case  31: /* RR A */
    { A( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }

    case  32: /* SLA B */
    { B( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  33: /* SLA C */
    { C( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  34: /* SLA D */
    { D( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  35: /* SLA E */
    { E( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  36: /* SLA H */
    { H( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  37: /* SLA L */
    { L( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  38: /* SLA (HL) */
    { pokeb( z, sla( peekb( z ) ) ); return; }
    case  39: /* SLA A */
    { A( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }

    case  40: /* SRA B */
    { B( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  41: /* SRA C */
    { C( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  42: /* SRA D */
    { D( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  43: /* SRA E */
    { E( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  44: /* SRA H */
    { H( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  45: /* SRA L */
    { L( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  46: /* SRA (HL) */
    { pokeb( z, sra( peekb( z ) ) ); return; }
    case  47: /* SRA A */
    { A( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }

    case  48: /* SLS B */
    { B( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  49: /* SLS C */
    { C( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  50: /* SLS D */
    { D( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  51: /* SLS E */
    { E( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  52: /* SLS H */
    { H( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  53: /* SLS L */
    { L( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  54: /* SLS (HL) */
    { pokeb( z, sls( peekb( z ) ) ); return; }
    case  55: /* SLS A */
    { A( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }

    case  56: /* SRL B */
    { B( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  57: /* SRL C */
    { C( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  58: /* SRL D */
    { D( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  59: /* SRL E */
    { E( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  60: /* SRL H */
    { H( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  61: /* SRL L */
    { L( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  62: /* SRL (HL) */
    { pokeb( z, srl( peekb( z ) ) ); return; }
    case  63: /* SRL A */
    { A( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  64: /* BIT 0,B */
    case  65: /* BIT 0,B */
    case  66: /* BIT 0,B */
    case  67: /* BIT 0,B */
    case  68: /* BIT 0,B */
    case  69: /* BIT 0,B */
    case  70: /* BIT 0,B */
    case  71: /* BIT 0,B */
    { bit( 0x01, peekb( z ) ); return; }

    case  72: /* BIT 1,B */
    case  73: /* BIT 1,B */
    case  74: /* BIT 1,B */
    case  75: /* BIT 1,B */
    case  76: /* BIT 1,B */
    case  77: /* BIT 1,B */
    case  78: /* BIT 1,B */
    case  79: /* BIT 1,B */
    { bit( 0x02, peekb( z ) ); return; }

    case  80: /* BIT 2,B */
    case  81: /* BIT 2,B */
    case  82: /* BIT 2,B */
    case  83: /* BIT 2,B */
    case  84: /* BIT 2,B */
    case  85: /* BIT 2,B */
    case  86: /* BIT 2,B */
    case  87: /* BIT 2,B */
    { bit( 0x04, peekb( z ) ); return; }

    case  88: /* BIT 3,B */
    case  89: /* BIT 3,B */
    case  90: /* BIT 3,B */
    case  91: /* BIT 3,B */
    case  92: /* BIT 3,B */
    case  93: /* BIT 3,B */
    case  94: /* BIT 3,B */
    case  95: /* BIT 3,B */
    { bit( 0x08, peekb( z ) ); return; }

    case  96: /* BIT 4,B */
    case  97: /* BIT 4,B */
    case  98: /* BIT 4,B */
    case  99: /* BIT 4,B */
    case 100: /* BIT 4,B */
    case 101: /* BIT 4,B */
    case 102: /* BIT 4,B */
    case 103: /* BIT 4,B */
    { bit( 0x10, peekb( z ) ); return; }

    case 104: /* BIT 5,B */
    case 105: /* BIT 5,B */
    case 106: /* BIT 5,B */
    case 107: /* BIT 5,B */
    case 108: /* BIT 5,B */
    case 109: /* BIT 5,B */
    case 110: /* BIT 5,B */
    case 111: /* BIT 5,B */
    { bit( 0x20, peekb( z ) ); return; }

    case 112: /* BIT 6,B */
    case 113: /* BIT 6,B */
    case 114: /* BIT 6,B */
    case 115: /* BIT 6,B */
    case 116: /* BIT 6,B */
    case 117: /* BIT 6,B */
    case 118: /* BIT 6,B */
    case 119: /* BIT 6,B */
    { bit( 0x40, peekb( z ) ); return; }

    case 120: /* BIT 7,B */
    case 121: /* BIT 7,B */
    case 122: /* BIT 7,B */
    case 123: /* BIT 7,B */
    case 124: /* BIT 7,B */
    case 125: /* BIT 7,B */
    case 126: /* BIT 7,B */
    case 127: /* BIT 7,B */
    { bit( 0x80, peekb( z ) ); return; }

    case 128: /* RES 0,B */
    { B( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 129: /* RES 0,C */
    { C( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 130: /* RES 0,D */
    { D( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 131: /* RES 0,E */
    { E( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 132: /* RES 0,H */
    { H( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 133: /* RES 0,L */
    { L( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 134: /* RES 0,(HL) */
    { pokeb( z, res( 0x01, peekb( z ) ) ); return; }
    case 135: /* RES 0,A */
    { A( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 136: /* RES 1,B */
    { B( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 137: /* RES 1,C */
    { C( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 138: /* RES 1,D */
    { D( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 139: /* RES 1,E */
    { E( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 140: /* RES 1,H */
    { H( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 141: /* RES 1,L */
    { L( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 142: /* RES 1,(HL) */
    { pokeb( z, res( 0x02, peekb( z ) ) ); return; }
    case 143: /* RES 1,A */
    { A( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 144: /* RES 2,B */
    { B( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 145: /* RES 2,C */
    { C( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 146: /* RES 2,D */
    { D( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 147: /* RES 2,E */
    { E( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 148: /* RES 2,H */
    { H( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 149: /* RES 2,L */
    { L( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 150: /* RES 2,(HL) */
    { pokeb( z, res( 0x04, peekb( z ) ) ); return; }
    case 151: /* RES 2,A */
    { A( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 152: /* RES 3,B */
    { B( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 153: /* RES 3,C */
    { C( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 154: /* RES 3,D */
    { D( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 155: /* RES 3,E */
    { E( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 156: /* RES 3,H */
    { H( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 157: /* RES 3,L */
    { L( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 158: /* RES 3,(HL) */
    { pokeb( z, res( 0x08, peekb( z ) ) ); return; }
    case 159: /* RES 3,A */
    { A( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 160: /* RES 4,B */
    { B( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 161: /* RES 4,C */
    { C( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 162: /* RES 4,D */
    { D( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 163: /* RES 4,E */
    { E( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 164: /* RES 4,H */
    { H( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 165: /* RES 4,L */
    { L( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 166: /* RES 4,(HL) */
    { pokeb( z, res( 0x10, peekb( z ) ) ); return; }
    case 167: /* RES 4,A */
    { A( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 168: /* RES 5,B */
    { B( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 169: /* RES 5,C */
    { C( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 170: /* RES 5,D */
    { D( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 171: /* RES 5,E */
    { E( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 172: /* RES 5,H */
    { H( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 173: /* RES 5,L */
    { L( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 174: /* RES 5,(HL) */
    { pokeb( z, res( 0x20, peekb( z ) ) ); return; }
    case 175: /* RES 5,A */
    { A( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 176: /* RES 6,B */
    { B( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 177: /* RES 6,C */
    { C( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 178: /* RES 6,D */
    { D( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 179: /* RES 6,E */
    { E( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 180: /* RES 6,H */
    { H( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 181: /* RES 6,L */
    { L( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 182: /* RES 6,(HL) */
    { pokeb( z, res( 0x40, peekb( z ) ) ); return; }
    case 183: /* RES 6,A */
    { A( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 184: /* RES 7,B */
    { B( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 185: /* RES 7,C */
    { C( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 186: /* RES 7,D */
    { D( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 187: /* RES 7,E */
    { E( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 188: /* RES 7,H */
    { H( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 189: /* RES 7,L */
    { L( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 190: /* RES 7,(HL) */
    { pokeb( z, res( 0x80, peekb( z ) ) ); return; }
    case 191: /* RES 7,A */
    { A( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    case 192: /* SET 0,B */
    { B( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 193: /* SET 0,C */
    { C( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 194: /* SET 0,D */
    { D( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 195: /* SET 0,E */
    { E( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 196: /* SET 0,H */
    { H( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 197: /* SET 0,L */
    { L( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 198: /* SET 0,(HL) */
    { pokeb( z, set( 0x01, peekb( z ) ) ); return; }
    case 199: /* SET 0,A */
    { A( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 200: /* SET 1,B */
    { B( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 201: /* SET 1,C */
    { C( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 202: /* SET 1,D */
    { D( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 203: /* SET 1,E */
    { E( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 204: /* SET 1,H */
    { H( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 205: /* SET 1,L */
    { L( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 206: /* SET 1,(HL) */
    { pokeb( z, set( 0x02, peekb( z ) ) ); return; }
    case 207: /* SET 1,A */
    { A( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 208: /* SET 2,B */
    { B( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 209: /* SET 2,C */
    { C( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 210: /* SET 2,D */
    { D( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 211: /* SET 2,E */
    { E( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 212: /* SET 2,H */
    { H( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 213: /* SET 2,L */
    { L( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 214: /* SET 2,(HL) */
    { pokeb( z, set( 0x04, peekb( z ) ) ); return; }
    case 215: /* SET 2,A */
    { A( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 216: /* SET 3,B */
    { B( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 217: /* SET 3,C */
    { C( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 218: /* SET 3,D */
    { D( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 219: /* SET 3,E */
    { E( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 220: /* SET 3,H */
    { H( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 221: /* SET 3,L */
    { L( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 222: /* SET 3,(HL) */
    { pokeb( z, set( 0x08, peekb( z ) ) ); return; }
    case 223: /* SET 3,A */
    { A( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 224: /* SET 4,B */
    { B( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 225: /* SET 4,C */
    { C( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 226: /* SET 4,D */
    { D( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 227: /* SET 4,E */
    { E( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 228: /* SET 4,H */
    { H( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 229: /* SET 4,L */
    { L( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 230: /* SET 4,(HL) */
    { pokeb( z, set( 0x10, peekb( z ) ) ); return; }
    case 231: /* SET 4,A */
    { A( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 232: /* SET 5,B */
    { B( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 233: /* SET 5,C */
    { C( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 234: /* SET 5,D */
    { D( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 235: /* SET 5,E */
    { E( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 236: /* SET 5,H */
    { H( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 237: /* SET 5,L */
    { L( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 238: /* SET 5,(HL) */
    { pokeb( z, set( 0x20, peekb( z ) ) ); return; }
    case 239: /* SET 5,A */
    { A( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 240: /* SET 6,B */
    { B( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 241: /* SET 6,C */
    { C( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 242: /* SET 6,D */
    { D( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 243: /* SET 6,E */
    { E( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 244: /* SET 6,H */
    { H( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 245: /* SET 6,L */
    { L( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 246: /* SET 6,(HL) */
    { pokeb( z, set( 0x40, peekb( z ) ) ); return; }
    case 247: /* SET 6,A */
    { A( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 248: /* SET 7,B */
    { B( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 249: /* SET 7,C */
    { C( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 250: /* SET 7,D */
    { D( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 251: /* SET 7,E */
    { E( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 252: /* SET 7,H */
    { H( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 253: /* SET 7,L */
    { L( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 254: /* SET 7,(HL) */
    { pokeb( z, set( 0x80, peekb( z ) ) ); return; }
    case 255: /* SET 7,A */
    { A( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    } // end switch
  }

  private  int execute_id() {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case  0: /* NOP */
    case  1:
    case  2:
    case  3:
    case  4:
    case  5:
    case  6:
    case  7:
    case  8:

    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:

    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:

    case 39:
    case 40:

    case 47:
    case 48:
    case 49:
    case 50:
    case 51:

    case 55:
    case 56:

    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:

    case 71:
    case 72:
    case 73:
    case 74:
    case 75:

    case 79:
    case 80:
    case 81:
    case 82:
    case 83:

    case 87:
    case 88:
    case 89:
    case 90:
    case 91:

    case 95:

    case 120:
    case 121:
    case 122:
    case 123:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:

    case 135:
    case 136:
    case 137:
    case 138:
    case 139:

    case 143:
    case 144:
    case 145:
    case 146:
    case 147:

    case 151:
    case 152:
    case 153:
    case 154:
    case 155:

    case 159:
    case 160:
    case 161:
    case 162:
    case 163:

    case 167:
    case 168:
    case 169:
    case 170:
    case 171:

    case 175:
    case 176:
    case 177:
    case 178:
    case 179:

    case 183:
    case 184:
    case 185:
    case 186:
    case 187:

    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:

    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:

    case 226:

    case 228:

    case 230:
    case 231:
    case 232:

    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    {
      PC( dec16( PC() ) );
      REFRESH( -1 );
      return ( 4 );
    }

    case  9: /* ADD ID,BC */
    { ID( add16( ID(), BC() ) ); return ( 15 ); }
    case 25: /* ADD ID,DE */
    { ID( add16( ID(), DE() ) ); return ( 15 ); }
    case 41: /* ADD ID,ID */
    {
      int id = ID();
      ID( add16( id, id ) );
      return ( 15 );
    }
    case 57: /* ADD ID,SP */
    { ID( add16( ID(),SP() ) ); return ( 15 ); }

    case 33: /* LD ID,nn */
    { ID( nxtpcw() ); return ( 14 ); }
    case 34: /* LD (nn),ID */
    { pokew( nxtpcw(), ID() ); return ( 20 ); }
    case 42: /* LD ID,(nn) */
    { ID( peekw( nxtpcw() ) ); return ( 20 ); }
    case 35:/* INC ID */
    { ID( inc16( ID() ) ); return ( 10 ); }
    case 43:/* DEC ID */
    { ID( dec16( ID() ) ); return ( 10 ); }
    case 36:/* INC IDH */
    { IDH( inc8( IDH() ) ); return ( 8 ); }
    case 44:/* INC IDL */
    { IDL( inc8( IDL() ) ); return ( 8 ); }
    case 52:/* INC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, inc8( peekb(z) ) );
        return ( 23 );
    }
    case 37:/* DEC IDH */
    { IDH( dec8( IDH() ) ); return ( 8 ); }
    case 45:/* DEC IDL */
    { IDL( dec8( IDL() ) ); return ( 8 ); }
    case 53:/* DEC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, dec8( peekb(z) ) );
        return ( 23 );
    }

    case 38: /* LD IDH,n */
    { IDH( nxtpcb() ); return ( 11 ); }
    case 46: /* LD IDL,n */
    { IDL( nxtpcb() ); return ( 11 ); }
    case 54: /* LD (ID+d),n */
    { int z = ID_d(); pokeb(z,nxtpcb()); return ( 19 ); }

    case 68: /* LD B,IDH */
    { B( IDH() ); return ( 8 ); }
    case 69: /* LD B,IDL */
    { B( IDL() ); return ( 8 ); }
    case 70: /* LD B,(ID+d) */
    { B( peekb( ID_d() ) ); return ( 19 ); }

    case 76: /* LD C,IDH */
    { C( IDH() ); return ( 8 ); }
    case 77: /* LD C,IDL */
    { C( IDL() ); return ( 8 ); }
    case 78: /* LD C,(ID+d) */
    { C( peekb( ID_d() ) ); return ( 19 ); }

    case 84: /* LD D,IDH */
    { D( IDH() ); return ( 8 ); }
    case 85: /* LD D,IDL */
    { D( IDL() ); return ( 8 ); }
    case 86: /* LD D,(ID+d) */
    { D( peekb( ID_d() ) ); return ( 19 ); }

    case 92: /* LD E,IDH */
    { E( IDH() ); return ( 8 ); }
    case 93: /* LD E,IDL */
    { E( IDL() ); return ( 8 ); }
    case 94: /* LD E,(ID+d) */
    { E( peekb( ID_d() ) ); return ( 19 ); }

    case 96: /* LD IDH,B */
    { IDH( B() ); return ( 8 ); }
    case 97: /* LD IDH,C */
    { IDH( C() ); return ( 8 ); }
    case 98: /* LD IDH,D */
    { IDH( D() ); return ( 8 ); }
    case 99: /* LD IDH,E */
    { IDH( E() ); return ( 8 ); }
    case 100: /* LD IDH,IDH */
    { return ( 8 ); }
    case 101: /* LD IDH,IDL */
    { IDH( IDL() ); return ( 8 ); }
    case 102: /* LD H,(ID+d) */
    { H( peekb( ID_d() ) ); return ( 19 ); }
    case 103: /* LD IDH,A */
    { IDH( A() ); return ( 8 ); }

    case 104: /* LD IDL,B */
    { IDL( B() ); return ( 8 ); }
    case 105: /* LD IDL,C */
    { IDL( C() ); return ( 8 ); }
    case 106: /* LD IDL,D */
    { IDL( D() ); return ( 8 ); }
    case 107: /* LD IDL,E */
    { IDL( E() ); return ( 8 ); }
    case 108: /* LD IDL,IDH */
    { IDL( IDH() ); return ( 8 ); }
    case 109: /* LD IDL,IDL */
    { return ( 8 ); }
    case 110: /* LD L,(ID+d) */
    { L( peekb( ID_d() ) ); return ( 19 ); }
    case 111: /* LD IDL,A */
    { IDL( A() ); return ( 8 ); }

    case 112: /* LD (ID+d),B */
    { pokeb( ID_d(), B() ); return ( 19 ); }
    case 113: /* LD (ID+d),C */
    { pokeb( ID_d(), C() ); return ( 19 ); }
    case 114: /* LD (ID+d),D */
    { pokeb( ID_d(), D() ); return ( 19 ); }
    case 115: /* LD (ID+d),E */
    { pokeb( ID_d(), E() ); return ( 19 ); }
    case 116: /* LD (ID+d),H */
    { pokeb( ID_d(), H() ); return ( 19 ); }
    case 117: /* LD (ID+d),L */
    { pokeb( ID_d(), L() ); return ( 19 ); }
    case 119: /* LD (ID+d),A */
    { pokeb( ID_d(), A() ); return ( 19 ); }

    case 124: /* LD A,IDH */
    { A( IDH() ); return ( 8 ); }
    case 125: /* LD A,IDL */
    { A( IDL() ); return ( 8 ); }
    case 126: /* LD A,(ID+d) */
    { A( peekb( ID_d() ) ); return ( 19 ); }

    case 132: /* ADD A,IDH */
    { add_a(IDH()); return ( 8 ); }
    case 133: /* ADD A,IDL */
    { add_a(IDL()); return ( 8 ); }
    case 134: /* ADD A,(ID+d) */
    { add_a(peekb( ID_d() )); return ( 19 ); }

    case 140: /* ADC A,IDH */
    { adc_a(IDH()); return ( 8 ); }
    case 141: /* ADC A,IDL */
    { adc_a(IDL()); return ( 8 ); }
    case 142: /* ADC A,(ID+d) */
    { adc_a(peekb( ID_d() )); return ( 19 ); }

    case 148: /* SUB IDH */
    { sub_a(IDH()); return ( 8 ); }
    case 149: /* SUB IDL */
    { sub_a(IDL()); return ( 8 ); }
    case 150: /* SUB (ID+d) */
    { sub_a(peekb( ID_d() )); return ( 19 ); }

    case 156: /* SBC A,IDH */
    { sbc_a(IDH()); return ( 8 ); }
    case 157: /* SBC A,IDL */
    { sbc_a(IDL()); return ( 8 ); }
    case 158: /* SBC A,(ID+d) */
    { sbc_a(peekb( ID_d() )); return ( 19 ); }

    case 164: /* AND IDH */
    { and_a(IDH()); return ( 8 ); }
    case 165: /* AND IDL */
    { and_a(IDL()); return ( 8 ); }
    case 166: /* AND (ID+d) */
    { and_a(peekb( ID_d() )); return ( 19 ); }

    case 172: /* XOR IDH */
    { xor_a(IDH()); return ( 8 ); }
    case 173: /* XOR IDL */
    { xor_a(IDL()); return ( 8 ); }
    case 174: /* XOR (ID+d) */
    { xor_a(peekb( ID_d() )); return ( 19 ); }

    case 180: /* OR IDH */
    { or_a(IDH()); return ( 8 ); }
    case 181: /* OR IDL */
    { or_a(IDL()); return ( 8 ); }
    case 182: /* OR (ID+d) */
    { or_a(peekb( ID_d() )); return ( 19 ); }

    case 188: /* CP IDH */
    { cp_a(IDH()); return ( 8 ); }
    case 189: /* CP IDL */
    { cp_a(IDL()); return ( 8 ); }
    case 190: /* CP (ID+d) */
    { cp_a(peekb( ID_d() )); return ( 19 ); }

    case 225: /* POP ID */
    { ID( popw() ); return ( 14 ); }

    case 233: /* JP (ID) */
    { PC( ID() ); return ( 8 ); }

    case 249: /* LD SP,ID */
    { SP( ID() ); return ( 10 ); }

    case 203: /* prefix CB */
    {
      // Get index address (offset byte is first)
      int z = ID_d();
      // Opcode comes after offset byte
      int op = nxtpcb();
      execute_id_cb( op, z );
      // Bit instructions take 20 T states, rest 23
      return ( (( op & 0xc0 ) == 0x40) ? 20 : 23 );
    }

    case 227: /* EX (SP),ID */
    {
      int t = ID();
      int sp = SP();
      ID( peekw( sp ) );
      pokew( sp, t );
      return ( 23 );
    }

    case 229:    /* PUSH ID */
    { pushw( ID() ); return ( 15 ); }

    } // end switch

    return 0;
  }


  int global_tstates = -tstatesPerInterrupt;

  /** Z80 fetch/execute loop */
  void execute(float time) {

    const float timelimit=1.0 / 15;
    if(time>timelimit)
      time=timelimit; //avoid maxing cpu, slow down emulation speed instead

    int    local_tstates = global_tstates;

    int ticksLimit = local_tstates + round(time * clockSpeed * 1e6);

    //trace("delta: " + inttostr(time*1000));
    //trace("ticks: " + inttostr(round(time * clockSpeed * 1e6)));

    int lastticks;
    if(PROFILE)
      lastticks=GetTickCount();

    while ( local_tstates < ticksLimit ) {

    int instruction;

    if(PROFILE) {
      int now=GetTickCount();
      if(now-lastticks>15) {
        trace("Instruction " + intToStr(instruction) + " took " + inttostr(now-lastticks) + "ms");
      }
      lastticks=GetTickCount();
    }

    if(ANALYSE) {
      if(analyse_frameRenderIndicator) {
        //saveScreenDump();
        analyse_frameRenderIndicator = 0;
        break;
      }
      if(ANALYSE_CHECK_PC) {
        if(_PC==0x6792)
          analyse_AddrFlags[_HL]=1;
        //if(_PC==0x00008ea8 && _B==4 && ((_BC_ & 255)==3))
        //  analyse_AddrFlags[_DE]=1;
      }
    }


    if ( interruptTriggered( local_tstates ) ) {
      int intTime=tstatesPerInterrupt - interrupt();
      local_tstates -= intTime;
      ticksLimit -= intTime;
    }


    if(DEBUGTRACE) {
      trace("pc: " + inttostr(_PC));
    }

    REFRESH( 1 );


    instruction=nxtpcb();
    switch ( instruction ) {

    case 0:    /* NOP */
    {
      local_tstates += ( 4 );
      break;
    }
    case 8:    /* EX AF,AF' */
    {
      ex_af_af();
      local_tstates += ( 4 );
      break;
    }
    case 16:    /* DJNZ dis */
    {
      int  b;

      B( b = qdec8( B() ) );
      if (b != 0) {
        int d =  getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 13 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 8 );
      }
      break;
    }
    case 24: /* JR dis */
    {
      int d = getSignedByte(nxtpcb());
      PC( (PC()+d)&0xffff );
      local_tstates += ( 12 );
      break;
    }
    /* JR cc,dis */
    case 32:    /* JR NZ,dis */
    {
      if (!Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 40:    /* JR Z,dis */
    {
      if ( Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 48:    /* JR NC,dis */
    {
      if (!Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 56:    /* JR C,dis */
    {
      if ( Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }

    /* LD rr,nn / ADD HL,rr */
    case 1:    /* LD BC(),nn */
    {
      BC( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 9:    /* ADD HL,BC */
     {
      HL( add16( HL(), BC() ) );
      local_tstates += ( 11 );
      break;
    }
    case 17:    /* LD DE,nn */
    {
      DE( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 25:    /* ADD HL,DE */
    {
      HL( add16( HL(), DE() ) );
      local_tstates += ( 11 );
      break;
    }
    case 33:    /* LD HL,nn */
    {
      HL( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 41:    /* ADD HL,HL */
    {
      int hl = HL();
      HL( add16( hl, hl ) );
      local_tstates += ( 11 );
      break;
    }
    case 49:    /* LD SP,nn */
    {
      SP( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 57:    /* ADD HL,SP */
    {
      HL( add16( HL(), SP() ) );
      local_tstates += ( 11 );
      break;
    }

    /* LD (**),A/A,(**) */
    case 2:    /* LD (BC),A */
    { pokeb( BC(), A() ); local_tstates += ( 7 ); break; }
    case 10:    /* LD A,(BC) */
    { A( peekb( BC() ) ); local_tstates += ( 7 ); break; }
    case 18:    /* LD (DE),A */
    { pokeb( DE(), A() ); local_tstates += ( 7 ); break; }
    case 26:    /* LD A,(DE) */
    { A( peekb( DE() ) ); local_tstates += ( 7 ); break; }
    case 34:    /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); local_tstates += ( 16 ); break; }
    case 42:    /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); local_tstates += ( 16 ); break; }
    case 50:    /* LD (nn),A */
    { pokeb( nxtpcw(), A() ); local_tstates += ( 13 ); break; }
    case 58:    /* LD A,(nn) */
    { A( peekb( nxtpcw() ) ); local_tstates += ( 13 ); break; }

    /* INC/DEC * */
    case 3:    /* INC BC */
    { BC( inc16( BC() ) ); local_tstates += ( 6 ); break; }
    case 11:    /* DEC BC */
    { BC( dec16( BC() ) ); local_tstates += ( 6 ); break; }
    case 19:    /* INC DE */
    { DE( inc16( DE() ) ); local_tstates += ( 6 ); break; }
    case 27:    /* DEC DE */
    { DE( dec16( DE() ) ); local_tstates += ( 6 ); break; }
    case 35:    /* INC HL */
    { HL( inc16( HL() ) ); local_tstates += ( 6 ); break; }
    case 43:    /* DEC HL */
    { HL( dec16( HL() ) ); local_tstates += ( 6 ); break; }
    case 51:    /* INC SP */
    { SP( inc16( SP() ) ); local_tstates += ( 6 ); break; }
    case 59:    /* DEC SP */
    { SP( dec16( SP() ) ); local_tstates += ( 6 ); break; }

    /* INC * */
    case 4:    /* INC B */
    { B( inc8( B() ) ); local_tstates += ( 4 ); break; }
    case 12:    /* INC C */
    { C( inc8( C() ) ); local_tstates += ( 4 ); break; }
    case 20:    /* INC D */
    { D( inc8( D() ) ); local_tstates += ( 4 ); break; }
    case 28:    /* INC E */
    { E( inc8( E() ) ); local_tstates += ( 4 ); break; }
    case 36:    /* INC H */
    { H( inc8( H() ) ); local_tstates += ( 4 ); break; }
    case 44:    /* INC L */
    { L( inc8( L() ) ); local_tstates += ( 4 ); break; }
    case 52:    /* INC (HL) */
    {
      int hl = HL();
      pokeb( hl, inc8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 60:    /* INC A() */
    { A( inc8( A() ) ); local_tstates += ( 4 ); break; }

    /* DEC * */
    case 5:    /* DEC B */
    { B( dec8( B() ) ); local_tstates += ( 4 ); break; }
    case 13:    /* DEC C */
    { C( dec8( C() ) ); local_tstates += ( 4 ); break; }
    case 21:    /* DEC D */
    { D( dec8( D() ) ); local_tstates += ( 4 ); break; }
    case 29:    /* DEC E */
    { E( dec8( E() ) ); local_tstates += ( 4 ); break; }
    case 37:    /* DEC H */
    { H( dec8( H() ) ); local_tstates += ( 4 ); break; }
    case 45:    /* DEC L */
    { L( dec8( L() ) ); local_tstates += ( 4 ); break; }
    case 53:    /* DEC (HL) */
    {
      int hl = HL();
      pokeb( hl, dec8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 61:    /* DEC A() */
    { A( dec8( A() ) ); local_tstates += ( 4 ); break; }

    /* LD *,N */
    case 6:    /* LD B,n */
    { B( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 14:    /* LD C,n */
    { C( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 22:    /* LD D,n */
    { D( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 30:    /* LD E,n */
    { E( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 38:    /* LD H,n */
    { H( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 46:    /* LD L,n */
    { L( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 54:    /* LD (HL),n */
    {
      pokeb( HL(), nxtpcb() );
      local_tstates += ( 10 );
      break;
    }
    case 62:    /* LD A,n */
    { A( nxtpcb() ); local_tstates += ( 7 ); break; }

    /* R**A */
    case 7: /* RLCA */
    { rlc_a(); local_tstates += ( 4 ); break; }
    case 15: /* RRCA */
    { rrc_a(); local_tstates += ( 4 ); break; }
    case 23: /* RLA */
    { rl_a(); local_tstates += ( 4 ); break; }
    case 31: /* RRA */
    { rr_a(); local_tstates += ( 4 ); break; }
    case 39: /* DAA */
    { daa_a(); local_tstates += ( 4 ); break; }
    case 47: /* CPL */
    { cpl_a(); local_tstates += ( 4 ); break; }
    case 55: /* SCF */
    { scf(); local_tstates += ( 4 ); break; }
    case 63: /* CCF */
    { ccf(); local_tstates += ( 4 ); break; }

    /* LD B,* */
    case 64:    /* LD B,B */
    { local_tstates += ( 4 ); break; }
    case 65:    /* LD B,C */
    { B( C() ); local_tstates += ( 4 ); break; }
    case 66:    /* LD B,D */
    { B( D() ); local_tstates += ( 4 ); break; }
    case 67:    /* LD B,E */
    { B( E() ); local_tstates += ( 4 ); break; }
    case 68:    /* LD B,H */
    { B( H() ); local_tstates += ( 4 ); break; }
    case 69:    /* LD B,L */
    { B( L() ); local_tstates += ( 4 ); break; }
    case 70:    /* LD B,(HL) */
    { B( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 71:    /* LD B,A */
    { B( A() ); local_tstates += ( 4 ); break; }

    /* LD C,* */
    case 72:    /* LD C,B */
    { C( B() ); local_tstates += ( 4 ); break; }
    case 73:    /* LD C,C */
    { local_tstates += ( 4 ); break; }
    case 74:    /* LD C,D */
    { C( D() ); local_tstates += ( 4 ); break; }
    case 75:    /* LD C,E */
    { C( E() ); local_tstates += ( 4 ); break; }
    case 76:    /* LD C,H */
    { C( H() ); local_tstates += ( 4 ); break; }
    case 77:    /* LD C,L */
    { C( L() ); local_tstates += ( 4 ); break; }
    case 78:    /* LD C,(HL) */
    { C( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 79:    /* LD C,A */
    { C( A() ); local_tstates += ( 4 ); break; }

    /* LD D,* */
    case 80:    /* LD D,B */
    { D( B() ); local_tstates += ( 4 ); break; }
    case 81:    /* LD D,C */
    { D( C() ); local_tstates += ( 4 ); break; }
    case 82:    /* LD D,D */
    { local_tstates += ( 4 ); break; }
    case 83:    /* LD D,E */
    { D( E() ); local_tstates += ( 4 ); break; }
    case 84:    /* LD D,H */
    { D( H() ); local_tstates += ( 4 ); break; }
    case 85:    /* LD D,L */
    { D( L() ); local_tstates += ( 4 ); break; }
    case 86:    /* LD D,(HL) */
    { D( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 87:    /* LD D,A */
    { D( A() ); local_tstates += ( 4 ); break; }

    /* LD E,* */
    case 88:    /* LD E,B */
    { E( B() ); local_tstates += ( 4 ); break; }
    case 89:    /* LD E,C */
    { E( C() ); local_tstates += ( 4 ); break; }
    case 90:    /* LD E,D */
    { E( D() ); local_tstates += ( 4 ); break; }
    case 91:    /* LD E,E */
    { local_tstates += ( 4 ); break; }
    case 92:    /* LD E,H */
    { E( H() ); local_tstates += ( 4 ); break; }
    case 93:    /* LD E,L */
    { E( L() ); local_tstates += ( 4 ); break; }
    case 94:    /* LD E,(HL) */
    { E( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 95:    /* LD E,A */
    { E( A() ); local_tstates += ( 4 ); break; }

    /* LD H,* */
    case 96:    /* LD H,B */
    { H( B() ); local_tstates += ( 4 ); break; }
    case 97:    /* LD H,C */
    { H( C() ); local_tstates += ( 4 ); break; }
    case 98:    /* LD H,D */
    { H( D() ); local_tstates += ( 4 ); break; }
    case 99:    /* LD H,E */
    { H( E() ); local_tstates += ( 4 ); break; }
    case 100: /* LD H,H */
    { local_tstates += ( 4 ); break; }
    case 101:    /* LD H,L */
    { H( L() ); local_tstates += ( 4 ); break; }
    case 102:    /* LD H,(HL) */
    { H( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 103:    /* LD H,A */
    { H( A() ); local_tstates += ( 4 ); break; }

    /* LD L,* */
    case 104:    /* LD L,B */
    { L( B() ); local_tstates += ( 4 ); break; }
    case 105:    /* LD L,C */
    { L( C() ); local_tstates += ( 4 ); break; }
    case 106:    /* LD L,D */
    { L( D() ); local_tstates += ( 4 ); break; }
    case 107:    /* LD L,E */
    { L( E() ); local_tstates += ( 4 ); break; }
    case 108:    /* LD L,H */
    { L( H() ); local_tstates += ( 4 ); break; }
    case 109:    /* LD L,L */
    { local_tstates += ( 4 ); break; }
    case 110:    /* LD L,(HL) */
    { L( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 111:    /* LD L,A */
    { L( A() ); local_tstates += ( 4 ); break; }

    /* LD (HL),* */
    case 112:    /* LD (HL),B */
    { pokeb( HL(), B() ); local_tstates += ( 7 ); break; }
    case 113:    /* LD (HL),C */
    { pokeb( HL(), C() ); local_tstates += ( 7 ); break; }
    case 114:    /* LD (HL),D */
    { pokeb( HL(), D() ); local_tstates += ( 7 ); break; }
    case 115:    /* LD (HL),E */
    { pokeb( HL(), E() ); local_tstates += ( 7 ); break; }
    case 116:    /* LD (HL),H */
    { pokeb( HL(), H() ); local_tstates += ( 7 ); break; }
    case 117:    /* LD (HL),L */
    { pokeb( HL(), L() ); local_tstates += ( 7 ); break; }
    case 118:    /* HALT */
    {
      int  haltsToInterrupt = (((-local_tstates-1) / 4)+1);
      local_tstates += (haltsToInterrupt*4);
      REFRESH( haltsToInterrupt-1 );

      if(ANALYSE) {
        if(analyse_checkFrameWrites)
          for(int i=16384; i<16384+6144; i++)
            mem[i]=0xff;
      }

      break;
    }
    case 119:    /* LD (HL),A */
    { pokeb( HL(), A() ); local_tstates += ( 7 ); break; }

    /* LD A,* */
    case 120:    /* LD A,B */
    { A( B() ); local_tstates += ( 4 ); break; }
    case 121:    /* LD A,C */
    { A( C() ); local_tstates += ( 4 ); break; }
    case 122:    /* LD A,D */
    { A( D() ); local_tstates += ( 4 ); break; }
    case 123:    /* LD A,E */
    { A( E() ); local_tstates += ( 4 ); break; }
    case 124:    /* LD A,H */
    { A( H() ); local_tstates += ( 4 ); break; }
    case 125:    /* LD A,L */
    { A( L() ); local_tstates += ( 4 ); break; }
    case 126:    /* LD A,(HL) */
    { A( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 127:    /* LD A,A */
    { local_tstates += ( 4 ); break; }

    /* ADD A,* */
    case 128:    /* ADD A,B */
    { add_a( B() ); local_tstates += ( 4 ); break; }
    case 129:    /* ADD A,C */
    { add_a( C() ); local_tstates += ( 4 ); break; }
    case 130:    /* ADD A,D */
    { add_a( D() ); local_tstates += ( 4 ); break; }
    case 131:    /* ADD A,E */
    { add_a( E() ); local_tstates += ( 4 ); break; }
    case 132:    /* ADD A,H */
    { add_a( H() ); local_tstates += ( 4 ); break; }
    case 133:    /* ADD A,L */
    { add_a( L() ); local_tstates += ( 4 ); break; }
    case 134:    /* ADD A,(HL) */
    { add_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 135:    /* ADD A,A */
    { add_a( A() ); local_tstates += ( 4 ); break; }

    /* ADC A,* */
    case 136:    /* ADC A,B */
    { adc_a( B() ); local_tstates += ( 4 ); break; }
    case 137:    /* ADC A,C */
    { adc_a( C() ); local_tstates += ( 4 ); break; }
    case 138:    /* ADC A,D */
    { adc_a( D() ); local_tstates += ( 4 ); break; }
    case 139:    /* ADC A,E */
    { adc_a( E() ); local_tstates += ( 4 ); break; }
    case 140:    /* ADC A,H */
    { adc_a( H() ); local_tstates += ( 4 ); break; }
    case 141:    /* ADC A,L */
    { adc_a( L() ); local_tstates += ( 4 ); break; }
    case 142:    /* ADC A,(HL) */
    { adc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 143:    /* ADC A,A */
    { adc_a( A() ); local_tstates += ( 4 ); break; }

    /* SUB * */
    case 144:    /* SUB B */
    { sub_a( B() ); local_tstates += ( 4 ); break; }
    case 145:    /* SUB C */
    { sub_a( C() ); local_tstates += ( 4 ); break; }
    case 146:    /* SUB D */
    { sub_a( D() ); local_tstates += ( 4 ); break; }
    case 147:    /* SUB E */
    { sub_a( E() ); local_tstates += ( 4 ); break; }
    case 148:    /* SUB H */
    { sub_a( H() ); local_tstates += ( 4 ); break; }
    case 149:    /* SUB L */
    { sub_a( L() ); local_tstates += ( 4 ); break; }
    case 150:    /* SUB (HL) */
    { sub_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 151:    /* SUB A() */
    { sub_a( A() ); local_tstates += ( 4 ); break; }

    /* SBC A,* */
    case 152:    /* SBC A,B */
    { sbc_a( B() ); local_tstates += ( 4 ); break; }
    case 153:    /* SBC A,C */
    { sbc_a( C() ); local_tstates += ( 4 ); break; }
    case 154:    /* SBC A,D */
    { sbc_a( D() ); local_tstates += ( 4 ); break; }
    case 155:    /* SBC A,E */
    { sbc_a( E() ); local_tstates += ( 4 ); break; }
    case 156:    /* SBC A,H */
    { sbc_a( H() ); local_tstates += ( 4 ); break; }
    case 157:    /* SBC A,L */
    { sbc_a( L() ); local_tstates += ( 4 ); break; }
    case 158:    /* SBC A,(HL) */
    { sbc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 159:    /* SBC A,A */
    { sbc_a( A() ); local_tstates += ( 4 ); break; }

    /* AND * */
    case 160:    /* AND B */
    { and_a( B() ); local_tstates += ( 4 ); break; }
    case 161:    /* AND C */
    { and_a( C() ); local_tstates += ( 4 ); break; }
    case 162:    /* AND D */
    { and_a( D() ); local_tstates += ( 4 ); break; }
    case 163:    /* AND E */
    { and_a( E() ); local_tstates += ( 4 ); break; }
    case 164:    /* AND H */
    { and_a( H() ); local_tstates += ( 4 ); break; }
    case 165:    /* AND L */
    { and_a( L() ); local_tstates += ( 4 ); break; }
    case 166:    /* AND (HL) */
    { and_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 167:    /* AND A() */
    { and_a( A() ); local_tstates += ( 4 ); break; }

    /* XOR * */
    case 168:    /* XOR B */
    { xor_a( B() ); local_tstates += ( 4 ); break; }
    case 169:    /* XOR C */
    { xor_a( C() ); local_tstates += ( 4 ); break; }
    case 170:    /* XOR D */
    { xor_a( D() ); local_tstates += ( 4 ); break; }
    case 171:    /* XOR E */
    { xor_a( E() ); local_tstates += ( 4 ); break; }
    case 172:    /* XOR H */
    { xor_a( H() ); local_tstates += ( 4 ); break; }
    case 173:    /* XOR L */
    { xor_a( L() ); local_tstates += ( 4 ); break; }
    case 174:    /* XOR (HL) */
    { xor_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 175:    /* XOR A() */
    { xor_a( A() ); local_tstates += ( 4 ); break; }

    /* OR * */
    case 176:    /* OR B */
    { or_a( B() ); local_tstates += ( 4 ); break; }
    case 177:    /* OR C */
    { or_a( C() ); local_tstates += ( 4 ); break; }
    case 178:    /* OR D */
    { or_a( D() ); local_tstates += ( 4 ); break; }
    case 179:    /* OR E */
    { or_a( E() ); local_tstates += ( 4 ); break; }
    case 180:    /* OR H */
    { or_a( H() ); local_tstates += ( 4 ); break; }
    case 181:    /* OR L */
    { or_a( L() ); local_tstates += ( 4 ); break; }
    case 182:    /* OR (HL) */
    { or_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 183:    /* OR A() */
    { or_a( A() ); local_tstates += ( 4 ); break; }

    /* CP * */
    case 184:    /* CP B */
    { cp_a( B() ); local_tstates += ( 4 ); break; }
    case 185:    /* CP C */
    { cp_a( C() ); local_tstates += ( 4 ); break; }
    case 186:    /* CP D */
    { cp_a( D() ); local_tstates += ( 4 ); break; }
    case 187:    /* CP E */
    { cp_a( E() ); local_tstates += ( 4 ); break; }
    case 188:    /* CP H */
    { cp_a( H() ); local_tstates += ( 4 ); break; }
    case 189:    /* CP L */
    { cp_a( L() ); local_tstates += ( 4 ); break; }
    case 190:    /* CP (HL) */
    { cp_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 191:    /* CP A() */
    { cp_a( A() ); local_tstates += ( 4 ); break; }

    /* RET cc */
    case 192:    /* RET NZ */
    {
      if(!Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 200:    /* RET Z */
    {
      if(Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 208:    /* RET NC */
    {
      if(!Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 216:    /* RET C */
    {
      if(Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 224:    /* RET PO */
    {
      if(!PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 232:    /* RET PE */
    {
      if(PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 240:    /* RET P */
    {
      if(!Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 248:    /* RET M */
    {
      if(Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }

    /* POP,Various */
    case 193:    /* POP BC */
    { BC( popw() ); local_tstates += ( 10 ); break; }
    case 201: /* RET */
    { poppc(); local_tstates += ( 10 ); break; }
    case 209:    /* POP DE */
    { DE( popw() ); local_tstates += ( 10 ); break; }
    case 217:    /* EXX */
    {
      exx();
      local_tstates += ( 4 );
      break;
    }
    case 225:    /* POP HL */
    { HL( popw() ); local_tstates += ( 10 ); break; }
    case 233: /* JP (HL) */
    { PC( HL() ); local_tstates += ( 4 ); break; }
    case 241:    /* POP AF */
    { AF( popw() ); local_tstates += ( 10 ); break; }
    case 249:    /* LD SP,HL */
    { SP( HL() ); local_tstates += ( 6 ); break; }

    /* JP cc,nn */
    case 194:    /* JP NZ,nn */
    {
      if(!Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 202:    /* JP Z,nn */
    {
      if( Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 210:    /* JP NC,nn */
    {
      if(!Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 218:    /* JP C,nn */
    {
      if( Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 226:    /* JP PO,nn */
    {
      if(!PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 234:    /* JP PE,nn */
    {
      if( PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 242:    /* JP P,nn */
    {
      if(!Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 250:    /* JP M,nn */
    {
      if( Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }


    /* Various */
    case 195:    /* JP nn */
    { PC( peekw( PC() ) ); local_tstates += ( 10 ); break; }
    case 203:    /* prefix CB */
    { local_tstates += execute_cb(); break; }
    case 211:    /* OUT (n),A */
    {
      outb( nxtpcb(), A(), local_tstates );
      local_tstates += ( 11 );
      break;
    }
    case 219:    /* IN A,(n) */
    {
      A( inb((A() << 8) | nxtpcb()) );
      local_tstates += ( 11 );
      break;
    }
    case 227:    /* EX (SP),HL */
    {
      int t = HL();
      int sp = SP();
      HL( peekw( sp ) );
      pokew( sp, t );
      local_tstates += ( 19 );
      break;
    }
    case 235:    /* EX DE,HL */
    {
      int t = HL();
      HL( DE() );
      DE( t );
      local_tstates += ( 4 );
      break;
    }
    case 243:    /* DI */
    {
      IFF1( false );
      IFF2( false );
      local_tstates += ( 4 );
      break;
    }
    case 251:    /* EI */
    {
      IFF1( true );
      IFF2( true );
      local_tstates += ( 4 );
      break;
    }

    /* CALL cc,nn */
    case 196: /* CALL NZ,nn */
    {
      if( !Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 204: /* CALL Z,nn */
    {
      if( Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 212: /* CALL NC,nn */
    {
      if( !Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 220: /* CALL C,nn */
    {
      if( Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 228: /* CALL PO,nn */
    {
      if( !PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 236: /* CALL PE,nn */
    {
      if( PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 244: /* CALL P,nn */
    {
      if( !Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 252: /* CALL M,nn */
    {
      if( Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }

    /* PUSH,Various */
    case 197:    /* PUSH BC */
    { pushw( BC() ); local_tstates += ( 11 ); break; }
    case 205:    /* CALL nn */
    {
      int t = nxtpcw();
        //if(t==0x6794)
        //  trace("Height " + intToStr(_C*2) + " de: " + intToStr(DE()));

      pushpc();
      PC( t );
      local_tstates += ( 17 );
      break;
    }
    case 213:    /* PUSH DE */
    { pushw( DE() ); local_tstates += ( 11 ); break; }
    case 221:    /* prefix IX */
    {
      ID( IX() );
      local_tstates += execute_id();
      IX( ID() );
      break;
    }
    case 229:    /* PUSH HL */
    { pushw( HL() ); local_tstates += ( 11 ); break; }
    case 237:    /* prefix ED */
    { local_tstates += execute_ed( local_tstates ); break; }
    case 245:    /* PUSH AF */
    { pushw( AF() ); local_tstates += ( 11 ); break; }
    case 253:    /* prefix IY */
    {
      ID( IY() );
      local_tstates += execute_id();
      IY( ID() );
      break;
    }

    /* op A,N */
    case 198: /* ADD A,N */
    { add_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 206: /* ADC A,N */
    { adc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 214: /* SUB N */
    { sub_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 222: /* SBC A,N */
    { sbc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 230: /* AND N */
    { and_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 238: /* XOR N */
    { xor_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 246: /* OR N */
    { or_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 254: /* CP N */
    { cp_a(nxtpcb()); local_tstates += ( 7 ); break; }

    /* RST n */
    case 199:    /* RST 0 */
    { pushpc(); PC( 0 ); local_tstates += ( 11 ); break; }
    case 207:    /* RST 8 */
    { pushpc(); PC( 8 ); local_tstates += ( 11 ); break; }
    case 215:    /* RST 16 */
    { pushpc(); PC( 16 ); local_tstates += ( 11 ); break; }
    case 223:    /* RST 24 */
    { pushpc(); PC( 24 ); local_tstates += ( 11 ); break; }
    case 231:    /* RST 32 */
    { pushpc(); PC( 32 ); local_tstates += ( 11 ); break; }
    case 239:    /* RST 40 */
    { pushpc(); PC( 40 ); local_tstates += ( 11 ); break; }
    case 247:    /* RST 48 */
    { pushpc(); PC( 48 ); local_tstates += ( 11 ); break; }
    case 255:    /* RST 56 */
    { pushpc(); PC( 56 ); local_tstates += ( 11 ); break; }

    }

    } // end while

    global_tstates = local_tstates;
  }





    /** Reset all registers to power on state */
   void reset() {
    PC( 0 );
    SP( 0 );

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    exx();
    ex_af_af();

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    IX( 0 );
    IY( 0 );

    R( 0 );

    I( 0 );
    IFF1( false );
    IFF2( false );
    IM( IM0 );
  }

  private int readBytes(byte[] data, ref int position, byte[] dest, int offset, int count) {
    if(count>data.SizeDim1-position)
      count=data.SizeDim1-position;
    for(int i=0; i<count; i++)
      dest[offset+i]=data[position++];
    return count;
  }

  void loadSna(byte[] data) {
    int position=0;
    byte[27] header;

    readBytes( data, position, header, 0,        27 );
    readBytes( data, position, mem,    16384, 49152 );

    I( header[0] );

    HL( header[1] | (header[2]<<8) );
    DE( header[3] | (header[4]<<8) );
    BC( header[5] | (header[6]<<8) );
    AF( header[7] | (header[8]<<8) );

    exx();
    ex_af_af();

    HL( header[9]  | (header[10]<<8) );
    DE( header[11] | (header[12]<<8) );
    BC( header[13] | (header[14]<<8) );

    IY( header[15] | (header[16]<<8) );
    IX( header[17] | (header[18]<<8) );

    if ( (header[19] & 0x04)!= 0 ) {
      IFF2( true );
    }
    else {
      IFF2( false );
    }

    R( header[20] );

    AF( header[21] | (header[22]<<8) );
    SP( header[23] | (header[24]<<8) );

    switch( header[25] ) {
    case 0:
      IM( IM0 );
      break;
    case 1:
      IM( IM1 );
      break;
    default:
      IM( IM2 );
      break;
    }

    outb( 254, header[26], 0 ); // border

    /* Emulate RETN to start */
    IFF1( IFF2() );
    REFRESH( 2 );
    poppc();
  }


  private int loadZ80_page(byte[] data, int i ) {
    int blocklen;
    int page;

    blocklen  = data[i++];
    blocklen |= (data[i++]) << 8;
    page = data[i++];

    int addr;
    switch(page) {
    case 4:
      addr = 32768;
      break;
    case 5:
      addr = 49152;
      break;
    case 8:
      addr = 16384;
      break;
    default:
      quit();
    }

    int        k = 0;
    while (k < blocklen) {
      int        tbyte = data[i++]; k++;
      if ( tbyte != 0xed ) {
        pokeb(addr, ~tbyte);
        pokeb(addr, tbyte);
        addr++;
      }
      else {
        tbyte = data[i++]; k++;
        if ( tbyte != 0xed ) {
          pokeb(addr, 0);
          pokeb(addr, 0xed);
          addr++;
          i--; k--;
        }
        else {
          int        count;
          count = data[i++]; k++;
          tbyte = data[i++]; k++;
          while ( count-- > 0 ) {
            pokeb(addr, ~tbyte);
            pokeb(addr, tbyte);
            addr++;
          }
        }
      }
    }


    return i;
  }

  private void loadZ80_v301(byte[] data, int position, int bytesLeft ) {
    byte[58]        header;
    bytesLeft -= readBytes(data, position, header, 0, 58);

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - 48K + MGT
     * 3 - SamRam
     * 4 - 128K
     * 5 - 128K + IF1
     * 6 - 128K + MGT
     * 7 - +3
     */
    int type = header[2];

    if ( type > 7 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesLeft;
    readBytes(data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_v201( byte[] data, int position, int bytesLeft ) {
    byte[23] header;
    bytesLeft -= readBytes( data, position, header, 0, 23 );

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - SamRam
     * 3 - 128K
     * 4 - 128K + IF1
     */
    int type = header[2];

    if ( type > 1 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesleft;
    readBytes( data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_v300( byte[] data, int position, int bytesLeft ) {
    byte[54]        header;
    bytesLeft -= readBytes( data, position, header, 0, 54 );

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - 48K + MGT
     * 3 - SamRam
     * 4 - 128K
     * 5 - 128K + IF1
     * 6 - 128K + MGT
     */
    int type = header[2];

    if ( type > 6 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesLeft;
    readBytes( data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_extended( byte[] data, int position, int bytesLeft ) {
    byte[2] header;
    bytesLeft -= readBytes( data, position, header, 0, 2 );

    int type = header[0] | (header[1] << 8);

    switch( type ) {
    case 23: /* V2.01 */
      loadZ80_v201( data, position, bytesLeft );
      break;
    case 54: /* V3.00 */
      loadZ80_v300( data, position, bytesLeft );
      break;
    case 58: /* V3.01 */
      loadZ80_v301( data, position, bytesLeft );
      break;
    default:
       quit();
    }
  }

  void loadZ80(byte[] data, int bytesLeft) {
    byte[30]   header;
    int    compressed = false;
    int position=0;

    bytesLeft -= readBytes(data, position, header, 0, 30 );

    A( header[0] );
    F( header[1] );

    C( header[2] );
    B( header[3] );
    L( header[4] );
    H( header[5] );

    PC( header[6] | (header[7]<<8) );
    SP( header[8] | (header[9]<<8) );

    I( header[10] );
    R( header[11] );

    int tbyte = header[12];
    if ( tbyte == 255 ) {
      tbyte = 1;
    }

    outb( 254, ((tbyte >> 1) & 0x07), 0 ); // border

    if ( (tbyte & 0x01) != 0 ) {
      R( R() | 0x80 );
    }
    compressed = ((tbyte & 0x20) != 0);

    E( header[13] );
    D( header[14] );

    ex_af_af();
    exx();

    C( header[15] );
    B( header[16] );
    E( header[17] );
    D( header[18] );
    L( header[19] );
    H( header[20] );

    A( header[21] );
    F( header[22] );

    ex_af_af();
    exx();

    IY( header[23] | (header[24]<<8) );
    IX( header[25] | (header[26]<<8) );

    IFF1( header[27] != 0 );
    IFF2( header[28] != 0 );

    switch ( header[29] & 0x03 ) {
    case 0:
      IM( IM0 );
      break;
    case 1:
      IM( IM1 );
      break;
    default:
      IM( IM2 );
      break;
    }

    if ( PC() == 0 ) {
      loadZ80_extended( data, position, bytesLeft );
      return;
    }

      /* Old format Z80 snapshot */

    if ( compressed ) {
      byte[0] moredata;
      moredata.SizeDim1=bytesLeft;
      int addr   = 16384;

      int size = readBytes( data, position, moredata, 0, bytesLeft );
      int i    = 0;

      while ( (addr < 65536) && (i < size) ) {
        tbyte = moredata[i++];
        if ( tbyte != 0xed ) {
          pokeb( addr, tbyte );
          addr++;
        }
        else {
          tbyte = moredata[i++];
          if ( tbyte != 0xed ) {
            pokeb( addr, 0xed );
            i--;
            addr++;
          }
          else {
            int        count;
            count = moredata[i++];
            tbyte = moredata[i++];
            while ( (count--) != 0 ) {
              pokeb( addr, tbyte );
              addr++;
            }
          }
        }
      }
    }
    else {
      readBytes( data, position, mem, 16384, 49152 );
    }
  }]]>
      </Source>
    </ZLibrary>
    <ZExpression Comment="init emulator">
      <Expression>
<![CDATA[trace("Loading rom...");
byte[] RomBytes;
getBinaryProp(RomFile.FileEmbedded,RomBytes);
for(int i=0; i<RomBytes.SizeDim1; i++)
  mem[i]=RomBytes[i];
trace("done");



trace("Loading game...");
byte[] GameBytes;

//@FileAction(Action : 0, File : @File(FileName : "Z80Example.z80", TargetArray : GameBytes));
getBinaryProp(GameFile.FileEmbedded,GameBytes);

if(GameBytes.SizeDim1==49179)
  loadSna(GameBytes);
else
  loadZ80(GameBytes,GameBytes.SizeDim1);
trace("done");


//Cheat code for Ghost'n'Goblins
if(0) {
  mem[36056]=0;
  mem[24756]=0;
/*  mem[36432]=0;
  mem[36433]=195;
  mem[36434]=163;
  mem[36435]=96;*/
  mem[39857]=135;
  mem[39858]=50;
  mem[39859]=180;
  mem[39860]=191;
}

//dump ram
//@FileAction(Action : 1, File : @File(FileName : "dump.bin", TargetArray : Mem));


//fill ram
/*for(int i=0; i<mem.SizeDim1; i++) {
  mem[i]=0;//45;
}*/]]>
      </Expression>
    </ZExpression>
    <ZExpression Comment="timing test">
      <Expression>
<![CDATA[/*
int start=GetTickCount();
int ticksleft=60000;
while(ticksleft>0) {
  ticksleft-=4;
    int pc = PC();
     int t = peekb( pc );
    PC( ++pc & 0xffff );
}
int end=GetTickCount();
trace("Time: " + inttostr(end-start));

quit();
*/]]>
      </Expression>
    </ZExpression>
  </OnLoaded>
  <OnUpdate>
    <ZExpression>
      <Expression>
<![CDATA[execute(App.DeltaTime);

App.Caption = intToStr(App.FpsCounter);]]>
      </Expression>
    </ZExpression>
    <Group Comment="input">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[Keys_1_5=0xff;
Keys_6_0=0xff;
Keys_H_ENT=0xff;
Keys_A_G=0xff;
Keys_CAPS_V=0xff;
Keys_B_SPC=0xff;
Keys_Q_T=0xff;
Keys_Y_P=0xff;]]>
          </Expression>
        </ZExpression>
        <Condition Expression="return ANALYSE;">
          <OnTrue>
            <KeyPress Name="KeyAnalyse" Keys="F" RepeatDelay="0.5">
              <OnPressed>
                <ZExpression>
                  <Expression>
<![CDATA[if(analyse_checkFrameWrites)
  analyse_checkFrameWrites = 0;
else {
  for(int i=16384; i<16384+6144; i++)
    mem[i]=0xff;

  analyse_checkFrameWrites=1;
}]]>
                  </Expression>
                </ZExpression>
              </OnPressed>
            </KeyPress>
          </OnTrue>
        </Condition>
        <KeyPress Name="KeyTest1_5" Keys="12345">
          <OnPressed>
            <ZExpression Expression="Keys_1_5 &amp;=  (~(1 &lt;&lt; KeyTest1_5.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTest6_0" Keys="67890">
          <OnPressed>
            <ZExpression Expression="Keys_6_0 &amp;=  (~(1 &lt;&lt; (4-KeyTest6_0.KeyIndex)))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestEnter" CharCode="13">
          <OnPressed>
            <ZExpression Expression="Keys_H_ENT = 254;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestL_H" Keys="LKJH">
          <OnPressed>
            <ZExpression Expression="Keys_H_ENT &amp;=  (~(2 &lt;&lt; KeyTestL_H.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestA_G" Keys="ASDFG">
          <OnPressed>
            <ZExpression Expression="Keys_A_G &amp;=  (~(1 &lt;&lt; KeyTestA_G.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestP_Y" Keys="POIUY">
          <OnPressed>
            <ZExpression Expression="Keys_Y_P &amp;=  (~(1 &lt;&lt; KeyTestP_Y.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestM_B" Keys="MNB">
          <OnPressed>
            <ZExpression Expression="Keys_B_SPC &amp;=  (~(4 &lt;&lt; KeyTestM_B.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <ZExpression Comment="kempston">
          <Expression>
<![CDATA[JoyState=0;
const float threshold = 0.25;

float axis=joyGetAxis(0,0);
if( (axis<-threshold) || isKeyPressed(ord("<")) )
  JoyState |= 2;
if( (axis>threshold) || isKeyPressed(ord(">")))
  JoyState |= 1;

axis=joyGetAxis(0,1);
if( (axis<-threshold) || isKeyPressed(ord("^")) )
  JoyState |= 8;
if( (axis>threshold) || isKeyPressed(ord("_")) )
  JoyState |= 4;

if(joyGetButton(0,0) || isKeyPressed(17))
  JoyState |= 16;]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
  </OnUpdate>
  <OnRender>
    <Group Comment="gl texture render">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[/*byte[6144] video;

for(int addr=16384; addr<(16384+192*32); ) {
  int y = ((addr&0x00e0)>>2) +
       ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}*/


if(VideoBitmap.Handle) {
  glBindTexture(GL_TEXTURE_2D, VideoBitmap.Handle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, VideoBitmap.Width, VideoBitmap.Height, GL_RGBA, GL_UNSIGNED_BYTE, mem[16384]);
}

if(AttributesBitmap.Handle) {
  glBindTexture(GL_TEXTURE_2D, AttributesBitmap.Handle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, AttributesBitmap.Width, AttributesBitmap.Height, GL_RGBA, GL_UNSIGNED_BYTE, mem[16384+6144]);
}]]>
          </Expression>
        </ZExpression>
        <Material Name="SpeccyMaterial1" Shader="SpeccyShader1">
          <Textures>
            <MaterialTexture Texture="VideoBitmap" TexCoords="1"/>
            <MaterialTexture Texture="AttributesBitmap" TexCoords="1"/>
            <MaterialTexture Texture="PaletteBitmap" TexCoords="1"/>
          </Textures>
        </Material>
        <Shader Name="SpeccyShader1" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  vec4 vertex = gl_Vertex;
  vertex.xy *= 2.0;
  gl_Position = vertex;
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D tex1, tex2, tex3;
uniform float bordercolor;
uniform float flashtime;

void main()
{
  const float sideborder=0.1;
  const float topborder=0.135;

  vec4 color;
  float u,v;

  u=gl_TexCoord[0].s;
  v=gl_TexCoord[0].t;

  if( (u<sideborder) || (u>1.0-sideborder) ||
    (v<topborder) || (v>1.0-topborder)) {
    int bor=int(bordercolor);
    color = texture2D(tex3, vec2( float(bor)/7.0 ,0.0) );
  } else {
    u -= sideborder;
    u *= (1.0/(1.0-(sideborder*2.0)));

    v -= topborder;
    v *= (1.0/(1.0-(topborder*2.0)));

    int specX=int(u * 256.0);
    int specY=int(v * 192.0);

    u=(specX >> 5) / 8.0;

    vec2 uv;

    //get attribute
    uv = vec2(u , 1.0-((specY >>3) / 23.0) );
    int attr=int( texture2D(tex2, uv)[ (specX>>3)&3 ] *255.1 );
    int ink=attr&7;

    vec4 inkColor = texture2D(tex3, vec2( float(ink)/7.0 ,0.0) );

    int pap = ((attr>>3) & 0x07);
    vec4 papColor = texture2D(tex3, vec2( float(pap)/7.0 ,0.0) );

    //flash bit
    if( ((attr&128)>0) && (flashtime>0.0)) {
      vec4 temp=papColor;
      papColor=inkColor;
      inkColor=temp;
    }

    //bright bit
    if( (attr&64)>0 ) {
      papColor*=1.1;
      inkColor*=1.1;
    }

    //test pixel
    //     zzxxxnnn
    //zznnnxxxRRRRR
    int addroffset = ((specY&(128+64))<<5) |
       ((specY&(1+2+4))<<8) |
       ((specY&(8+16+32))<<2);
    v=1.0 - (addroffset/(6144.0-32.0));

    uv = vec2(u ,v);
    int byte=int( texture2D(tex1, uv)[ (specX>>3)&3 ] * 255.1 );

    int lit=0;
    if( (byte & (1 <<( 7-(specX & 7)))) != 0)
      lit=1;
    if(lit==1)
      color=inkColor;
      //color=vec4(1.0,0.0,0.0,0.0);
    else
      color=papColor;
  }

  gl_FragColor = vec4(color.xyz,1.0);
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable VariableName="bordercolor" ValuePropRef="bordercolor"/>
            <ShaderVariable VariableName="flashtime" ValuePropRef="frac(App.Time)&lt;0.5"/>
          </UniformVariables>
        </Shader>
        <Bitmap Name="VideoBitmap" Width="8" Height="192" Filter="1"/>
        <Bitmap Name="AttributesBitmap" Width="8" Height="24" Filter="1"/>
        <Bitmap Name="PaletteBitmap" Width="8" Height="1" Filter="1">
          <Producers>
            <BitmapExpression>
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)
//Sample expression: Pixel.R=abs(sin(X*16));

/*const float sat = 0.9;
const float[8] rLookup = { 0.0, 0.0, sat, sat, 0.0, 0.0, sat, sat };
const float[8] gLookup = { 0.0, 0.0, 0.0, 0.0, sat, sat, sat, sat };
const float[8] bLookup = { 0.0, sat, 0.0, sat, 0.0, sat, 0.0, sat };*/

const float sat = 0.9;
switch( round(X*7) ) {
  case 0 : Pixel=vector4(0.0, 0.0, 0.0, 0.0); break;
  case 1 : Pixel=vector4(0.0, 0.0, sat, 0.0); break;
  case 2 : Pixel=vector4(sat, 0.0, 0.0, 0.0); break;
  case 3 : Pixel=vector4(sat, 0.0, sat, 0.0); break;
  case 4 : Pixel=vector4(0.0, sat, 0.0, 0.0); break;
  case 5 : Pixel=vector4(0.0, sat, sat, 0.0); break;
  case 6 : Pixel=vector4(sat, sat, 0.0, 0.0); break;
  case 7 : Pixel=vector4(sat, sat, sat, 0.0); break;
}]]>
              </Expression>
            </BitmapExpression>
          </Producers>
        </Bitmap>
        <UseMaterial Material="SpeccyMaterial1"/>
        <RenderSprite/>
      </Children>
    </Group>
  </OnRender>
  <OnClose>
    <ZExpression>
      <Expression>
<![CDATA[MemSampler.ValueArrayRef=null;

if(ANALYSE_CHECK_HOTSPOTS) {
  int prevWasHotSpot=0;
  for(int i=16384; i<analyse_hotspots.SizeDim1; i++) {
    int count=analyse_hotspots[i];
    if(count>10) {
      if(!prevWasHotSpot) {
        trace("hotspot at " + intToStr(i) + " count " + intToStr(count));
        prevWasHotSpot=1;
      }
    } else
      prevWasHotSpot=0;
  }
}

if(ANALYSE_CHECK_PC)
  for(int i=16384+6912; i<analyse_AddrFlags.SizeDim1; i++) {
    if(analyse_AddrFlags[i])
      trace(intToStr(i));
  }]]>
      </Expression>
    </ZExpression>
  </OnClose>
  <Content>
    <File Name="RomFile" Comment="Imported from spectrum.rom">
      <FileEmbedded>
<![CDATA[789CED7BFB4314D7F5F8CCBE17D817CF010CCCEEA08EBBA20BE2324558E5251A9425A092E8A8C194A8890145121EEA86A4ADA9E923266DD3E6FBE9A76A9A863C45F3F063FA30ACEB52C6714454D03525B09A5D92EE67251851A361F89E3B60DAEF7FF0FDA1139C997BEFB9E79C7BCEB9E77167F34DA76972D2CB9BACEB59CB469628F6DE48984417B4DDC21EEC9CD08411B7A1ED5DB740EAF7596BD9A0F70F89E3416B0B4B595AD8DD1F93F2899C25BE7EE153599F2730768F0BD44F3C8D457615B05E5FE2E4D405D0471024FE55602C520AB8290BE0E744F33951D7231A2F8BC4E2CB9498C8E0542E0C709F56559C5A5E515EFAC81B95DCD2B395AEE51517AB8BAB4A4B2BDE285CB5EA7CE1C5558527D714AE78A3D855E25B53786645E9D9EAE5678B5D1756159E2DAC3E5B587CA170D5D915674B1F3E87E63D74BEBAEC6C61D185CAD2527EF9D9D5D5E7AB5755BD51BCACEA8D0AD7C5A2E5675DE70B2B4EE5FFCDF9B7FC132B9657F8562D2B3DBBAAB77A55E9B992D2A5E4D2B3C5851797BAAA56165E5CE95AE32BAD2AACF6B92A4B2BC83F16AF705597927F5C595A55E65B535AB57CA9BFA8B4F45CF1F2AAE215BEE5157C656165E9F9A52B0AAB7B8AAA96972DBBB8BC028060EE9AD2F3AED51757545601672B562CAFBE58BDCA75AEAAB4F05449E12A4F5529B4AA7C15A5978A5C5525A5E78B5D15AB9657ACF6952C17AA4A85A5AEF3652E72552FDCAA579F5C5E5109785C85A7109215A5172B0B5757C3CC872F56BACA7D12FACA15AE8B55ABCF5617AEF155155694B8562E5FEB5BDE5DBCE2424955E1A5E215A585E7AB4A57ADAE02B955FA8B963DE258B8AA6C4DC583AB7373AA9616AF2C5FCE2C282D7958BFC2F583EC9AEAB5A4AED29EF550E1B553C35F7CF4D7BFFDA5F3C8D1AE8E374FBCFFC19F837F3A19F8F013CF71F73FAEB0FFB36BCFE54F0FBFF3EEE0E743CF7E3CB0BB7FFD67C7FCEB2EC5A8550AA5262A5A6BB86A5D2CF49CE137BC97692B98377791E5EFF95EA76F3EF76877DEB9B36F9DBE70B1EFFCDBBDF3E68335E2A21869991F4AA7F59BF7C4770D68F87CFBDDEA8DE4CD4C1E63426DF93D22DD2326F7EC5A5B23129CF04B599719637937A9A616DA489963728F59C1FE8DBC2EA4C9CFC1C0097A5E183A4ED0B3014411E6DD3D1B9B298792CAD3B2CDD444857A620D1E1416C803CDD91A7682C7AF73687061575E140CBB897F162562BBC4D9E7448294F32D5D66A52CD99DCBED12F398F9BABB2E392DEF7671E630AEA0E530948825BB39F31C19BF84BEC9AFA5A32678FB862E455737C975FF8913ED977577FF5B4E269B57C9F82DF40591B1AB0748454FB7861B70C043E4CC7699F803FACFA29D3E165277B72B7AAE1B38450FBF05FAC937068CA285568964977323E75CC27DB3872FE00BE687E42E153668EE930F6AF396B121C66030DCD26018A688D19113FAC5CA9303F2EBC60B62898BDF4C6ADB3EA4B5AD2B5307BF5A1933F8D53D6E346B76973CE77FB7FD2E7D5C71C8C0985F61DD1DE406AA825ADA9274E01372157582AC6CE9CEBF315371759B427557311063BFD71DE333D72B04558EF0D182510533B6B779B44B96C508BF4E13A3ED96D161C5704E7BF1EA03EDB83267E10E3923BC96E6837F81CA47DA3EEC49F57E2CEF8DDA273B17BB775FD46F1F7D7A5F6C7F52FABED4FD85B27D19E7AA4FEF9BF7DF8EA3FB98C9E5CE7DC5934FECDCE7EAC056ED63612DFBB6C6DFCAD8F7CC985129DCCBC85BC4BE70F7C51981734161CCB6E949DD1D2D0F825BAC0C9ADBD3F967410BBF8BD1C40DDABE71CACA8CE205F1BA41F5462639AE9C79E3B242351FF53875AA5CF4C4F58B340D5EB512841233588FED7E7FB313CFF5CE546E236EB6F22D46D1AE5015213895931C5576E6F30927E395A983942ACBF9EC6762FAB9B6FC93A242B5C82872E3F7050FB8D1D03D46D61B33C6C56B12BE71421FE20D7A43E42D99EBD32E614469BF6B4E5018451BF8C26F856B4A7B58F57BF4F8C2D97DDC3E9C418EA93804D4DF225EB4DF84B773ADD7E5AE5998EA0891AE21D576C3E0D31861E04DEF77B5A6BBE208F5A01B7BBF6B904AD5A83E9887039E734EFE389FA03A72FEB41296D4F621797AB788238CE79C8905E44487A2678AFFB74324FD4DEB7C57487D4B7341CCE5C6F29AD881E1EC2656F8F90CC13E93CEC74D187475D032BDE576FF604015ED2463E38CDF0D3AF04990BCF9D664B4566E37201052D6AB6F394A47E151D860304085234786C42FC8E53024CA4FBF386344F880E6BFB5479B3184B0804EE8C54FBE28D12028F7607334BAC550833BF44E9CDF41E3F983CD5878449C435E1911AEA786BD6BD5E23B64FABF905D4F1D744463838E985433B664F069DD60939E58297692AE7F812C23C918C4183484D00CC2203C3F63489C4BFF7B9F62043A011718E7E08EE8C1ED31D28B6E70BBFED1AD830E4C4E9488A769AD444CDF4E24A1992711EA7F4D42B00089591F6123EBAAD9DC48D5E0D3D1834D31D67216BD1A069B8C6189E0766D106439A81D0C9A4C5867AEB0463918B0DF708A029E38E1A892EBDB41858327464999FE96A8B0FB4D5D5A9F1015E3190CF699BF9E4C5645B9F349796BBB2B2EE50445E231978CB7F856F243A7EE5200E68972695505A7351A5176FA982638587F77F0F17B831BA207D7C4ECFE98D645AA9859B45A82241F0880C9A906EB75838FEB838301242F592E8977382781A7CBBD2953B38208282E2E2E4CC44C210BC3D218AD49892597AC1494E9886C07ED04E471B6A5B60A9B5C2E1F84B441F83279D0BA910569D8062BA20797C6F8D0807B625C589D488D35F7513BA9460AA8E63A27BD324D58828369D3B04230D913F40128C2410D561806971AB596721638DD1DEA22A380694B113BE188C2FAEEA3B84FE5B6A33DDC179CC22CC83401A40C37CC494E890381C9524EA4DAEC9A6058389E1C20FE5798AB25AEBA5D627B4F10F4E416DBE9999FD01A1F0C7AC2C4D7A161F12019DBD71FA440D8A42AC97E3B40C803C4B073B22F9C9F8BE69E228D1AE01A6183058781598DA61F1AD067AD66AFF9348CDA86164CC8D1DDD317A9AE06EBD8C8FAFA6157043CFD30A98F0B3A2740F79DA6435AD0F3042FBB2E5C4C98320EE1A402765AF633C689295D38270703DE938AF6EAA6DAC626B2A9767BDD5CB2694B5D3DB9BDB16EE74EB2B6BE957CB2AEF5B0AEB2B1617363ED53790775154F3FB5A9AE91AC6D6CAC6D8566F196DAC6DAC79AFEADA7A8B5A96E67DE41411E2D92E7FD51A28AD92A12F63A7374D446885E1B92835E7974458D71CEAAEAAADC4AD7C60DEBD9756B5755C7382D9F9026888E15A456A1973989E3A45CA9377BFDBABC97D9F109470DEE2485BAE8B1EC97590E419D14F47AB3B03A46091040AAB5A0206424D63A1713DB4C2F44651B5822DAF4541421470D3D6B7D8805E3E04C37B5427B9455CFD6EC1113AF982CE49C92079DE92F3331DD32974439D199B8FFCA81B4FC3205086DE9C9D5311327B2AEEC8D0112BB81C67305A1F49E1A00EC065616C52490773821235A9A9882E0494DA4F8A7ACE5C72C17297E918D143FCF5AF602B33B4A2DED533C93F191F29FB2D61FB308BA2752FE226B450015A5560010DB990271BF7D5699C0440331D32B2C510601537046F3C48190C185EE5F1FD52B9A291D798F1BF8935DDB9DE08B94EF82950AC6189029341C6CD8BC88E5F78A2429E3BB67610D73E6CCD17AC2AD054E33A9574A6BA455FD82A0EF6BFDA4FFCCEA983E5F10A4AB9A4C6770457AFA019753D321C12821AD389B1BD6A41C3CFC76AC86898BA70AC81BE19968ECCC67D1018F8EE2344EF2471B3544683784A590FCD6C39B23EB5E62DDEFBEFEEE045FF30CAD09FD9DAF2165D719683D0EAD3B7C03B4D4CD5C7016768D50987E838D0B85318CD64902CEA56716C5A4849E0591A6C4BD601FEF1397D172F1F9CB6DA2FCB293ECF75FF2F771E3E17CDE4DD1F70AC83BE13191BC9C32502849B4CBE4D7F5B748CA92E940594C6A17341EA7132736643E40AF7562B00D22BB162381BFC9F52A26165691A54E627FF6CF59EB4B2C5AFBF8F44EB91333BD5390FC3EE70FFB61C7F845922E15AFD285B748B19E5E24F953647F01CB4BAC20EA26966629F4669FF05FFAEF65601A5E9B52A122C3B13BE228E35D0FD7BEF3B1C6866DDB3EED8D11654CFBC4DEAC81E47391125F19226E7D990D0A2B752DE3E627D9A52DF9CDE67DEC09469EA322044C3F56407E199878BA06514226038CED15FC3A78747BB84EEB2F2403A2159B27EAF500617E9925656EC3E1D0EAC3CD9CD0A933E7B3FC61BE1B90038B4289DEDCB536EF17AC9250EB495B33188FF1F684234B262D1C36066C8A0EE4394D6F191733B77073126185386AD90334EC7B855FEBA465032E60AC443F050FE0105770DC4C98B1759261C74A3A00BB812512BE329089C7697E19ED77EF3FA25449D0D66B7CC19690BA858C099B87EF248771122B881C81F7C9E47059480D1274B5A8B0C811955A1BBA437E16C8F0E84841F8A95E02806EDCF72F24D3C0BA55EB1D585CE4880957271784EE94914169D63F60D6A627E3F2A6A52487E4A9393A72C4A33773485105B72A37876BB7CC4157C94A0EACA106A96FB8A12D44DC5AB299FB467504C23E848A9B7A4F206377484D46EDE9261B161F08DDF9F166E308A1FB0616ADD248E3C66F9D8A0BF7EE21293CBDB4B3AC99327E0752FBA5E4B65A44F98190ECC2BD1A61553A1325C10943FADE98CFEEBD70C71ED6431AACD2F0B17C1C9FF2D9BD74FBBDB60BF78C5FEBC8AF386B011B343F6B0C467616B06084E389D8C48649730F267C2C1F33338620F8D22C51CD648A46260F97613550D0C6C827F85CF7E93423C06F847FFDD675B076F55E88101E6A3BB58388422DE814AA1263E322D5EB580E54637ECD80BC317473DAC79FA8FC78BBBBF7A275394CCCAD3FF95BA3509F2CFC26B1EDC3D3BF350651C26E8EC2B45274167E6B042BB81684588827066C130B0DC26A6222C700F19682CBB28E0D0809891C42436ACCCB59C1904C3C35E1C08CC40342969150BAA11847501CB4701CF37E990C1CC35F2010B0140075CCDDF52D972BFCC614A94AA63C977D252B373D49A584BE168DA4964A19483A8B9138D51129D286999044A50B98066EC3C0AEF9415698017C2739312FE43E2014FA2DEF7306D0C9E3F421E06112095334EF4F01617AED86A0B0DF6483C400B89970A8B100A0936D38F5800939C1FA9E3CA9583B3C0E9DF5A7EA75E076EC55A2D19E29AAEC516521DCD592DE1D4B5849ADF909D6A939DC4CE845FDE5019DB9903DD10C252206D33EFF9403D376398DFCC3249E3FB1E38249672254793A16F69AD505E2828D94CBA17DCACBFE00FF0E5B5F04BF80F4BFD924E9DFFA3C1B44A2080B7B88B0102060FC5A18E0F37EC6BEC2CC2255BB265EADB4A78193146E6AFB88AFFE6D7568B191752FB284AC4F922B24067E5DC0F23C2C7416C6596B595B4764DD2392B27B22EB6AD9CBD6C758CE2DEA711576E6CB643725EAC831EE1B27E0F880F547CA3F821C8361ADBB587F99530D55C8E24819265D9B9E74C86C7F25EF76206DD9550B69F942FA1B9B3F520C33AA19D602331474B2E523D6D4E9C4DFC2C291E3610A3A6DF8122C520CE31FB0662CDFE260AD1FB00EA7ED5B9B0D788DAC9930E7B1F7CCC7588B0BE625E00930EF48D866A961294B350B499BA39DB23CC23A74147AA9652D8FB1963AD6C964FF82CD7E89CD5EC69A29A545CB4E2CEC9E5878DADC9D6032B2B81E7C0BA8F32CEC41E4FD8427759D262661DAE9136AA9EF3749C29144296608730D42522A32463256B29E2560DE4287098995188477CB7A56B897DC72F4E4FA8421514743D4B12F3DD5A913EA75CEE489575D1060809888C021A5C48517539F41B6045015A7047D5E1E9B3F0E4E76A22977A26996259A35E398259105E2A08FC38003F13456264631B26EB5309AE0242FB5985E8E03663B4D0EC473A4BC941552539C7997262A742A0C5E615722AC74AAA8A51562023A2DD3E172CCB49D3597B0BC9BC6B591E3C0C92470F107EF7BB1ED2EBEA2F4E15564F3D6A62D0D4F37914B5DE7D7D4366EADDDB4AD8EAC6F68221F6F78BAFE8BEAA73741FCDABABD896C6E6CA81F71015CC3E3E453754F35347E3BDD80F1BABAEBD32961534303B969EB8874E253F13DEA3257F5EA93A5F53F44E08F6FDD16AC5EE5AA247736D536D53D55577F7379FD33B5DBB6FE1092C7CD4F4FB59BEA3603AE8629FC8DB5F59B83150DF53BEBE08FDC5A4F1615562FF716559516969399243ABB221BEBB6D7D5367D33CD103AE2BA8F13A8C16A6A9F0204646343C353B0AA4672DBD6FA2916009974BEB5D455F53DAFE86CEBFEECE5F35DE40FEB9ED9FA58F07ECF630DDB1A9EBE31457C6B7D5303E4C828298E5415AE4408EB1BC8CD0D0D5F544F2FAD89DCD6B0F3FBF5ED6C6AACAB8D2CFD97584A4ABB2B21737EAA0EA5CE758D8D0D375641F20D736A7FB8B57EF354CFDC83CF92593F60B2C9EAADF58F6DABDDDA4856D5EDACAB6D7C6C0BB9A2E90BA711C7306F5C5CA478396B5D0F99DFEA84206C6CA8A5828F6E058748AAA66A084F6BC1119A46C592DC864A977E080B01D8471E5F1CF203B6C87170A061CF76DB0EDB4E5BE398F7F5D89BDAB78CE537B5A712AA9F339C4AA8426F95EDBDB138A6C2A2311C434F23F26FF524CA933F17420997E9BBBD6A7F10020345119A34FB8FA4F70DD49AB0303731E0E75EE84E6C9885DA6D1F422D9F940ADE2FD9F2104A31DE4441A3C29C9928FC23F15C22B621F9AB7255756C652AC2DF3DBD674204A2B3175ABFF42267899FE520720451A928FC30D15AC7825BE1C683E672D6A9071AD79033BA66D7F687B5E146DB4EAA0FB2D72FC37D63D05DB2529E1CE6302C6C7A29119570B7D7501B38707D5249457922C5B5AC274C7156E45C202A4CFB17ABE462AC929709424E6ED9C20638E43EBDC164CADDD1F30945DE013F9E9624E049A013D3D53F869319357E31410B8133BC83DACE0561C15AB4D0B0393109565AA1C2B45F952BABE595788043475B4606C4D22D579B8DAC0BC6609E8D1BC519C0D972944E0C4F4F7787C5725A2356C316AF247B85F549A8AA41C7542D47D111892F2534E432B72102F63144C28384A9A98CC2D2704295A6226469C66800EDAF0970C4FEC84EC88B1D3223648C92ACA55C714ACEF66E3089C8BA6D2C922463E9076B3275C9C291AA6BF0E6918A592DA30F83F06C91EA6D2C11B16C63ADDB5014A6F1B0B08090D26DA79C903965400113EC334FE18943C27692891F121701F77349153AE92034E8A4442E7C3E7DE6D1125ABC79AB450AE76938A41597A464FE56DE932CF854F2FABB3DC17EF3369451F441CD1C2907C0F6E44427AD3461181F37B133D32D2EF19CF309740AC80ACC646F5B07ADBC840AB6FE302CEA5594DBBF8A421E2DE307A0B286D5914AE762C143406C0DBB856304C43D5A1516729389E13E4ED47751D2E5E6FC2863E7FFCA4F4CA5DB6BFA1D1884DCC0449394A2FB3948A20059575E21CBAB69457731918868FDC159CEAFA1A3F9CFF3D1312D2D7316F703AD3E0E6C3418A6A632AC8094C2809972BB3AEE10BA4E6D3EF35DA4A8801EF38E2608A99976BB6866E6C2125E15793A43CC23F552620581C2BE868E879CC342468DE73DC15E57643FC18E01DCC02530B66A76D57A0FC8E61C525598B8E93EDE45B96D9F70283F5BCFEAB1849E91BF908A0E8E426B861EC082EBC43C500C4F2AF8421A421A792D21970B82409924BE818E7FE1EEDF9317E34ACC2ED3C726516EFB3D4245A1B490D2F649DB0A76953098EC6B995FD63ADF25875D190E24F7478E04D056B2018511B46DEA586151A6F07A26A3307F7D597BE5C5195E5F627FB0936F21C947B7A64D129A7EB0A860388DC489EF046B32FEFB49B8EB6FC16D0F44C1401F7794FFEBA7A73A3FFAD5CBAFFCE67753D7B3CFCDDB56BF7DD9AFD72C2EB425A5E73697181EB115673E94F754916E395B92B01E2F90A9B0CD692A5EF9F50C282FD2B0EB33302A5D51A03AA352CA1F5060EF3EA014D295FB48A56CAEF28354EC7F4CF24369CA6F9334587B9ADC95866D4C93BF97863DA9D362FFB0A8B0BC7465E401E5EC3479519A56F93C85BDA75772E9CAF1A468B834D81DB95649526AE9D2606D692AECD716E5A3E9AAB951982349850513A3B05F2545CD95EEF00FFE405D27208BE8CC2E630BB2F358021F113E4D84C07DF7C519432A0C4CB10D7412363F931A748DB40E9C0581B9CCCB52B4155A426E6D62DD94A589C5AB527D2EC84C63CCF80CE437B4C1212537F4093A49E450E121EB8D9FE0A3DCE40E6B11CBEFA6E3CDE2A4A51439341BF25FA979252CB1000C119E747207595C064EB18536F44E7A60CFF65857B3CEAE37BB3A45FC2C069A895497B214F2E9C99465351B06ADD6A46128A9489868D49DA653E3859F25D39ADE4498DAE5F1A0B4E8CF621EF47B5F9C6178A05CBB397AD72F777CF45C2FECF64F3D67AEA786610DC83FFA38E1037AC2918BD93560DB6749A2173FF3EA1C90CD33A4AE13B98E319B79077BAC391C296E642D2B59CE23AC41FE82CB5BC48E0BF732C626D6E0EF849690197CDBC9492B4236DE7AEB403E193F46BC8D9C0C381BED08C0218C5DBDD1D36F3DC44D78B891BF3BB552279D4DC709DF99012F6C75CB2FD02E77AB0F87DE4125B57D261D2795E02B75E6FDACFBD69DE609BEE6D89070D54C1CF02A55B05005ECCCDF23918D1E64B85E0D921E1D352A63C2C25739573E4CF5CE491505C48574B84BA8E0367A8819ED92E1C3E0E327AD10506C6E5E84E45BAB66547A1D8A46C151998C0984F5519123D652368C6AEE35BA78AA51B8F2C0B989A50CF4598AD8BC3236525203D13FED1B5FA47C352BEC7D2052BC9AF530A6915BE4715A3E427C39E2C45FC92E61B95E931BAC89A040C3B95D4BA98A4871118B767010CABA4022E603E579CE11C3A0828A93F3665857A2AC319D02CE4687AF1ABA640CD0BD6CDDC29A0C5832D800F578D8BB33AD171B0D0C5F7560325C9E8B29980E8EC9E5468474E9E87DCE103AB2AC61DDE25C5A9BF605706697F5EA84660CB43704A93CF85F548B082D183A39E79042611A89F423CE3D753D758418777E5116F9C484C9BC3F4B86E0202535A808E050A4384A2A22E52D6CA4F81996B3D6B3136B1C448C049488ED16BFB6CF4587B98D519CF093B4482BBACB38A13F9349A065919271801B434D883CE08CF09EDE2861731A046EA1340DBAEE23FF80F545D6954BE7CD502342C1008986291B4BEE8B54D935D68F90C387152584A186E9F3A0E2C5874AB6F0577D138FEB32AE2D4039BA4FAAE2FA11F6780CA66B99A8B0B9124B66E491C6CBF3E4DED518A2AA4C2F59C979027D6DA2938E5E742D8CE6F840BAFDC15E1570F30C846C3AA6E5503E89CB51614A5F476911277D64B9EC14E12E59A8D279D6FB833418BA25FC62AE3D7144CC2095D03A3622D264FE88388726A1FFFC8B33C26844161E0983B549598F430F3B042C65589C43C68D8805A47EE4FB9D75180F2D419F52203ADB67067ABE9A8AE953F11C768330948EF436249492B44EA820E97BC277E9E8F98D38A747F0A63B7597B821F13D5227B4CE80A6A0A69C8984517C9F8C95B602F4BC96E64CBAD47AA9E51227DC309F830CE11CD08501B445CF8CD94E5ECB6C391ADD93127789B80D28D177FC3C0EA510F1C073145A76B45375895089B3BB84F1F411E083C43D9F722295DB852874201228BB3AAF4F84AAAE431294C689A30A0FAA2C870C173C24AC009DB14192719C91EBCD65E810D799BC5F2AE1A463376FFDD4DA4090FA1158F2903807F957EF0766F1346942F60E9B46441C4337A14362EE344FF59E0082A73F30835B0717C61FE3AF43DECABBC9681030782C995E7EACF9B643D76A30D8954E4BACAD199D44F0B96E722E6CE9A993803C73502A4015D27940EDFD22140A54297A7C62068B857787051306CC2092074C91F2E759E01A113CCCBBF913E40CE9042000DB11D5A430657AEB8103279220AB45F57F2E0AE2C207567046805052E2690F890E0A006A48BC4AC7E4ED608547668057EF011F0A9EAED72865FB901D89E5B0E96F982FA37D7C0B7473031CBEE8BF2C0E2DBE3C3E3236C08D8326C6902AC64117356397DA2E7103A6B318FDC0800CEE6B44BC4D85930AB55AA570B589327B622BF85E826953A9192584521503BD5009F7C6995F62450D13EDA6D547E6873268BCC5D52A6CB338D57F3E000FB53A5459E6D4FCF9C0E183879BA916EE409B41D54ECA0DAA25305D030E5A66FF5B2B60005010B781B88CEC42637FFB820834A64EA7B397B19CB373FF956F33CA3AD273D33BD2DF0ADD796B732B8CBF15FAFB5B6A75436B48CD810D0BEF58CA146EB57122847BE94CD411B4405D1229DEC34A434ED1609C28734F54D4F085247E907F8894BD35BFD9FB59B4104F95F9E0F688E72117F23F40498FF7E827C1A2E7FEEBDBDFA8B580718BCFD995103F8843A37F641C3F1AF581FFDD93E11BCD0A2860ACDDAE41C1C1E3FD8765F424DE2593E3C3862E3C6B18FE0E7A64CC44CE26585C43106E81CD963DACC74B6620DDA0B0E36DCEB84FC6F7BA223DCB6EC75432067ABB641E5996358007AC8661A575189FE2418DE8C0A8445C16C0951E190E3C9C94EE5783C3F2D71559E93E19D9253B29F30415C357158600EE910DC398427ED20AC8644C8AF89CE74A33CCC7993C90109D39DA658057B7F4EA330C07198F92CE27E2470359D71457BF50C83DB22F1457AF290C27658C0F6264C090757FA21C85227CF8FE643923FC4F86C7D80D4C7E8F5B8EFF3FA3A097D12C3A271BC395415C696550105085BEEB56D865CEEFC611187467A59F926581343C20CB2C4596E1903CD50BE245BA6E3D6E576DEDEFDC48A88FF66C29EC4FC41E6D49FF0923FF2BA3FEB5CBEFF1110A57BFDF63DDC3B6FCB8AC35FF278C8ED615B8C01CFCAD467F1F477FD31B05899CCF657E7526D464ADE77F3C4B855568BF129A30B9A83B0DBBC4427E030DD1C2212FAD022F39E55B506682A85B1DAC09C3935BA503EAB736B68688EB4B6A548FFAFA83298769453E9952E052A9E3A994C36F9306E36D8FC7E36CDF0F1EE6762C111530692054798C1796796157C342D0A139200123965F7F78B31B2CD7328376CDBB618B7D6BCD9F6A3A7EFCE64BA742EF7CFAEEDFDF3E8B8D78273386A8208A4D8699642ADCC0B183E734DD0EF4BBA9D83860FB8E9B122DF48DE83E54E71CE3DDA73EB07A6367A3346BDA39C6CEF6FE6D369A4447CA9F61055BE6E821434E6EA222A7BD10C3DAB36587E4590C445F14BFDD1DB47CC0D84C6811B8020C3E67C4EB9D85AF358E88D469DDEC690A74BAF04B991E23E38434B95D9FB05158201F476B1D8B45879682445FB0CC3CB570E688F7B399E8AD7DE608B10CBDF0961162B1F0D3B9F63562A13D1F651994F05F7387A603A0434F852136EB951D91222851D049236429847E083C9B9EBC4B091F2D001F88022B110FC9E5957933203D05072E76310A34482CC03FD38A99F46C1C42DB619A1CE884441DFF5A21C6D3F1106F55C6EE7FB8C421BB8C3F2A5E6764FC273E49BCA0EF1829C74D12AAAC23C4D72ACC65FECD6C54B9AB2ACC9159DAA57D6DC799BC8ED304E60301EC1223A48A7F8694A5BDD68FA4A4DD155A5C36BA8821B4BBEEC7684913B7F85DA48C3FE6213CFDAD12F684D0E26E8D4B344259374668984B6212D4BEDF4A2CD87A33BDD653F37D1BBA0BCE3ACFE40B7FE77A4E73BCEFEFDD3D984AA38992C995D2A542F25A3832953C40EE304EE2C85863514A61047D0F4D650FE3537A97943506346E2173080D958D0C64B860C6082A4A6DE0F57D90087A206F2282C2BB7468E838A981E740C627744CC006A99E948612973ACEBC4BF7F545AAD7B3301A044A454819894B68B50D3AA8448C0AF67F9FA090B600522054A7FF52E0BB344CD2051173BA9100348913D09843CB7A93FB50E5628D66AF59A2D9FE1164B201E808400B592DD0313377D1C7C55B43536B0E86D25D234191A6697E4CCCA04DFC57C8940CE896C81F1D216E8DA0342B2F86EDA091AC4E3E34A710894CD31A1AE6275D442EFA1940E8593AF313D292F4C28DC573183BFAFE9F122792F4DD5BE409FAE6ADF613A42A05E14B084805BB8738CBDFE90313A1B5FC9784AEAFAF2F38848641CC7702BC91DFCE01FB6E71CEE951DA7DEBD132249A69C1F06FB57C42C74A871692080002ADDDCF6F2563A8C83A28C0BB168441467D7D9DF95C6719DF4A96433AA2CF974AF9306CA221EF722B4C5ECAEFA0A394F4976164A7B5E13091111C0A400821F956BA8ADF41AA2057CC1FE140A0DBC43364F6102AF1890D660C0B8E045AC52E528B64FD9078860EFA82C275EBB5B070C6CA24470B37AD5AF0491F02DDC7838026AEA87C4A29B291804989A1610E81C38B474B15958785A35604A006357E86F60988E40E9236375517221BACECEF1CF799700CF83B43278D098275BCF291A0D4D24A36B9E949220ED802D0186974E8D1ADC07D68EC5AB20D9D14829763D454C75DD25AB2B20FE146C94D277AF1096F2FF08061354BBF2CD9416DA740725C677F504A68D0368C45A5445FCBD15C5A190882FB68FB1C0BF471615424230E7B84B7ED5712D23928A65059456F00139583B640F1F668D1C898C444BB8E2222A05B0676D6E92E5BAB546DA0AC3CDC0FB352075465B469CA246F9171B146B0955867178C1CBE4506847FDAA04864202A63409B5882363CAD32A9B06462044022E58D88EC52D2DE72B42778BBDFB76A3DE52023C7D17961E01AFA82669795ACBC1686EA421639E2E90BC05B8F746663B3D9DC419FD06DF304E472B9F7CB64E710E07B731C2686B53E1BD4E0D03DCD290C787C72F459079D208FD99A513F0752937EBAB3C6B6C1E6465203C739F5932C52C31F155E9D03090823FD2A061D50F3DF4290344366BC8394CD538647664D82B95C21AD015F063ACABE690DA3F4E54BD0DA5F463CAD5B66611435271904DBEF0B96ACBC2FB1664F747434D292A7856ADEF464AA03D0D13207E9891C97CEB60BD0CF355233175F160B179F13D75D166BE1B18B134F91C9260C1B19C83A8B9151E1C59127AEBC9F1526468BCABDB64C711E6D1016C183A447602E6321A2D013FC3BD4F9A387A02A1E122C994CF4E8F01BCA2E8581192146C5525A2ED675A92647441BAD14334999429ACAFBD0D9577FA607D077DC7D3F4B812A51AF2B53B45F16F31623CE2E0FD85D2A0C7DFAEADCF8D0B232E19875142AEA71A03406442E8FE26F0005F44BE931B5C12E9B9F3F8E7E1D12BD70F40D668C5F6CD78D8F7A86318562814C1960C668CDF86896821923908170B0BBDD6FBFBC9172EF7BBB86D36341070672DAF5F6CBCD54DBBEB79B290716E0461988C2CAD1D70DB3199811EC0F2F159ECDECDCCFB71695EFEA0B7035490736BA3A259E724653C8FFF313C56C14BD2F8F2B15B47C2C971BE346B31C5874562EA693314EFB25CECA38332F8D1EF49E82CCD51FF48F66CD3E29BF8A4346E7EE20CB00B5CAD8D641AA3EA4B5D52A4DBFBFCF4FD48C5E65DC036EC1935993F71EFB4AF67B6C9BE0CA84791E7900656DC1EC436C41D2817CF3BBB01FF73607BCBDF306DAC5194C1CCC18509799DF63F736B7444A600EF14A58F8F37C3F7F778F7FA0BD8CA7F8583F1F0737F33B10E3DD2FCD6EB6E9C83BC6914EF39BACE910ABD2461AF493910652A18B21A362E32672764CE434EA317E098D53C691BC77D901A8DA2716EE702A264E341085A3B2AB8C84DFD9FE9B79187FD72F0CCE9F70EF80C244E50722048963B25DC2CFE66F6C835B8DCFEF318E990FB1AD13153BB4CD809BB8300E4D68A9306DE198CD7D166B06B98B518BED1AE398035700ED89ED3B4005FE803F52FE2E0BC02DA2965188DF31B33ACE8C2674EEBF5B35BF8C8869859CC94DE984D104E3CDD68E1E8573DE25A7DD78AF90085526A870E1C1F9CED24B0FB676DCF8D1FC4889CB990955BBED920AF3A6A6F437CCC2D6AF9A332779CE23C92BF6F4716E07D6D143419D28DA7A7CE049B485AE5C9B7B3EF065BCD3EAE182E310199AA9D60A1F0A11E19A0DFDD41A6A03682CE0F1A3B7B100D7D1239AED89BE323F9FC9A7F0A97E7433DEF09C1314F62E7FE73CAC66BD1F361837A32BBECB3F83C4E3FD5C58A8CF09A71C2367F55341E42B511189D007C2DAF02F0DB00FA30F483E17FC501F67EB137E950D26D41F14FE6B7E59186EAEE376794B61787C3FA801A43F16680E6EA94DF687230F8677FFA221FD7D7F38906E4755FEE0FC1C9AF2EF09B5FBA9661B9DBE2B52B278631B2CADC6BF0BEED2AB5D9DEECF39FD7E96BFC6DFE95D9DE5531977AF8430368789E24D4976793223337E0385C0573997A9C320220EB8B6F443EEF16C66F85A21DC5BDE7605C0CB87034C54DB8724EE127E99D9C7218E3B852EFB65C476185EC2CCDA2030DBD211D9E40FC23F959930D995C9FEC85ABF9F9FC13F307D23F8643F9F9C6EFC22EC0FFB3D8196E748BCA36071D2E2F41B4BB3EC5B3AF249C9C8DAFC24DBEC6FF1DB13DC1DCE761AEFF4BF2EDC9BAF6E66E6C12A89392A520289554B462FDD16D2978CFF242E25D9634027A4DA9FD8EECFA18920E587DAA525894F4C6F067FD048ED0CF481D571BD4A603F8CF8676E86EFAF02B1EF0767ECAFDDD2A91A228C49BCC9CF9B78A37F8E3FF2849F3146AAFCF06737486BEA20341D531DB98ABBE7B3C6E9C0C687FC8F548EF104FCA185BDEC2DC87283DD3C6757393027493C24BE4CA26F36CEF6376DC76CA4DCD97ED8463AC0334DDA9C04B1C03EB77F7EF7CBC8DC6C36D8996D34AEE3EFAA34FBDB19C5DA446C3FAD2EE3F3C0E6EE4AC2770F1CFC3A52D21FB695F10CFA8F563A309BF15E484D6BCB9C93FC6CE3776F3687FB38E1D5ECB0BBA30B69B213E4D6AC7A191C92E6C322DA58FDB06A5F5839C7FE1DAF456A09A3AFA2B6ED7D1C76045B7204C3EDD8D872C395D7E135EA25477ECEA10506FB697B67D6434CEAC28C858BFEEDBF787BE6FFD3FEFDC2CF17FE35A7D4519FB3D5F1F9C226C7C7B9EFE45EC95DC014335773E3724F393A1D0F32AFE43C91F35ECE9F723ECC4977700BF1855D0B0E3AF63ABA17B439540BBFCDF92FC78F72E3B35F5FE0CAFC6DF6F29CD49CCC1C438EF0E9C296ECCDACFF9A3F525DC7FADD54B0E346FB829AD0A350EF19BA7737B485D209BD48D8357EFCDEE4AAF55ABFBAC174297B9674886BAE5B70AD1FDCCCE32C37960738086F3F54C3E84012B298E96C1161E520118A1CE1363D094F30866B3E77A84BAD76C5B8438B4919E5EEAE8C752A5FA6E2D0CFB73CD7C084CA3A953DB171C4DD8E9EF17ED8FA42CF82BEB102E2864BAD7E0E7DDCE4FAAD5B58F403FFAE050140EA0F9A7DD97EE1F6028043F6170C4F0D8751AE1AE054CA948A70EC0E2ACE783BCC95091B166419BA64074F660D2BAE7AA0C4EF5E206C5A6080C8B2F07A40CE70AA49428576AB0A8378164DB584DA8FC1FE69B67160C1CF66065A8ECE9FDAA208A61FB2468A4FB41D98EE7A2D2DD24228E011858E755E4B33DB32833E0E921EF4CD944A816A80D10EEC6792C5047B427EC10B2FBC20BE658F41BFC07CCE65C715902EF46A83BE3237750CFDD7E20974E54A649C532C11CA4EEAB04D1D7462CD543395D49C0EF7E60087BE10842FE71223D2CBB90EE2F3A997FED4CED8D4D83EAE6540C3D7907881C1AE190F0AF9397DE13168AB0DE382C14E2C30A09CACDF8732BADD1F5F6B21A38F7A68C5D86222718C883B4AEB525E65B464243A8EBA6623863C631D523231FE0F7CE1D8F8C56F73C60C17F185DCF70882FD3E6DC9CADB5004C00E9DCA09A79FE8E0FBDE6430B94F3A43D79331D385378086B9DE287456D9D27DED80C48BFC7600956DFDA80A73E8A6BE7065A0EF89EAC0F7C7C953E5B4385D7911071136CB3A16FD6460EA6765C2B54CF423B2BEA9CFAAD2C16478EA33F9F90369080AC184122075B7CB636E233E10B8F7D385D2A7701A4F410A1CB3814AC0B836B30B03A482F273FE0DBB920ED424FBB9B8B894D4D40E72D40F9D63B07338F47F980C2B670FE35D0AF93023E5328A3C86CBCAEB920FC386971F02CB1A2DC81963DE5934479135DB2B4767443F8D733C5CF7F87FB7D42D79FDD16C6EC47CBB33233CFFC891F8EBEEBFFCFAE1B13CF79DDE6B287121D58C7CAF5DDBAB64D4AFDA159192666E547610A1CB429F4C7AB507212772B4A393A81C0693E359395FAF38734690E7621AFC901C677246F19CAFB31A93EE28F0D7E5AFCBB372B249C5EBF29F9BDE8BD7AEB9F2A747EC3E76FF3B7FD8DE507B88BFF2EA1B59073E1A3928B2DFFD33B5F8B423D2F17BF786AFEBA9F65F41DE88D8BF6EF9F647F58A2CC8F1807FF8CF7A489E95DB85292043044A0E4C960A603F80DE614C95BA403EFA83ACA9C3B0BDF121363DFA8F2F31D7BF4A78EC2FD4F5577442648C5A9FFA4F0512553A4E2A194EF86DB65B7C8ED18F1E4AC595598E3FE253280EE2D3387E6EFC204EBFFA8B5F3CFC83BFAEFBDDC41F30C7D3073FFBF2A3C78A4E853ED63A4E7CE5D899BAFE7F2F7FFED889AF6B0F7D1823F10B130FC953E943066546166A5BFE2847FC65D9B1B4D799511C9EEA990AC67BCA218357ED413C17531DC295B2430C37F99FEB3FD77FAEFF5CFFDF5CD8FDCB081766C4B08C8CA976863B03FE304CE3A49D514E0DB6E9871AE3ACA500471BAD2579D06F9C825368E0526018891090D011AF716AE2E1A981A7660A463305ECBC4F8B20E0265368107CFED207AB36E5431F0D780022BF4896BFC48D9E31B222E8D710F43237E0712FD92DB5F397EC2E424F379A6F4470F9521BEE4E59BEB412E94F7A20020086F843E42506A0A591E6293418E0CD7F70CD862553F3DD454518B6BB08F0EF46ED254B10DE9692A2A2921689FE12C497F45C228D57A071691ACC736AA6F897C964123F25CBB62F2B81FE25E88279458FAF95E08A36553DB8B448A227C1216A53F88AAA1E9C6EA379F94BF2A5F58A46493358D1343C7A641053CFB5A01F68101900FF7C092DC1B99158819E1EF1A387F52E21A5F56F4768B6C3F2995512DCD43589CDB0B490081E6314F925809F24F32D1624C7192449CE00F14137EAC798921624A7182331351F752B18585F4B49490912B7DD6864001E6628804192B6DBE98C29BB32C600FC9655706148A0123CE02B2961A6DA2D9200103ED5145D6447CC1246D182F89D9E5F320D5F5242D3887E09A0A3D19336D22553E3881F6C37AC7F375ABF5D5ABF46BAD0FA63A4F5C7D3D2C2F38B5E3B74E8B5A2FCFF0B5E9D65D3]]>
      </FileEmbedded>
    </File>
    <File Name="GameFile" Comment="Imported from Ghosts &apos;n&apos; Goblins (1986)(Elite Systems).z80">
      <FileEmbedded>
<![CDATA[789C9CBB095C13D7DA3FFE4C261B10B2B860402413B136D5A0910A8D14434001ED025689B8A0E052F70A6A2D28908C62A5B7B5DADADADD6ADBF7EDEDD57BC5B6B7575B5B33981AA169AADC166A6A5342ADD84AA9A18AA2C2CCEF3903767997DFEFF3FF27933367E66CCFF7D9CE73664E2012A0D96D855B25199399936E054CCE7D71B2F4AEB4A2A6EF01A8CE4E2374779D3FB5EB75DBB077BABA2E5EE436DF387FF1F4EBF4C58BA70DA01178007D571B96B34E054B8715AD5C45577F792B97A177090207FA31EC1BF603927728FB503B9589C918F6C0E333DEC8CC2CD08BEDE91FBE9FD6F8F443DE07DF3BF6EE07BAD4350F2C0129E087A24024200A949FBF99AC1DE9D40EEFDD6108E3CD7B86E98E1E653B3B15A034F448ECCF601F0218042CFA0C135767A71C324258CF5EA6025226F4905BFCA11025B054B39D60D2DC68BB82088628B89EB72E5E64ABBAAE9CDA65A04F5DDCF5A40D6C360475A30BCB215DC15121C52EB6EA467FF92E3661005467672C5815422F0EF0E49E95431F7A4879E0C0EE31770C1AB2EDDFCFC3D4FF42FF8EB77FB52CE32D865B4F6484291E127513F47FE9A73FA387823FD0DF45E86721015BF62308EF20082E0B0A3C9561B98623180E700483A14B144CA4820DCF3A759DAB1810CCF5D3B2E5B07CC96DC1BC6E53B05D7F12CC69433F060362107A68A107FBDE7971EE88971F6A38F0DE7313EE881FB22D6F39D8073048098608B041ECC717C7316B056698703623AC1160A4AE49BB53446129E608D6DF500898082C6CC45B773304C5E22F3095D4B11462C2D1B8CB220A8728097DCF1B024A825570BDA0B8CE563D74E5D43EE4F4F55D5CA9BE9466417F8B48C28092B84124517D5B12BB5EEF47A12128703CEC5AF2E4E3D387CA50126FEE36FD274A22EB7976AA822328FEA2524DC7D1942070C39FF28E2CC915CA0CC28F196183C08D9C3041D72F0C26832528D4B761EC1B2EC238C0DE86F17D82084394443C40492147587400D38C2DE73DBCA6C7D5E3AA3F55CB1938A1864FA04FD59E42F5209DEAC394706AD7BE90821540217015D4F98B3C4A42381DAE844A1B62145052C23E1ECBC38A539CAB4BB828ECBB72F1D469419F210848DC08B11B2AF2F169CDF14F7BEF7B63F0C1F766FE6B4DD612E9364D48C4F7B9884F01547148F7C4B789FBB385FD06A127239C21704CA6511281846A083A06AD430606823303213E375484D88CC2CE2060ECCB79024910422150F496F2EB2E924628290057FD958B82A1D7D52BB45DAC6533DA8453028AA176173620BC47315DBF785AD3A3E05C9CC22D8AA90FCBDDB5BD1B6043091A8CAB4B6CAFE00422C68C1BA43DAAE72E7E00E2DD806090245AF7926A47830846323EAC53FEBCB8245B2841816484538490946546115D33106A4B8E5B0990DFD0BC3B1CF98C02E300D59DA0B9F80B2952103551B97E158AF711F078014297C86F578FD07511F97D43B8D88AF2407E83680EFA2B6D1DA776D5F42A584308E5B5092DE7BB0494573D6FD3DB5C0826E30D94F7AE9B0AD67506E5653823BCC513799DEAD31B048160517EBE8DB82AB96EB8EA897E30D261619DFEEC56FB14C12E82B94F081185EC677B55854828B9F14637715344248A065614895866300898FE2A08E34AC2A4DA2DD17F558DFFEA56E8E229B67AC07F9DDA751C44A734E0BFAA141C1D4271DCF65F6ED6463A43048ECC996F386405126ECC7EC95676CC7E47A623F28DACAD5B0FF4233010AB57813D7190363159ABDC21A281BB378D78B58113D18CEFD1312F4BEC51221A80C731B1FDEE787B7A443522849E9F1F1A108AE68888A73D246215938BC2957DAD3DA4C3FEC292F55B42B725AA7CC4254086581835FFBB02606C0244174015B99170E0C0936EA0BF3E0AB7782911A8DD1229447120FC279AAEE0EAD5C258A3E6A953E96158C9544C0B8314611FF260BD5E744ED7855E0BEAF3654EC15EA4590ACA2A20FE4D4D690554A25D53B7FA845B47ED4073653D03649655A2D55B943C64385C40F302BA3716A4E11D159D9D914059D24BD261A8E0983D180B843680CD5A493A29E120A1070CB32638A40A52728260D27284479AD34709D637CF91D9432DFA591EBD3E91DBD019781535FDBB0A609CAE5EEA637085480B83C3A12F063A940EDD554A17B288B50F750D462FFA8B8897D7C2909861B5DB9D2BA86E66C600DE4297E8CE84D317855E745FADAD6532CF722A24E2958EA4B657C1232538F28D5E974BC45B41F02EC53665785B3188CEA0150E472FCDBB45BCF2AE1D5611EF97B62919B4ADCF5170E700DEE61974029921A81A9A0ED3F9B352662B7F075C2CCAF6F4C7989D5C7690270A214F77A26AA0DBC8F81186CE8EAA2CBE0A0CAFE90525B8882F11845EF4547764889678C339A41F6DA4508E68FB20A31FAD8255D4789F2BA1AFFF0088363E0212C6B3A26D5F2D15C1EED3842517DA299C962C15205F0AF22A28278EB26F895BE841B021AB18122888B2297379A77EB8C35158F34B3F2039AF16A1D247335E9A7636CDE6982342F5001C384C458A505FD2EBD169CFBC305B4BFF06355E840AE944803FCDE245EB1E8DFEEC3A4175155CBD518B8B7BC0D83B94A72BC0D50738B74DA4358230D720420DC70F21247E6897A1DA13FE2054814085A135577783E4CB5304AA764B8FEBC57EA8579E2050A917D132052F8E035A2B483EC59041F42914FF53476B98233A239A10D105FD949E5EEE94C3E19872F9365295A8AA0AEE0A7B9D6B9DE098913B00470851528254C29DE0B87AC1915BC02041BC4B445A44269271A824962A4C14E1834ED1259D865B977F398EB4F780C047159F0E43261FC9536570996715483DFAED3134916B2F5CF962C82C04EB86C8E3BB58225797D047C04AD8F1EC55FE3B45F43E02D6708376D51139096DAD977B18A0DFAAED01E7170358E95D42FD796EC459E268F8E21ED4514568CD6F58B599E1645088582FF763DDAC16B1AAE07E36832BEC72CCA8FD4D74D43B04AB5CCC163B1467ED6855175D5E72BD81248D00523B5AA712945FC97F14E7598DE0123C4491D1A3F446E5E57260E765BCA4049A33302C0E3D81ADD2B7163F5E83CCB8FE83FEA110207299B30695F8E66DB014E4B2CE7C41A1E82660753D82EB45116C5F465F4509D08A8B3DE03A455C1082858A871C9F5B238F12B02DD7EB08D892A53D24B8B4668647EB0D4311E8803DCA96C945A07A7D0518F45F0B8E45BF9BA3648E0814F5472F380ACFB0288C675C9F917B6834AA4A34532DA8567A8B883835E8594EF0405DA840271B55892180BD57224843D0B190C5C0DD80F2630EE56F7D0B75FBF2D5B287C2207181E4F8168EB0C425DC1011BE290F256CC6E095821961187445701D82E1A253EA7D88274EC7D3D103A5E8F2E422469871709FBC384C306674962246598838D9289855763E9F8E9EE470D40C6094AAFA7DECDD744698A6BFAE7664FD8E516522780C347EB284E6E2106A03061D97481191B0041DAEFABE741C74043FB1EAEFA24732087DB5E8DA5B3F868D55FDD349854C88E0A0E76BE25EC9D467A958B0F5AD2D3DA0B9968EB29217836CE1168CA0892CD16169897B6535557792E964C66188DD20B8B6C3708BA89A5704D1BD76F580FC30DE008B0BD370AA6D512B8E848E5F6815917E2E227DA62CB4B864A3CBE188BA2DCD81D9C454E2EA295954D8EDD8F63B52AB8520B594E067D1D7829049EEAD7E842390A83AE2234AC485D430A16F2BA1049D412FD88B28325FAF213662227568876311E6970B6F791E18C6527F57087D0E2C1C8E81BF1E270248699E81A2EFCD66FBAEC6ABE60024E49E32F4A1079090AED1265D735075AEE6FFF4D61C4A492FEF818C53DF76BB0447094D3C3A3AF9ABC81C4915F6C8881399D077FAA410241D93586FA148A06A8A385349E3497D01635F076BE01E42EB48D94A7892890269FF9948A26F36FC7002D58A16A14A24C47D33623841DC00522E864A1E8445A70AFFD846562461D0A00EEFA62EFD9DE8367E06231988390BB32EA1DE3398E240A938C51FC06EA44831699BD25D82967163C294A361BB0CBBC4503E833F28C6670ABA1AD94135A5C156142545E2888BF1BF4E102EA3CF234D8B0937A4860A543371A6176E9D62854BFBB1E35B342D9B4D38029A2A91EF73489644131FB15DF58D6CE2798794484E2AE3529096761F06B102FF11AC21A2DEB2953451E14A11E67D4BBC94A68780BBF90EE9EF2C31E7D44C8792B000430E9C6FEC54772150628C55414A47381C5BC96C2CD45FFC54410C628BD08C1690099653E827F47A47377254F1C3D2622E04728C8212A69C166EA01A204572FD886AC28E4FD7465A5FADD55261C2B7F88B8CD03707325E228D45CC70FAB4A87404F345CF1344C47A70EAF5230A44AE2B2E93222D7A6E517DB16BBA9635F6CC56120D8E65A211D9B5732CBAF4BE0258310D1BD82504B1A864D46EA21C1AD12F7497911B1C7E3EE79AC71CC2BE0DE86EEE75A1F2D03771A5D6A28C22E12D6085930E07D1AEA6CBF5177546BC858B2BA204298094910EBEEE4696689A26DC6DFF1468F43E091BBEB05E46354092E49CBF8F30441732D9951C21C425582F875C970E832644DAB6129B807D2FB16848A45821B8BBF6091F712A0BAE4C38BFC81090971379D225344E15FC31D4D71CBBD6F9959620968AC884004B1EA17C0CE904955D4A7AEA5767D27BA4E12AA973139D06D0847BCD0EC2CB7B303458799DA517D26864D85132C076D2307AA3A85DE59F5C6C9FDA8C70355F5D441D40254DD793E253DDC80CC3D447A7666E03DA0960737D517519752081F41C4DC42FCF06466B2797383F5DF7BAFA66004D4242385D42CC33F7340B5A524AF3B7FA5A8566BB9AC10917A2454E80DCDA8F9512A50B3027CBAE4C992362CDE408A6F25B2C31D0024825BC619484A6B8F06DAB07431BB17D51BA72A2532FE99B1D848B04EDF5CB2C0468E10061047A36FBDD44EB466C1415EBA11B37AEEC7919FBD7C49FE70F113AE78038BB35233326EB62756BB51328030BB68C9D9B5A51FC869748E9900F50F4B2C9C4AF0AC28D53A73250B0C063AFB1C5A267B9FB6556349E781232DE1276A164E52540F5E8878AAC009A701A0D157DCD1CE8972EB56324231D3A8321885342715894769DD8E3CDBF130921C030412C6F00F628BD50F402DF9384F862F20883B824C2C9F1827BCB29C4CBD0423309B36A7071CF92A96C683746606038D9DD7B5DD841F0665C141610375A431A57B7204555538BB13B86CE29039B66E73A775F2168CE13A73494C85EE625415BBF78BB724F0B41B4FF0CD2F383C433C0D0CF015A066C6DB520D40A0EBB1CA727173DD42E42A6C43416693855042E5C13CC0699D40812943F818C068C1526AF2590D00B5B88DFC6788F1E050122B55A7116FE91889E6863C922878370B25CB851BFCFC04AD4C8A783646090C40383D3D9C6EE39C88C8C87EAFBAEF211A8141AC3A97D44FEB82895972C7211D1DFD031526AC67EDAA5870CC56B65027F8055101E976CBC86BC90ADC3EE1AC505A9C09FAA212E184DB7A464C90271C68918C68A0F1989A7C9E8133CE883695602FB4A366E219493A2F635642E42077CF23F74209195B062384C8498D04B50A2EFD592BA5A248F05D1E0ED44A4F4E510647576C6E64A72727214F2ACFCDCFCCECE98DCAC1C72D9D939FC4F19396686C8158ACC4C9C5AC8855C9E9D9D4D4E0A12A4E1FD4C72215128146249B65C2EA7698522176F90C24CCC63A1047FA4B52C9B14E7E6E692992A93263DE04F42FACD965134762A2705A43BB19504F128B291A94A522F5386F57EBB8BC6A1909021640AD91F2ACBC87D7164990C6FD1F893C90861321916450C1025914AB188A214F281222C538863D02241124A3E80B4BF041B51034504A9BCBF8480BCF34E85829252D24CD2A754A2107924162271144565664AA504B0024B096A7130BC8F98324901E1149957C97DD2369334C924B95C725FACDF3F3E7620A53229D249AE424286112920A3E0C012895431502491C849999CB084A2085B64528948546E3F9F14D8275E2A09C552B1763F2112514EB27E562AA5FD1DA130491979A6D80314060EB83A6F00A905A467605218E634C04B2BE0D91DF06E2F4CE9850D3DB0EE1A945C83796AB8378C4B54C058C35601D635903E1A126CF03FF6131B0673034C5B03737740492FDC5F05195510DF436AD268973DA0380A8A32A0CDA08A07CD7050EC226B1C1A03DD77408AF1317625202D782484411D823F5D24244C4F4878282161AE5006F1E2A1B740BC1512306EBD0BC8532B0146A6A424CA88ED50188313CF40CE683E71906EC7C0095E2B1197B4BC80E4C0F80500FF2A3A56E42BCA5BF059916541EE820717E440FE02F24DDA5D448C5009FF8A03D8B600E660FF464F7881E7CB850CC34C5BC96C5852BAFEE10DC2CCFCBCCC07A6E2AD09C9132C168B30257BCAF40718723D61C224729D39634AFE83E2B5C58AD70F66E6E6CEED2FB7A490EBFCBC3C343D1933C1928C978225695641E6CC022637F3C16C6166D2CCECA9D939D3F3B299FBB3E7CE12EE4B9A95FD40F69402E6BEFCB9B30AA64FB95F9890840559F99933A70AC9987D70C6AC82FC3CE1EEA4E97905D9337332A76433D3A70B038D32F3A632336666CF9AC5649352E13EC78333849CE933B385A9F9857982638630737AEEB402E181EC9C0261D60C6C8CBAC9CC7464915376DE5481D0C4E4CFC6A69429613223510F5B67D6F6361A310A84B9EB12AB8E32378DCC9C544562153F9FE9F10C5D84F3C560A53F81557A4B4A2D92D10F69BB1A2F8C69758F1DD9EAAE4E62FAFEC948DBDAD21BD394457D3E6AADE902A6878C234762695B63FFB9CF985674CBFFEA02DDF922A369BAFF8305FE8605BCA5815F6F72F0AB985FB1C4289D2E97FA8F2C48DBEC4E37C25CFFCE05E34A48C2616264E651B204FFB362AB685354CB049EB65C49DEECD63719615A2A209D73989E51BF111C5E4086CA5B101C338695CB8DF4F4C1483BB63D49F17C67C5F8760313E1036B772050AFFF29BFBA3DE4559522ED3C63BDCCA75925EDC501E4C471535B8E592A63AE279507FC7A365806C1C4E03A4C48FD29A516699557B9BC5EFB9F3898F113B75CE93CC20C4F65CCDAEB365A9F74A199522AE38E270E6624DA9EA63639347A2DE566A7F60656D57D53E4BFB0D0465B14B880EF3C6CA3BAFD4656E48FF189E9BA6D0B905463933B15CCE6AEC926652AF598FF4E567F3395364ECD8CC954CBE4AA059B911EB37988F67AA5D78ED2985E1ACDFCA45B431ACAE54123CCC78350722B55F0EF2A9157A96FF867116B792C6DA73BFF24F6E61FC562F648BDE927DF7293D4B788699B1603060B25C39FD46091C45C2589CA60B1666E6AA966A46A463F7832131DAC3E621A151C1B4C05461F3BD9941B74423A13B58967E42E66BCBA5A3F56640F0EA97FB6626B6E4B26FFAB45C5675887B44CB34AE5997A95DCC5F75AE432BE07473A894890AA7ACFFA62DD974548302587CEC3838D3D02852BAAC3C823B9F4A4312CC45E405E3559E38C3784E6D80EA31662E5DAB8BCF24D8312076BAF37D56BCF35D63756F0D5D6F8D17399C871DB6CB275E6C9CCADC61627231FB70B25111EF792BEC738754E4B668BCA1AD55DEDB5975AA8515DFA2EAFAAF6F1D2758D2775C82E4D26B2AEBE71ED325D9DCDF37E89111639C7A3BC12477D46B377E8AF90EB16CB78BC6EB843DF0D59CBE665A125C5C37DBE7DBEFDBE377CE7240F02F935BB3148CE7C6C4F7271DE0EF0E42DF63CB0CCF3E172CFFAC59EA54B3D92259E84259E918B3DFF5A34E6E1550F573FFCDCC32F3E1CB5ECE4C3D9CB7E5E7A1CBF431E3EB2346AA965E9DD4B3396462EAD5FD2B964DAD2FCA5DF2FF97EC998A53397CE98393D6F0AB1F85999B3B3A70A598E02A6307FE6AC6C666A665E6EF64C66FA2C26735A76E654A3800E2393F888990FE63B663259F9798E590CFA2786F834C70305D31FCC2CC8C65EA6CC9C9E331DBD8A5841B87BA002F1005AC63F6A8511E65093128857309BE5E2D90830F21D775FEA3D2AE3F24C5DFE2264D9B837895DA96569C35B7DE5A66169FF74FB724D7A39BD22610F29359352BD721C2597919C911A12230C65FAC6567DC05CF368D8665D6AB55145583F78DC9D62BA444C9F12530FA64DC6C839A97233CAD358E996AFA82B47326CCAE417DD362AF903B76D70F201B74D95FC5737DEBBE86EBC52973CBC35F98C3BF94377F269F7F2D29167DD23BF74A7277FE54EFEDA9DDCEC1EF9BE7BE43EF7C87FB8D3DE73FB4A992123B7BA8D7F753BF96846922AE7650C35D1B7DDF89EDBD93EB6DC664DFEC26DA4234736B9FDCA47FC3397F94FACF58F5BED7F608D5F58E69FB1DABF74A9FF8165FE0DABFD1F2EF74B9618D7BB9D7F2F371F2A37A71E303BFF512E1A7363DA5964C7678A55DDC6419B74D0403994FEE94BBA7CF99C276B95F1C466BF75894DAA633F5D3C8E44CA733B0F4F66AE1A2F61CD4F29974A1F61EC76EAE01B8A559D3C79B279DA49FF4FAB12A0FEA4FFF9E509306448FDC0355EB62D2818523FA5F3F0E251E360208B39BF7C3526BB56DD71C7EFF971D0E4BB9FDB5C3064C81DCDFEA34B46350D1D07FF3D13C8EDF61F5FD915684456F876A21AC86536C571862A3333374611EFDA653CEB4E8D2018109F17D17B2A9719C7AFD3854254F867FFB6478C1998FF11237992C73EBE6824AC422E22B78465FD8D1256F9ED4BB029B24F7FCEDFB9CC3F6DA9276595F1F335FEF847B09207F98C9D6263BED12641E9E9AF78EC4BEA92BF77635D232ADB35EC121BA4FDD55DEB1D5E3A7A91D3BCAC5407DFD5E50E8A77F2E3983BD4B2CEC37583060F1AEC1C649325E2394FC57CEF1C24D64F19A8FF13BA10FC38F174BBAA44FFE54CEDF0C51951C23C66FCBC586351EC5DF38CD959C62945B19945B1538A0667CD5B679CB78E2E7AF6AEACE999394F19739EBA23E7299390357D7AD6F40959EB1ECA5A37D4BACE50B45253B4445BB45297B56ECDC4C96513276FC8323E56145B2514AD1BBB78ED1D33D71A673E8DDD188B9E35CE331A842C637196D1357168E9C4A1AEA2B87945B15BA6C52EB82F76C9B4D8EAFB32974FCB9C549469BD2FB3705A66CDB4CCE1F7652AEFCB1C9B3769799EAEBA28736BDEA41A619CC46CBE2F6766FA98A2CC717993EEBE2FF36E61E2E4C48993EF2DBA6B7AD19D0F1665DE31EFAEDC7977650B396906619C74DEBCFDC9E3B681E9CCE28955F74EFCE77DD6C088A2C094A2270615958CB3AE5866DD32C2BA25D3DA5468ED9A226435ADCE6ADA93F5B7BF64FD6D63D696D5595BAAB3B6ECC99ABB316BEE5F722E6DCA39519DF34A75CEFA4D4533D6E5ACDF5BB4E9E59C575ECE39B137E7D23EEBD10C6BC37DF37C95F34A1EC73165F37A12C64929534FE23829BDB4C784F9F49EC998CFEBC9C252D38FB979DEF179DEFBF35EC8CF3B747FDEA1FC7987538A5EB85FC8F9696CCEA5F1827FDE0A8F6DA59C45EF84D3DBF1E046083E4AE16C9C38CABF669936DC38AAAA5DC1557B99D2B3552DCAE58DC6A7AB75CCB75402ED1FB95CC79D1BC894DCCEC040C6C87CAB63037ECF3223774E17123325E774F66F4806CEE9F67F83D54E56B364BEB87072ACFFF59583EBB5D7DBEAA3994B8D14E8E3CA079BC90F5DE3D5469DDF8553983FB86C25B1D9185A3FCDF8CF0DC492E3687FEE72A3E4515DC1EDFC8C4775EF90BCFE8ECA406EC037E964C5E3032338078D1DACBD59DF7692A82466A2991FEA1B914E1B7D5279D267ACDBA2EDCB0F54048A17970EE93C5CDC518F0D2F245D38E94B48D2DEC256036772C33C70839CA399AFEB951D9399638D6A959C1E186C6C3C0E161FAFBD31A20D078B273F4CE213A3996F1BD33E7017D6D6D616D7D6D678B5C947DCDDF819CD95EA9EF0F8FFB672747D17E64E90DC0992AB27390FC9719843FBE2550DC6C8A99492267348E41C4A2359872C5A376E8C78EA2A8E3961544D0DE01A28E019CAD65D38495C7A7D1B8A319AE96A84F9D3E6AFDFF0DD635F6E1CFAD881F2B48AAD159F55C0FC67F06E62F9BCC75E7EECD7F2C5E53B3722A775FCA3C8ECFE23689CB6429C80186DD0387185EEF547FB45418AD6427019A583CFFDBB9707D74A82CBE80B3A965C1831DDB5AA4D074D628934B84C764147F94909A6BB56F5A76D3AB6BF5C1E5CA6D06DF15F20E55BC4F23FA4D8CBBFC55ACAE0B2081D9C11F391C165513AF84ACCAB82CBA275E860495E1D5CA6D1418B98D70697E9747056CC0F0A2E1BAC838088E3F3DDA8C2F0B96ECB69FFA19548898EFD8264E08C8E3DE33F86997FEBD87F8B99261DFB25C9B04D3A1033F0958EFD4ACC34EBD86631D3A2635BC4CCD9DBFD7F7A6C65A353AE34F874DA5B9B063506E452BDB65A8975024A2F5BFACB96E2805C15A8F64A4B9DDDA8F4E6784C929292E2FFA77CB557594ACEF1494924EDF2EF5B39482C8D27ED03DAA38D64E21BB4C1F8FD7AFFFDABA8AC0D3A4783F1E67A7D92F195F5BAFD3F50F9E4B6D185F91FA9F7D6EB638CDF5712AB79A5D2A6D24719DFDC84D5A98F36D994CD279BBBF371CAEB6A2BE8CEAFADDD529BDF25A74F2E182287E6CEC36D17B04CB9BAABAD5EFB735B13A9F8FC72AC2856E8F67B5675D56BBB45E5AFF6CA89C5A0A124696FB6C9E9810CDE30E381BFB6DF72E668E67463FEC9667FD3AAB6FA0BFE6757B5359AE33BF7C79B3BF79333F992F364E6A7C6DB4635F6C2804DB589B6448CE90771D80B841717EEF96DD8DBB91CC2BD32330E750EE5DD8A013F730B039B97DDB6D6E457DCD52DEA72B397292F4D4AE225681B9445A21B6E271626652431564F043B6B4A3EAEF81E983E3B7B9680615DF69F83B7B204D11A19EAC13F0671FDA14FA25192A95BBC9AC4685ADD0AF11CA75B2B9E93D35E747B2DB8BE30DAE7E81850C7C8135265E8471211CE55E3FE79547409E9576931F052EB7066BA181926CC91EBD580F69D14ABBDB129795AD1977CA3D13E8F9272A4980726D83F6E8B919DAB966F92CB8E5A24F2089BFC02B1FEB6D868E667FD315E653AD25FEB700C2D979386D5DEB8D2A1CC15FD3E1CD1F842152F3159DB69CE78791DC6EC5409AE12E46AA37CBED9D91E2A47E7E26CA7CACD66B3F6B239358C97A912E227F6FFE87F760D6981CA465A1CB1D18BEF48D8BF5A5DD27978DC7E7989E8237FCB4C66BE6F2C2DAD2B1D8FBFD3A5305F5306F30DEB0CEBC8BDD95530BFAEEC72594CD5E5B28C75F22A92CF2FDB5596BFEEF4BA5DF8D360BD6B58E7BFDE23B41F5DC38329D2185AC32BADB4F1EA1AA4BF6E503CD3EB7FE491669D22E4FFF591B6FEEC0FBF677FFC3DFB33C92E4C9C9D78A1E3B7288B5C77E8C2218CB33CDB1EE917B51C114F7DB091D4CC4BCC49EC683CD94C6911B45ADB56DD84863296D844F1EAC543C4BBC3C7968E926B7D6A9FDAACBD51AF6D6FDAFC7E43D01886606C875C5B97EF34F862F1204BBA726D70D4FFE56A74A73998A8F537068D3474606B9BF224258588CEC354AF1041D1381475033352F8E31D19444C66CE26B0484A1B0A527B121793ED19FFC239082B0623EAB5BF8C6313F62FA6EC5879718262F590667FC9DAB682210B7E3BF7B5F58DDB42EDC7F2718AC536AD522E5D200A316E9866509F0F12E4D2D5E275877398A69CDCE8ABF6E5F68D65A45EBAAF5424A24339996918F78C5CEB6CEF35185017AF93310BC4313D5FED1F1D46B6B6AB34A50BCDB38DE04E55AE45EB6C742B473EE646CB2D37B768CBCD173A08B7CF77F807B11BCCEBCDE56665B957A934C735A12A56F32B982F072A926A9DB32ADD89E2F9FCC0F9B981F32E7723FDF4BA8211D9DFBF59FED4C9ECB1059F1D88A95990BD43B7F5C08C779A1F7EDA7160ABFE8966DDBB05ABDE897BB279C83FA6AE1AA37FF2AAE36F534D07671C78D7F18FECB10715DDD7398D20845D82C01F132A85D907AB857FB83A3A9DEE2FABAF0B0785CA83C2D7D71DC2E5EF9E14AE0B7708AD1FD5B8EEEC9E7AE0C59B071D8EBD39EF8C210FA33B3BE52CC7D9394EDC7264B7DB3B3B651C2BBE1CB6C40135F19BA5C31F7E6FCDAB9DFFF2BFFA08FE36FDCB7FACF5EAD3EE73D537AE9C2BDDF7DEB947F6BEC72D7AFABD92453BDE232FADC55716F88B610132CE0195716EE9F098DD6B5E2D8DF9FCD565B3F1D7F2976339431ADDEE60DF950F4EEF7BEF23FFDEF73E687CFA3D77BDEA3D6C66115FA26DE929BEF48BF3AF853FF1BB4A3BF9BAE29FF8D6D28B5555AE502F18D41227BB412FA4D77D5DBAF9DCB7C2C20FBEECC8FBFAEB1B6BDCF32F3F567CDA094EF2FC1DE1B076CEFE872CD41DB874A9D0B1D17108CFC585DD1B8F1DBF747363F7C6E64B97DC871C8E42C7A54B87EABA9B17141E3B70FC5071F375C721E1E0F1E2C2E6EE43070F5C5AE068EE06EC89B5B3763B9094BC79FBF3F5014767A7427039C72D5BB674E9B9EBE7F873AD9FF47DD77AF7B2CFEFFE7C99B0F140357254B8E7C023C2E5CB9781E779B87DEEEC545DEE17849247A6D9C83647B720D4BD77E040DD51293DDE2297B078B61D964B8E1F55D1364B829C948FFF1FCBF14CAE2BE215751BAFB78EDFF8F5C2F11B9F2FB23F3CF18C73D2C57D62FF27940C211908D5B7CFA2F465B74F5419D065F6577E157EBD6EFF70A3706B83FD956BC24DCC3B48FEB5B7859B47EC471DC28D29F09A5CE851C087DDC28D25D05FE76F1B5DFDF52F89F9731BECBBAFD58979C7AC0DF641BF1E78B3CBAE0883A1173204C8E0D912053CF8113B6B35CC9AC93EF83E94C85997009BDE66371F14D33AB2D94B201B335D1CD9DB4A0E001779560C6413668816587299F15F0E450F799F6F10205ECEEA15103B9B4DFB4F9890C726FF03CA12C8AE2AD74D70F59234E32A797D29D108E2DE50EC9F64B49011AA11B81AA157E5124774F792FDD664F45E10C28CCB1A82EA30386EB0D20D1C18ED300A743D60BD0215CBD9A51A4ED1C311022A406385042B90BD5E21A0BAD849B7B8AA7576F2826E145037417F8BB52EE76C2AEEEE5EA079A0BF037A27287681427C57FCBF3CA04FD2C3E81F61F4CF207B0D067F0CF138480F6CB80A1FABE1DC77DCC5BD1CA761395ADC63D60BF71E02C75E38C8B32D8F70070CDCD7027740E05AD670F7ABD83B6FB0832FB24A1A14E781EC3FCB03780D282BD9AB40B65F738464428368D1B42831AB1A965F874B07D9AF86722C70CD0EFB4707B9E02C6EED5FD97BF2D9B87D2C32917EFFFFD11B0A5FA587D80720F96D7038E0C001B6D9C1BE13C93565733521EE9F31DCAA83EC46076B3B08F1C3417105E8B7FFAFB495410F5521A99036482DD23393C2731A5E5AF1EC8E777BA7F46EE85977ADE4DA3CF5BD61FAA8A1C256615D933E3AC1F6E7FAB16173C3B435737794F4DE5F955115DF033DC88E1EC55145196D56C56B86A32C44F0F277A44A7985F48CA44CC518B4C3B949E149E1BBAF4EFA79C4032342F47EC57E4599A24C6E5158151F8B2FBEFF505FCE446BD52BD43F2ACED2872533627B6CDF66ECBD5BC3C8C57D83FFA5DF74B1DF84B03A04FB35214D99BA2C1EBF7A4BBC95BC2251802D04AB439059A25852A2C82C918FE4147B38547FFA3A0B6E80720027076339B2AB6F320BEB5840CDDC10821251F74244A3D4E28ED9F1C84F0E5EE260FB7E78A544630B95CFE1DE8F86735BB8B662CFA20C0F65F81AF61D03C32D55ED63C33F86E12F812144DEC646904DAE1A1686B170270B0FB03005E041A0F781F47356EA65A50D9C741F47EFE2E87D2C7D9A8DBED31E13E6C65DE1C6AF6627BD5862B91E22909D00CD005B58F882835738A44321630DE7D98C1B606D150DD7F90438CEA253D15454685051C45D1683C0C0428A1D183BDCCDC1681606B3D006540F4B0C2683A55D7800F54F96BECCCACF816238C86FB172AC09FFEB4BAE3B1A606107EC8D660FF7B16FF4C19C1E981B066B186400C3C350ED85A2EFA02C1D4AF4FFEDF5D6199094818A81042DA47F0E96AB30E92A8C084334B2D80EF21079D5657814F4E9A0C5B64340C341DC7EFA19867E39443F67A71A392ACC42AF1DEE217BCD88A410D9503BE5E6E820ABF8E436E1B7E5A4CE87C173412707751CC0719004807E1A60112B59CE52A7596C4B65006503BA9EF842F92450D4429C06E2A5AC9A66D50A71FFB5C8F0F82D107F1A54AF803A0F34DB40F13DD02F01F53ACE052CE094D0C752EF00D50BD4B740E3F11A28E241AE02855A7CBF174536A02A38FA294EFA25276BB1D3CFB2D0CE52A52CE5B543A51D8E96C0BA10D484601707FB384DFEFEE1392549EF86926AD9498F9658AE84203D047961C82B51EFD3AAF795C9F79529F32C6AB33D22108A7E3824FB8EA3305CD8C7C22E1672F783AD0C32C3709C856F2B20D443E45706D4334085817E1DE8BF027D2748F30F2BC4437EA7924AB04AEA1B24DE1FA99D21781D09404FCDA2024AF34056CFD2C759D5CBAC46C112CD95A2217364879F20283817B0E8CB714A11FA9D3ADEECD796B0017A0C98B2A519EC5D2E88C539C40A191248FE821B87552A38620768E442481042E42F02037392107275766A48E4135105B16E30B821A395BDBB951B779985528E1490A808422E21A4217FEE20074D0E961638852017CB23F0288184102C0C435118E696C1940A28AF807BC463D851187414861C86283B085A81BF7DF46809296D2084101C27E07C89B36208A75734D0650017017E01C010A303E027D1FC2F02FD0371ADEA69A0422DCB00F53051E3309D4F4AA91E880E1353276FE2A197D684297284FA0F20C70FE8EBB76B84B0466033045680B085EA2DA18BCAE43B42F25FC28AC70E6BF867A2F970F4E632CD357BF4658BE65B362A188EBC370C13CAC82BE1496520390C0A0B3103944F2AEA22D946637509DA8CDB878BFCBF466E10A4064182333962D3083D06612BC02980D31830B180CCFD070BE359F8095D0A4031113FCCE5A081831E0E9A38E8E2E00CC0DF01BE13473094008DA62AFA862E4EE802431728BA80EE22562E1EA708263C7A951886094A35A83240B58E537F1F527F5116D9FA92E4D61CB5F0B3CAFDB12C7835EAF2C7B2EB5755E5059A0F21FA2532D9475B20D24EDC162A2CD901F7D8002E6D888D7D978BBDC20D3F661F7E8B8BBA45D2B80E7BC4AFF6D87FD9D32FDB9D0656B8C29DFF89BBD0CB95F7719BAE70691D6CE655BB4DC12618406105CDC760380E5E75C6A7D2DB87AA3F18FAFDE0422ECE2E1C2A7C3273F7A4EA4B57578F367CF6C8810587F053889F27F143765DECC6CFA4496993D654574FFE6CCC810313279A272AC7EAC72A272A472BE3A71994CA69914AA532099430067F230EB111F642FB08EE496E189B89F0767332FB24FB50B61A0CF64BAC8CBBCA4571ABB9786EB47D2867402DFE8C8B641FB10F660FD813EC0B40CE0D8243C8EF7F538518246FCA7C92BD9B4B6332E14E8867766F89074DE6A4CC4ABB26B3FAC40C762B7B690A4E702D572F878071ADAEDC0BF3978FFE9704141F194C80D1C7178731E8A61F217B68A803E2FEB705E23EB4F1E1E29EC2DEBA6B9AAB06BEB8D7FD2B39CFAF3AB22AFAAB04BC3EF651F4A309BF14F61ED9ACFECAD092FBF3CE4B8CCA2E1D3A638CB82932FB81E905D942EEB4FC5905B3EECC6372F3B31E989E374BB82F7346661E332573C62CC703D9CC94FC0767380AB267CE3239EEBF4B304DB98B9930C99A2ACC9A913DA560A6E34166F638E6FEECE905D3982CC7CCFBA74D7FE001D45C25B8CE827014841FA1E72C3C1A820921B25B5EF88E12DCD4AC0FA85BC728E118F0A2E8F20428C683178F30595B94A9C0EA84741E6C4E30D888E8D536B0F1E4A86228A184E6D1C6F7D3E74BA82F5938853E8455F0A0E8E3E0DE107DAE44F135A3680F29AE87E8EBE41F7420D8C15942A58729364CD787E98E30753DACB8D2A3E9EAD1847BC89F5D6872E0DCA4E86335B7580DCF6A9E661579402760101936F4F518FA3E1E3A39DDF0C977861BBC262468D12BC667A459857BDBF87B4FF71A5AC3746B886EE5A85F180813F741EDE0A8531C7D91D3B486F0509C00C335C8F805326E822D154658415501195738D7F5B0EB5A4FC1D55EE775A7EBA2905143626FB068946183A6D756DACB5FBED1FBE3A6DEAB377A96F584E55520B791EDF112811C6AB2510B5883E880FA0FE2CD45AF3A85780B3C284C5D023A32AD1D468A61CBB8DB29D9EB870C76C2F8EDB0BC0796F4C0343D5948F402FC0AD00EE0051802F028C01AD18C2BC5FF04F552B70F30F49050962C65420A018FFA5AC14309500564C7EF10A0D2817A7420C596D415A0CE73547998AE2A93649C91E31AE1594E818EF4195063147B183416482883F819A0AF80F874F489D12571FB879D318407CD185AA639A33AA37846C9E8CB62CA065BE2CB8687A2CE242A2DD6AAABEE9B022F26009E577678FEB2C3F3C60ECFECBD9EB17B3D4D3B3CB0D7F3CE4ECFF93D9E77F778CEEEF114EDF0ACA9F194EE29A839B7957D7EFFAB5FBF72FAF9675F3EB7F5EADE932F5FDE7B7AEFE5979E7EF9E7E77FDCFBC3DE11AF5EDD7B75EFCD576EBE726ACFBA67CE6DBDBCF7D49E537BBCCF739F6C7EEAF5A7163C197C32F49789AF54FF65F14BADB50FD7A6D486B64F7CA5E0F1D1F83DB0ED93176A5EF8CFA7FC2FBEB16DDBB68D7F99BD6DFAB621DB9817FA6AB49C952BE1D8402860FF66FF3770AEE41C778EF9366D979B9FC16CB2C5FBBDAC7EBD2DD5F8853B852B8F99E66F7FD697514C2925569ACA918B4F1F47BF60558D9E2797A4E95B8F59247279DA56F7C767F819562DBFD6A2AA6CD76C29C64656490CA37EC03F7B6F4352522A9554C1CB4D123C57B64BCA9352F727A5827E2A7676C4B487579A6A7829677CD73D91A1529CE3AF1992261E3F930AD847717B8637B2D057699226DCD04B12CAD469627F75E54949E9BE4A466213CA3DF35E4BFBCACDCB6CC05892FFEAEEF365799387B7EA47F96632B23ABDCCF7565A7C6BA9C7BA3598A2FCD5BAD5F7A6BE487C5A67FA2C6D27A9FC9849DACE5C93048D835A8BFB7C53F34E7CB4356D786BE138484B68F54A96F323AD72BEDD22193D322DB6D537C524B5C9F572DFFD26894DE2DBCCBC892D7298D77CAB98677D8B99BDC95825CBB40BAB5149588732FB669922D33E724F66A4759EF7B7FAE69B86E2553A23B399C8E5F7C15465D438D02B7DAB4DD2D1EDBE7FFB965427C7B7562527B49A1EF2DDE7FB8C7930ED1F6E5E6AB11F316994691F20AF52273332254F5BC6E190637C976CD2E4B8D666944271DAB056DF6293C42B2B542723A5B9C8269332ED65B737AA34F55A934DA297F89E0CF86B5F0B98B4819107DD81CDBE53ED95C8278FE5B5CDBE5A7D3702F922F9983BED98DB883DCD32A952D27993291A6F6DD767F9E6374C9CCC5CC13A3B1B098F38637CEB6CF9A0B498D6C98CC2B7D9A42AD447B40C6764C811AAD0FFF7EDE6D9C8BCBE8563FD869ABE8D63AB9287B57A65C9835ABD0CFFF4BF5B76348E83E5477E1D5393748F9E3AE28BF78DB8FD8B6D3C67C86D8F34E457B4CB86BD5B8C54487C1DBE124CCFEB27B9A8CBD465ED65E565E975ED6509E6A5982A2F6BD336BB0DD653C6821A83853696D4A8791DC873123B2BDE3645F906270E65AE5426EF7437DEE31BACFF35ED69777BAF9EC65307D96E231D6AD04B0D16C5105F290E31B21B09EF322F3458B4237C858CDC976F8AD24B468C1841EA48E23754068A038D2BCA93F4F2E0E85623D58ABCFDA4616D767085D9E94D2BEE18CD9277DA7D13937FEA304F349B533EAB7CCAEC6C91B6F796F3CA6F2A9FD29FECA8F0CA4A5352D2DADCC7ADD1C1546AB65799DCE66E51EA0F3A2FF076469794343B6961DCE074E6565CBA89F69F7AB2CDA97FA60395969955971C707B2A9FEA083A6548C064FFB0DA7FFF501340EBC86FA7D37337B54B0D86F4F47CFFADE703D86F7A30556AF2FC50D381BADD1E03441A4EDE6EA1263A57787BCB93027285E7C1274857DE5E4FA0C6FF7A0DCFD8E65AE44968C2DBCD66739E39C574B76F3A73A7B39D662CAA6866707062543045167446F12AAB21295562D6C70627CA8229510851AFE6E758A57CB9559E6A494A959A9DD87E763B6D8AC461BD343FEADF954F11A2BDB46FBA894A2F379B37B7B3E52B90884824223E3E3E2E7FCC49F7BAC4F8B8F2C4545562AAA0320D1979D25D8A8AA57AD6A2F4D216E9A2919FBBAB3BFA29554B83B323834E25122245D3893CC26CDACCF79A1E158D70395AC073D6712D4A6B4EDA7BEE61563B76921E7C416A1DDE425B860D19CA8C8D91880512DF18F5D466FFA8279BD452DFA01801DD1415744A79C63A6A580C6535C408FAE131A01F96E46CA16FB63C8EDD1CB7486DBC1E2DFEA342D3C764E0E0FA485F16334C1C57A7961022CC6935689EA37D63F423C551E2919FC1EDD2E00B2AC431C81A1D43E92531023624ED2BBC8AD289CE0FEF43B651E6142C2062F26A782BC14599834EBAD6A7B348BCCA60B96445A557519E44FAB4E45DA8C68617C8BE8CD90CD94CC12B98A8606A64AFAFA52DB5593FDCD7DE56C94FB2289C5E2BFF8E559D1A0A3A235B7A193A581E99708FD34B97CF0A2E8C429B0C6E8C0A3E2A6B0BC8A3500A2B50E8CEADE5665E6AD5DC0C6C6F914E6C915A6E25B5D3E5E64061C019A8ADDD5A18303B9350FD9D8D295EA9F507FD8D0EE2041813B624DC610C66E4BD37FA056B0CB25ADE977A9FA057B598FAE587571451360645D8393FA6359827F52A775BB52D83CF6C4A7FCEAA6C919CE94B35518D758D28E01595E57C89458F0A6E89B97012E94AFEC0ED972FA2680A95BBBE0D6D60136A55A2E55A122A78D017B1D0743FB6AA0C14069D2AAF2458AE0A2E54127C8FCA828F42155F629506B04D70A39238BE15A63873AADD7C01EDA6AD9DE669869ADC773C9BA127EBBB5025B1C3F8B8D2C5CEF841F166E7E441E678A7573A08019A91D52A1CEABB60AA0AFA52A743BF2A06274A824E091F890A9EE4E413F05489056872CE86BE94E59C7AB64E6941175CDD12594AE414658A2633DE47EA393A8B128382D4279252EF6C9CB5E8B1879919EB57AE5DF2F0860D46816CCD99ED6B39F1C513FED827285A4E8CD9E37BC2F8D67C67FA67679F48DC6DDDFC8CA5DCF99C75C33396B24467A0D4F74530257A8549850C940453159014D02FE84B2D965E407A5FA0241234FC39A6BFA5A69B53819F68D2F00F98747C8149CAE73077F97B6AD157216303B9A85FF30AD5E9486D05D650577A95C598DFDCA228C4530019DF46989398E899F144DAFBEE232716FF65CCB056F2227BB93AC22457CBC8DBD52AAFEC99DD96555E0C1158CB926AAFE499E72C455BC8C5ECC085BED42933824E8A74CECF6174C8A46B44CBF5A9C4A728ACE3FB5263C80E36E33FDDBE9DBE7274C55E1B87331313EDA717E1508E22F552A404A71CB22533B5BD0DFD6F2080249DBC206E66F27DE1D72C6AAB6F2417399F2FFB0B717C6B994233719D0FA1B53D809A946376D6D6B2C5E6D97250A7F595D9093956D360F50C5486764D21AA6F8B626B6142995C20F3662CC62618B208246CD9842191BCBA455E9A1AE79FF75A7D9B8D453977103B4C61EE12474A248A206162D014BCD2D4B8E071A955923A589D8A1EA64E4FA7A7A2F94988737716AFF0CACB939A034DA2DD5D38894EA7B636B89DF64A0B8985488B3BEF1F60EC269CC8A55E693E4E19B936DADFFD72BD49915A52DD1255BAAEADD1F8BEDB79C444A58883A7A22E063607CCE5286B891A4C94CA8C858A14468A3A70086D9BF82853A41AF0D2C948F254EB4455172723277FD61A89DAAB3475A42AF517F9A34C946E7B11CE3C362DCE4C13F5CDCD011D33475D822C693229C8E81BCCEB03C44EB1B3BC13954F91888499AD14ED2F92D85F64DFC21C71CECFB950D5220D9603B1BBA6791B4C779D5C6116F5D0BCD03CD1D922A9ADAD2936AF1795AE12810F1D8A997A91B2CA16295F649984BE033B55F012937473E7D4C2FEE92411CDACC21B1118F3997B7D22CE1E1B1271DA10467EE60EF44D9C8C0D8964B0BCD437DB141D307EE876A642A9D93F766F6045D2C28266926B6BF05CAA21931F56ED7F671B4962C708F49129D11DA21BE663AD6A64ED3246197446F71D2F37E990F402B47E013DAD10F00F5A1410A5B582CCA52A1424D113E7E4E497DD8D635E763B9323778CA3D67E62FA292769C1DA6A7EA429E43C6AB982B6E648CA49CA5B9194B46E7559D2DAE349D69BD952E7FA5549E54965A54949EB577AA43B929CC9DBDC66F3C28158223EEEA7094289BFA6489F87EB1FF92AA5943C39C3300516D9A8E4EFDD5D9D1B2ADCC60BEE896FE7D76EC9978371C68E082706C089CEE47748B2D5AD1F8F1D1821A4038102AAF370DD977CE786323776E0678B4CF710DD97620346691B89B5495D9C597EF1472C1AD8FE9C4A1B3360644CAB7E047A01BDC2F8A23BE5B3693B8C60B7CD4F85C48F999B84BE8845E26ECBC7AEF419CBDCC6C3F3756FCDA7A2A1F3705F5972078A265510F534C9BFA6C6FFED56FFBE2DFED9CFFA15AFD725FFC39DFC913BF973B7F199F938E58BD5DEF67F57E3BF6B8B7EB4F17BB7D36089F47D61B0A83A2B2BDC8DFE9D92F813AFEFE86F8BB56CF2E437DDFEEB4F91495797C199B4B975D7688DC69786DF7B7DF76A7F4D7EDDBD3979E2CBEF274F78B9727C72F2CB18B0AD1DB9CDDD3731D5F896DB995EDE4EFB273CEF9562D27F88D93F5CB7A8FCF73D5F977CD06DFC64FEC843489EEE5D2AED4D776D6D6DE968B8EBAE8ECE9956D9D8EA7F32B78CE05E7B0185669E8DA18FF31E3FEC6F9347DE73F20FF75060FBBBC66CC3B04FD1ED4FDDE1D1ED6CABAFD306D7FEA911963BD34D72529EBC9370B2CFB762ED09FD22E44A8E291FD3EDE45D38CD24F4EF02365E744F9CD8BFE92A02C5E2E42330C0F3FCB8C3D0B7B070CC3BEE18401DCE2BE95B5F92151B81D5F574DF86120C489E4331FB558BFCA57BFCCFEFF5FCB2A373C37FB83B6E74D4299B9C6FBD579ED49FDE2F9E465536BDFD3E7A9537DE2B6F328B37B4DF901D7E5629D9E217880E989472A9F2B3C33BF58A4045E0482E73ACB3F23FDC8D69AFBBF39562B7BCD21A8DC1E168BEE84C9DF246873E86979E8DB157B61BB61657D4B2B58F97566007373A02724A99AF57DCE8A808C825F981A64DE371D8A4F503DF26E71BEF978FEA2762C3C0176B106A9A7FA7462E0D684F4A37A9A5E3BDB2C01F2819FFFF9B947CB924208E4DA8681AD544C625548CD2FEF4E76103BF0F7BFAFF2B036E90613B02CA7C39F58751FF0CDB4C86FE7F8FDA81B192796DB6EF8ED1C771F1555CD14EE7B7C8C6E71AC36E42CA8D8E26E781F224E7C1F2514D9898F16294F6E7DFBB544567AA813927F6B4E54C8BF22C2E2A9E41A7522BEEAB4A504ED38F3AD2B045DF9EA9A63030B60C19B29967CE5422BE9F305AFB624B0BC6599D53B7E4F70F55DD4E93A1373D633D5348B675A4E76F6EA79555A38FFBEED88E5EADC9894C758ACA462012844EA26784B7E7FF88329AF94A6952E4D629559EE1CF8AA4C5006A7CB1EFD531435BAB6A6B1FE72758E5BE138C4AAFE2A32C6ADF677C24860E377DE7EA92DF75937894C1558FD4F78D7E103FC3AAF6FD1BA34189EF7BBE0CD34BB8B2D4A5C5B71E3145DC7CF759DF095C1B7FE6FB88AC8637273FED36747FBBF2B92E4CBF20A9657057B79AC2C5A0522DF1159A246AA9DFB0BBCBF0AD6F7763DA7A77FB34AF75D830E346B72F26E9F6E16C8CD0490FEBDEDD58F3F0C1E51D77FF32FCAC94597678EDB6CFDFF6AFEF7C6CE32F95DFA635BA9FB54A98415E65C0BF6477034E0E780490B5B1C98D6E74283A1928D31E73AFCD8E1577B3AC38CA5C1DB3CB3D3776E42E62C962EDC63195EECEF9CFB98F74CE64647DBE112F3462D36EE28C1C0BCD6BAB37AC36978F79CC5DBD70FDAA918FB93798CB3BB0BE1FF69AFB37C9A496E0E5585C6F922D3163CE0F64CF0F8CDD2557AD7D3016475EA9BDDE8803577D200EF17A239931E58C021D095F60EDF417ED1E8B142198741C9B8FC0C6260D36EFA77CE28AA30DFAEB7DA97329A41649C99E6D5EB81A6959BFCABC611CE495AD3497AD58870141070EFF07C228428DB81426F4102A072E2A0788B3517FA4CEBFEE39A4CCD93066ABBB6A72728D3B9D2353B76970359F64A5EBF40B71325710AA29E6572477346D26FF39003792985FDDDEF36143E980179E18779CF9251530A6181C1FC74798BE1F1177C4D48596B8C1F31FCFF95B7E1F241D07E1A55CF51126D646633E79682BD90FFFBAF169F4D823763A71BDDF484682A4FF65A414673AF3CBF01123C8003D93CBC521D4CF2B8977E77949837274A85DE30D97CAA53EF528EDADC6D2164BB01467396F68797039FA96C2F1C572A9F3CDFCA053FBD6BBC172ADF32DCCC29B9805128793DADA5063476DAD97336F2F4C388CF3CBDA6AE5804D12F7B0894FB06ABDB233C41637F1FCBF6FEEF46CDBC50FB7467825E496E7D62EAF4CCCDCDCD99100B66FD4517A1D6630A64C28986C9224BCA38EB67D8A5D137FB3BCC3F3DD33DEB74BFBE3950EB35AA3FFD1F82979A8F65DF5B3A5319010E9648F5925CF0D418BDFFA5C0C65B95E538EB1538B8A9F7166132F6BD005DC71F147982127D50B49FCD73010629AAB470C8A2F1DDD4A16E57156F9305B9C85AA2B37939652B2C3303512A33C0B2A8B259AB9694E151A71C0859F1EDC636C76A770A9B149CE23CC88D408728A49952591B39A04366B3F6BD981018BE7F51D29BA26B7312D532E8DD3EB749FB88D4CA65C197784910D366B7B1ABD16FFF93D83CD71DA6B8D1DB8602038FBDDEAB251A571E90D93B1D43C58DF7D2160AC2F69E21F31A947A7D7D65A24A346D5A2AF2C35530ADAA9F9D7A0219BDF60222BBD4CB155BAB94589DC22F7CCDA1FC839D02886DFFDEBC2D17DBEF50B3196C6D36CD3E0A4A4EA166D71415CB9395EFC7923CB711D4A82D5AF31D4BE4A1EE990593FD7F413F170512F58DB5A349620AE3C925EB04A5B70F565D69FC6C8E117FD758CD21D49B8E6E7CD64899A64936ECF2F270F8A7C8F3192CEA9AB5010B345CBC0001B1DB9C4377253BB8A99E21BA9CFE840AB4C22DD47068FCB6CB116894D1A9C2DC55EF318FA236B42EA0C1CEE239B6095D8A860B9C29C1A976E8A48D593725C7C0D3C70128363653C46C7B8D2220F909C51EFA773E49155A0980230F8B406AB5C59D13935976C833658A59B3AA7E69BCD383916D75536E2F2623B45510B7129F36BDE8B7564B190A66F7DCE428F970BC5E6465E6A61946907DD474CFAC9492F98AD83FA5E48B7446323EF7A1F635316AB41A96C0C3A55F9C19CC87446A1A66D4A8FF525BE8FD191C05D8B13C12FF5C8EEEF3C954F4533E755B20A2CFA36982AB351BD94AD3D39A15537BCB5C3D78241A8AFA5437F427C90661697932B4FF63F3A7E33A1C71FF5A269BA3FE34564547AA193CFB1CA865953F48964493BC4AAEB6E573051EAA9B804EC42B8FAC4AEBEE3699B2D912DFA172CDAF16A411F457234E6FC0B5F3C66A52A8F30125BA4CF185CA70A962B836591F51D6495359B3C460B04D7CB03A8FCAAEDE52BBCD2DB8B8E8ED9FD144D3D89B8731845422F2128A69F20AFACF04FBD1763BF48788BDC24B10DADE91FC1A7954BAC123904CB24F5A40B93A263E0B18638AA57C2275A94FDC3F24B51855694A384734C2A73EA0C736A42305581AB9EA4C090FEA789187D6003E68C129D4D3B5D2C3755F34A8B629C720F9BAB8FE5430D56454B689C32571FCD979C69B1926881CD4D00E5ED98A052A7E955ABD2DB69FD68A5F3DD7234D977313478176D1D135903F9770913F97B6CA09CCC9C2511042EBCC41802C38754814410FFBDAA8DD6FFC316D253754A5CB2D3A50B3168398BF1D840786476B6D385873044E10D67568BC4149B37CFF672CB95A59EA79EE9D009CFB64B185AA7D98D84903A04DE9F3AF80D4107D657E2F26F6DF564BEAB01D7825EB9E8C936A9D9E73008F9B0736A71C56E8BAC73AAC7F08AAFABF0D8142B95B5DEEC4B5B6F5E87339FB2DC5CD6E8CF7EC52A25CB532262A9E7EC131D152B30C2433F48A68DB4A7DD187DA846F8969B1423C8F3EA11230C166A28FE861830896F5ED8FFECD59C830B04DF4ADFDF187AB7256A548D55A1BDE9FBC9F3C22B66ED6522F875114D553E9D155D00EA81AC18E3374375FFF5D660B9BC90672D1A9479F085A860B9CA2ABDA732D018C0B5B3B999AC9D1B3BD4D26CF2B4B045C9179CC1F30A5E62E3129E3841BD9E76C45D6CE33CD4EB1D497944193E2D4C804D6A153FD36468BEE01FFB6A5B13D1900456ADD26BD1AB3ABDDF1456677B95A5792BCC4EC2559F8BDB62556120A97BF68CAD644FBEDE40A2500C2AF58AEA16A545D739B574D39EB30DF9D518F7A13718A7AC56A6A7A3C2DDE6BFF276D06989CC0CD4E5A6E7073CEFEC0CE4B7D3B99B480CAAFFC5E762EEA9D4B16779137901A156759875635F6D2E4EFB272EAA4C437CB9E8559973099076CC4D9CA4F76C6123DE69FFD834D7E732A9B0960EBEF6E53624B08DC8FB085F544CB36F79C39046948636E62B5F9408C25CAF56792CAFA2986458E14C63A546312C3D372DA1B545F2EBA8D7D2DE262345B23A3863F00DDF5AD858595BBBB0C6E0FDBCD017D588B16870BBB45074BAC5B8207626E244F31113E17CCE224BDC8E2BCDC4447D475D727C6BA3F1A87BA2B35DC1A57DE83EC291D73BD26EAF3C576D4BC8204F691AF04EF2876ED4F4F52B7C2DC407A6DFE45FC300012536C7B2DCAB2D464F3E640809D4277C32BFCD6CB2D76FDE63316EB3D2E996E195CF5A87B544580693079D5EF9F8E076196A0809BCE31BA5A6619BDB9EB17CF138A9D850F9BC558915B98757E8BF1CF3B9BB728F35022F656B464BF41E52BFAE31806BD0B433EEC7C98C88D12239072829E01C15E119B6377047E0A6692FC96DEF681CDDEA4822AF521865FF4394BAC681C7242B93CA4A73D6636EFDAAA4B2A4F4F22358152B96A209FEDA90E44C6FA8C6DA66F24703C079832E3FE8A30DBE28030691EBD1A4CA705E32D7898EA15C8C2B1B8DA7C963334D0A2EE16BBDE34A75142CF67C401B5F227723537491604C0772633BDE6848D16834A89E3A855829BFD6BB1F839C1C73C7269E8E9B6331A8A5FA11B61FF512DB0F1D09FB51A3130EE8233ADA2509C048121CB606B5120324CFD8578DF01D3ACD85CCA3D54A5CDCAF4D37659AC9BF23EF455345B51AE42B37C54D4C310D4A61062B4B5379A57E640A13F18B3409FDDEECA4F566B32F9F1976C4A4C2AA32AC2A9B38514FA528BD91A51EDDEB66332F89A14C9218C17F78BBFE92779472F267AFEF4B571693079B39273AF6E9EF0AE2E8C87BAFA1B0F3FE5D6EF257F18674AC335919742A775BFCDE8462AB2CB83DC272723404D7CAEA3AB3D05D6043F49DD556D5A85177903CFF7F6A7B16F026AAACEF64D24CDAA699505E014A13A4BBD4CAA3206285B689C802EB2274D9961616687C2CB8CA6F2BCA52A12583A095D515DC7577519146408556DA8208C8AB8351401E0AB805BAF218144BE51928D0B44D33FF3977266D1ADAC2FEFFB72967EE99FB388F7BCFB9F7DC4998EB387AB108E2777DCAC18F8B8E69602E5AE04F8ED7FBD3206848B772A78611BFFB87223FAC3F972F87F537F7F3F7A7990432FBE31722A75EE5FCDA242606BF4CC0694EBF083EFDE7A29003BF585984DFD0FC2D29E7982EF159945CB3051C209E4D3633297B0C7F4BCA3CC626861D0B5F64E6A0C2A3F38F450C519E8E2ADF5B42C7AE3C7540B3205E0BD75BE065290D2B8BCA60F1063AB05BEBE9D7C442FFC4CAE05A8BC071B643C4006D8BA0E5A902886C72DC7F5D59F9953E533F9FE3404AEC37D87D1F1B6865F4E0482FED3E12DF0B262F7C541E31FC7CC55CFC766CD15CEA6F10697F7D4DA5F1DA4A7D4A7CD9313607A647556F16ECC5BDF20377E32A77FC1AF77DABDC7F5EE38E5AE3BEB9DAFDCC9A3F965C5E33E5C3831F5E2D7EADB87771E9BA11EBBE5CFBEBB5FB3F1EF3B1F8D1031F0DFEE891F5C5EB7B97BE55DA583AAE6C75D995B294F265E5E7CB476EF868C3F50DF68DB68DAF6C336CF36FF9CB56C3E74B3F4F5E3F62E7C61DB29CBC7EF5FA413BF66EC7B45BE993DBEBB6956DF9FD968D1B233E9DF1E99E4F1336FD75937FD3AF3FFBC767E73FB36F7E6FB3BCD9B75913161615151616A6E1B461510643942E4C1B65D06A759C8EE3D21F7FF60FD6C7ADBFF9C34BD61939B3AD8FE4FCCF1F9F9B69FDE3737DE47C98BDF4F894CD623135640F9AD0EDCA4051679AF7C1E6B9FD0F4498EA005DADA25F13D4FFBD55EEDFAE46FD57AD710F5BED8E45FDA79474FD70F187DE0F7B976C2D9E50FCC3BAE7D7F9D62E5AAB5BFBCAC7E4E3B91FDDF7D1A0F5FF581F5EBAB8B47BD93365EE3253F9E3E59BCBF90DB3367CB0E1CA86948DC91B9DDB74DBBC5B0AB6FAB63A3F4F589FB8F363D03F61FD5BEBE376ECD88EA9B6346BFBA56D6BB7646C29D9C87E9AFD69C5A77D37BDBEA96ED3C8CF967E76FAB30737FF7573FDE6AB9B87ACA00F459A9E687A764CA2E158B83F2DD595C4240FB9FC415E212CB7BB60B9BD788F7955AAFE6FD59C25B96A48CCAA9C8B0BDE1AD377819F8FD7BE042B7F59A6FBE70F8CA46934697A8EF9E50782DF9A189939A4F7AAAA5772AA0E2CFCF9C0C8548B9549818CBF8E793913337F1E5E04D17B8F3EE2C4AA4E6C2C4C844DE1F3FCB189ACFBDC07F4C146D37436C155917CC0362649DFDF6FB2B2030684950D29AA80453F33BFDA6C8105296BE68189D6CE07A6ECEFBE0A5FA1909FC8E1FF053FDA7D953FCBAA2BF0DBFFDD7DD581EDBF4BE5970D59B8AADEECBF7C99AF2CB865C919308CB8BBAFCA4BA9F6EF49CAA99F5F758FAB223BDF9F75B4D32A7F5A4152A45F4A845D326C0ECCF7564B7E7B7C6FBF352972FD2FED8B73E6EB63B5E6AE144DD5EA53B57FCB36736598C7E89BC051331F99B2AF2A0F44ACEA44C8D7CDF4F5E0F396F95563B00A14EC03764AADAF8D0B9A16B0079CFB1357573B7F6BF4B8FFB4FA25A3E4FEDDEA6E592FED714D38E6DA3F7BB5905CED8710F55E989EA766BA67AF4E35232BD895744D28AD98DD37B7EFF01515F4797F69C5F0CB1FCCD46702C52D79FB5F5E8D0C901348F1724E3D88D0F4AA66E61FAB5AF4345681A2DA32F7C7AB4197F95F53556DA06A14D5AF6ABEDEA8751F5DADDC28DA4EC06F251E6982792A3A9E3FC65B9931F30B17D187762FC1C28DD7AA32A8D7AC16B74651EBB135A856C29A66B57EBDA6B55ABF5E73976A4D5ED3B65A8FE4E16398A65D9AFD9D56019D211FD3B729EC1DB2B102DA0DD95BE1EEB40A0760BA061A2CAAE6F74899F3AB3DD9177BBBC9276DE6CF537B29D13ADF6FC70D81DF9A0A5376F765636033D6CDFE7276AA7E1928ECFEE993F97E292F51B3473B06707D1EC391F0FAF023BBEBAB00BEAA8CAB8FABFAAA32C55A5315F49038557B37B5F4C7B4A04B9B3593AD35A04F08B34AA5B412095577C0AEDD7AC030BE673B5593ADD5B773FCAA322010D23AD7A18A1DD4D40FDA13663D0CE4AB0654F5378FC6EBEDAA05FFA93205FFA558BFE958E5FFB43D156A5BDB3AB7A6144AE8F01DFAE13F6A4DC5D8D1E66077A04F8AF5E8DDF6C69DDB52117675DC13A19AA458FF7597BD70C79694BDD8610F84E890623D7677DADFA91D65FD45479AB7961EF6DF77A5F51D5A51B65F76A0712BB953ACFFBE1B6D3B6E4359EE695FD3608953AC27EF42CB0E5B5076FBDAD53048D614EBE93B6BD7517DCA6A7F7B9AB548996295EEA85507B5299B83ED68D42C5F8AF5873B69D37E5DCAE21B60F165C9C61257C99B2517FBA495144ED001858B0546EE6BBD912B58980394AAF0BABB3EEEABFAB8CA2AD3A5602A6D54F8BFE4B450ACAC42B1609D1AD3266F90B6FEE2D8232FC4CD8E33D5B7B4A219219754ED5BF1D16342EA98EA71D507F2C9FB0F7C92B2677CF7AAEC6EAE2ABD8EC5C57D427C54C1316B4EA211ABBB9FFFE417F9B7BCC956266C6C736C784FD9279D24B9A0DA628D82E55D9FD443BFC5DA6D80B9B7BFB795C78C44BDDECF5AB5FDCD91FAAA9E55737B987C7DEE9DD25F9FA81930A0E096B447F36F5893627A563D8C25A04AC25715C37BAF3AA699ABC626660C4FBEAA70EFFBA4FE22C47AF873C30954ECB0F8687CE056DBA28DFBEA27014DE2B7B628F28B87DDB33F99B9FEF1F5BF5F9FB1BE6A0CC48679557DACEB9551ADFA5A9F47F3EAC12A2AE34CDE16724ACE6DFF702CE2BB8C890BAD68F282F4C7D67FB37ECFFA5DCD6C0A6F678395A1F6ADE0F64A5E3B4019766BCD30400458FEB6744C694AE9FDA501960D6DB0A4D5A1FE8D5634D4DC0E2F01CB8B6BABA5E906F03F54BABBF4B3D275A5C07A5E698035162B95A0D6F5D66D03F97771A5AAF70C65DE42184D1F76FF9041AF264FF097B8AD4B9A5DA88554AB7285948E66C0D57425845450499BA482CA15521CCD806BF0B7DD9454508932E3B426E6769741B19E5682ABE94248F3A092369B9BCAA1389C5682ABA926A47950499BCD1FC7E611B4125C4DD521CD834ADA6CBE199B47D24A70359D0B691E54D266737E03141B6825B89A7E08691E54D266F3591B0E58DD5FC1056A4541ADAB41EDF581BCE6965C70536C65B6D296C690F1D707F2DA6E19BD718079F0807ADCF7C62957D3C910B9834ADA943B7763D518FD04F7F18D5513C6C0E234694A7F30F0AA162CC408DAAC01937B6BAAB0B33CAED01DFC6930DDA066D0AEA64DCA2175DAA20D4491F6D216DAE84A55416888F1B453A72DDA4B15DAD78269EB5ADA011A6259EDD4698BF6358576E6A620DA5C4B3B4043CCAE9D3A6DD106A2487B77306D7D4B3B404D525BB443EBB4451B888E31326EF6B32AA3668C3E503DBCA525A0A6D3AD7FC6F26D5EC0D89496988C6F4D20A28500A0AD2D37CA7A2898C07885C07BAD0944B6100034F8975A48E040300168C98DD17313DC86CD555C4B0F19A0D9C556FE165C90AA0FED0B3D6D4F09CD6845282AC453F4AD0ADA22342340E88B56848C50FFE7B608D182B60841FB010AA57E5BAACC3761831D4C8F0F71347DAB82B6E80115B02473DF20C76D76C9AA9025A58DF2B60C680125E93EBCA58566A04955C87A775B695BF40E6F1963D4B9FB6FD5171875F54730BA8EFBAAB2AA12A2D3E01B53AB27113A6D41475503B6D22A9EEEA8811B0D4B77F1D413A79EC5C78155EE035BF5F9A766169CCA31EA68C6A9FA23673158AEFCAAEAA7CA85A77242EF4DA775DA606EA70AEEDCA2650A77576C6DCD7EDCE7EDB0BF8D5A33B993ED0AD0419B2011EC9FB716E148BB22DC4EAF99E0BFDB17A2A35641627C8562B8876D53AD01C7481DAF006AAAB9DD12DAACD69E15B45959B10077498031EEED68150569BD375398DE56A53D86B755549829FDDC7F3B72A4B82210ED9866F10277A61F5A776D41C795837AD4BABD99D7DB41BC9AEBABDB4015375587F269B762108FD75A7834DCAE4F2B091501CFB5A34D5B5583F85C69E1337D47A82E411252016FB39376AAB53D6CED540E1EBA1F7784AA1A2CBE227D759BC6DA56C50ECCB5ADEAC1823CBD33A42F5AC4A6525F68B327422B75D00FA1558179AB1B252D9CA0FC88F7408178E01737E90FCE72AED16FEA3D153AADFEC8FCCD73E3E601986EEAE323907CC1C29C32F34FF40B24E447EC64241945465BEDD691D651D6D176BB7DA47D947DB4C3EE18E918E5182DD88591C22861B4CBEE1AE91AE51A2DDAC591E22871B46497464AA3A4D1642C79948C23E3AD63AD8F5AC759C7DBC7DA1FB58FB38F778C753CEA18E7182F8C151E15C609E35D635D8FBAC6B9C68B63C547C571E27869ACF4A8344E1A4FD2C844924E2659D3AC13ADE9D649F634FB447BBA7D9223CD31D191EE9824A40913857461922BCD35D195EE9A24A68913C574719294264D94D2A549248B4C2153C9746B96758A75AA75BA3DCB3EC53ED53EDD91E598E298EA982E64095384A9C27457966B8A6BAA6BBA98254E11A78AD3A52C698A34559AAE57EDC544D2BD2C7372A659BFD6CB860F7CDF6A8AAB673B0D8C8B376FAA677B0C3C92688D6F60FBC45626C52F6F60EF1D38C69EE86BD00C8E718F4D7AA351FB90B5539A3DC6A77B382E2E6BACCBA7FB75FFDD8E34C9A7F96D9CE9E92C539366729C36D7A19881EC28A829D6392AEA1D24BF165FCE11AEB9E70CBEE76521C1536FF26BF1E49B4E67C864E2212B2712A6CEC1E89E219DA168CFEF09B9078FF949BA7CB91361CAE1164F528B201A339E961241D883750CBE6D2792C4129B5C5BFCE92CDBAC5807B1094EB1426C12BF176F894ED126C8C449FC3A9EC8F06711EA7BE904C42AC8F50746D03C999CCD73A89872A6834C382219725C32E1ED4416E51C17AFE629A50C11CD66A5B657941B7C14CB127B9B551AF52A95167A8CC14B9802599045644D319AA7BC158CBECBA5ADABD349C88205CF3D47C80CF810F2147C8899CC20E3C91980198013D02DBE9F2EB2CFAB4777F58D8FEF6BAAB778FA9827EAC7ADFDB5FE3766ABC9E291499124339C03E518E3F0EB18176265765F945144CC49BCB1E650798997ED552313F630913DB65E35AC9A47687D423C3A1DA43660EEB1A556D8109BE4E17490D2DE0ED11F5AB09097ED74D83C703B8864DB1C6A1E9489B2CD268B6D5E2D6744A1C8D2EB3D4178A7478F7704D2033EC440EE27FD488ED00F523C05BBEFF37D73FBFE64BD76F650EEEE3E33BE3BC079F8ADBDF22DFFEABDC392CF7B39D0FF3CE8CE9C4069DE32CB0C791AB1FBF264962D576CC20F9287C82BFA89AE01D21B44F6F1BA06A2E6616A2144F0318C60C1F7CD40295FC68B8055621EDA4951732F06E85944FA8EB6EE9613BC0FEC299274E74FA87940CD23F3BCEC69F3CAD579A4F39CAE5A72CCD0E96638ECA375BAD1761DE92174161E143B0B3D043CF6AFDA923D6F8BD5307F4BBCB9CFDEFD877EC9FAB57D231E0EFF7B789FF027B51A16ACB33E0638BD887A9D9B0198C6099CF7FF0BB04B286121580723B492970889D063BB2C0269022B64995D4450F2505E8E10E84FE2E0F0C53450CA5E643DAC83CCC13CB493F3B7E9CF254A888571B758C8F26848187B4BCD036A3E2021FBDABC324D3E6F3DC37CBE75F93B0CF3CEF2656F31CC5BCB586210C3C55E52B86810F15095EFF23FDBF7D3A15C77C2D0EFFADE33F4BB2338B9F8F811A584BC9F51E217C4FF39566C01633A5E0C2635EBD86F0C8250DFAFF37981B0FA90F7C8914426E45D6DA880D85D799B1CF159928C84D4CDBC5022885DFF2510D19E51B9AD44147F77EAB98F0561C2833D8B6044F990B7C9DD4ED334E867E86CE2E10CE0BCE37A0CF988908C8CE26241C8A85C1B218ABF3AB24812C56E9B9E29819C39A92584F48AE16092FC88ED50CE007F545E668D1705FBCCAE09B22BF7BD07120AC1921E48A8F024BEF740B4DBEAF0876BEB25916818AF2884137C33593F2AEE3842F2E8FBE992E8E9600662136DA2270CDF38E38341E48CAC2036F5185E2CE5863D60258969190F0C2CF678D21FECB54E92BE8BD27D2C89324B2EDD81E69791C3D1767C0C0B96FB3B9D619D60CFE89A50EC72643C90A029CFFDED50AB37B13C6C40CF62C991D19B2F16451DC7F844E1E78E68062BAF83D984B0DBA4C393C3222A6A4ECE888AF8C0E773464594F90ECE88D296EF5BEED430A97989024CAB890E0D215A4954E48505271689E14B5A383C8695F7F0B9AF3E84DADB8026C30A52AE53672CDE3AF5E1283D31A467444516EF48AE8CD25DC8F3BEC832EBBC30CD901177A0794D6394D94B3895EC16C4B71936C19196111651BC362B232A42F8646A97287DAA61D6C391BAE2AD59191C7BA1BC7C37439C898EE11DD19449803F6AEF8189F8CAD61727319AB2862D9359CD5AA79CCD6A4AE44F27B34CFF21D545844C5869C0D3D6DE588EAF244ACA55E4D5E219827860128C319E412EB2F98BA69EA5E737F3A207E495924E16316C7169661AABC1733559CD85B209735866DBCAD453843CB3C0077C8D073BA6E9236C05691461FA4C7424FE8190FDCBD333184D71F124A0E6BAAFFBAF580DBFE8F787354C71E9A44A86347C320B4CDB7270B9B1239AB680F63658AB254D52010C834D80053843FB02D8AF9DF401C78DB3D1955AE894544B4B6792BCA778B46EE235719C174B17E5493C9F84EEBE28498C25C980B1820C9A1B241F61AE3905A8DC283C94FFBCCD5E816783A693B80A1CC7061F636EA4A53385A454031005E316EE67FD94E5691FCBBE89D3AE75A987E304987659AFFC038D24C0BEE83A9B2C24271A1063A78A294A1E44985D872FA6D817C4E9FC8162479B31C8B37D495B2C172D9C2453A20F8751C98D967CE807075920766562C082D3881E7C379CA7EF2994B4C6649BC84BA48718DB8385D244E2FF9261FCB866594F7B59F61BA46A7DD3C3111EFA49B4CA3E0B61A15348BEC5C17B8080D112C3A70D82804DEC4AC207E10B8916C844976A91A0B48764E417F1893C1EB00C3EC9E3DBEAEAA0ED8F36C122EA7F84C551B25051251A49105C979CF84224DEC0E27A44323D3CE681A413C530E307361C298F68B1786D48EA46330679FC35DABDD51E8EF1CA24B2B3B5C7D1782A39CB9DC17E21D9306F8D6193D92EF8DA25A261EDB03E5BBC0CBB944F64F3C8AB10A9D8591FFB06715E83059D05AA7A3CCABA16E9A3A884B589286AF65E221A818065AF99DD418ABC2CB797ED1249C84820AF89B4732ED102CA2CE5B6B2F9E455E840893DC88AC40661928D9578494C81B649BCC4793479F8263E8EEA4FE3273C381B220991B8A119A46040953E70661BC614E91E865DCBDB792BF181D9F8792B604DCD18E4B13EDE8E560E922EB091DE872AF694B9A9E4103E03A56A9209259DC8B7E41591AEB16419ACD46380E78FEC41B2929C85C158061DFDA3DDE2C3051D447D19454D86C190A8A8609D36D12F1F1F2C7860C526DCE03DE42A39EF074F205F69049206E489661953E3E1A0F449E60AC43C67FDF8E2CAFB218AFFD68F6F06F4B2791E7C43AD914D5A982CC60216BB90EAFF134412F48DB51691F3100F5416B9443E97DCC43C5E64AD2403A4BAC09A583DBEBD8A91D9D7D8B1CD18CD033A26B4721C1A5EB0C66B52FB1D02AFCA452FA79E91E763500FC0F679B4DA441AD11F96B40F79943C92B59CC680CC1BE4AD0D347A677CE49117685B728B3CEFB845312399324269B155642D0ABDBCDDA949B36858F0CB85C9B1A93271F7FB36A1EE68A71B32D98D51562A6D391D6025C58680DCD4BF99A15E46974F477F881819DDCB89D8936237B38D6267C468FE0CC552C1FF52A94740BCC9F829952B40E524B6351D00CFE1D072CC7B60FBF6A3453C66D575DF85AFE786301EAB42A14DC0173692EE68CE423FC0C6C19688E02BC6C86334682F82EE39429DE939AF46F39C4D04439C0C1B941116117C7A2F76B045B0D889CDC3458A160996AC9D9E28E34BEC49D6EB27D70C06C226B60477666F82E63B73ED3D36306AC861708AA1561386E6248603D699B742046642CC62075E3301FBA7C54A3E21F3419217C930E874B74FA329243720B07912949DC9A04C3F827174B1E00B1773D0B4393338EF0B502AB21EDE6111D00A79523666C3BECE3D2F63EFC00A43E35858B3388EEE72D8651E4EBB8F627A2FABA118A9F6B2DA9FE94A709A3C306BA0CD0EEB849BE40C3A6B43AFDA23706C35EDB0BDE0C8F1B4C36E49ACF92AEDB06FC4589E45CCCB7874F41D86DFF8CDD6ED6E0746CD20AE446DCD0342D6D0513F07D81065DE86D28DCAEA04CABC6EB34307FF0902A13F419710F22ECC03272DC8E1472F58BA0DDF14E7F36A38963FCC97939DE2832356F2B94B1361B7643190A541DD1FED1F9E68ACE6D3655C0070AEA605F3005EA2CCC601960873B020F447F3B438604B370E4439C18E659F267B00F3B16670B046C01AA15F25920F583E4F376DD0C2E944A1E66274035488FE3B5412EC44343F0922EFB5087D3B0D3BF042DFD9676522D1B912B92AFE6E83294CEC0C9881B772562912309E5B417AD2BC6EA40759220CA6AFCFFB0BF942B0615BF20D7993E400964374640A4187E6C94956147B233DD6BB289F521EB628666132FB146ABB30AFE8BE057D2208F8C959EAB3680702084106D9707E1D0FE22EB788BC8BBC0AD8BBBC03144C25FCDC2C0B062251E4D3EF179A45B39B6493B38FDBC00A8E138B8181E96C3B69C497081B0AC99FC0CA7688BD7A2DA756248996C05ED94DFB5F73403E30271EAEA410F9E7D25107372137A8AFCF864EEA41FDFA714F986EB2130F07CF8719BC27B9420E9172F0E685E47B68DA6076BB7DE455884CBDE4E2A9FA440CEEBCE4CC7367B944F604BE1D99F4604FB05E11275CC282C0CAF8BBC911BF79DFA8C7B65CBE9BF9AF871273EC23FDC7CE52E7BFC90E65FECB27BFB1E52BB28B312A1598C33905DB0AFE44357BB8BFC41A625033472F89E7963A4958AAFE905534D507EB8FD304A3CE975E8DE27F5C22487298E679C41E03CC14AB117EF94BBA07655608619D77502C4F8CE12957E606796187D186EF1C3E4DBE3FFF3E045730B1C144C206EF2D67DB4866CEEC675F90C9D220FEBE66FE9EDBF873C0FF17FB68A471914C7F3F8AFA751329FFA0C986E3E42559933D4A3D21298CF2613CA457C11ECAF134999A9B4C47DFCC3990FFB771EF1C31F5AB0199AEA9F607FB050B357F81B75373ED8CEBB604AB0089E4ADEC723A397766D79079E438C8594E3E073BAC80C9AC82BC427AD243CE79F22E1343EB11C6454EE05BCAC9936417194EE6E33A4D8C92CE6DC652892C319143DF91E1DF05DBBFC2DF0953B8C2DFD28ABF88D4CCEC26E629B13B600F324F312EE121C052987D6C92802D2CB0DFFD461884FD4952C03EE74320FB39390FF600331B11BD6C4BFF47BAC6D646F589F4DFA5FB2F274305CC1B46A2C9BBAAFBEBC85121152727988A92A8EF5A3026A2B18BC5828B08BABF110229F1E5A1185271899C477702FAE91A27B13BD82FD9AFD9230189D0D724F4129E2E7FA8613F3AC238113E423DF131F0BA221A5F1E049BD8034B9D48D04F8A705A234BC1638B70C224DF7AD8A87E74C1F208DD06D6C22C22689F15063DF44FDE01516C9D9C485F627D9F6E90EE01DD23AD9E1E4A60FF8AAFD5C0FC7F2E1009902F7095201B41F27AA06625F743E99334AAEB0C5CEB719924D7605DC75291D47A19CD39BE9C799AF050FA2DF32273C37ACCC3E87E6656C806F9AACCD1FE77477E1D7928F284AC86AAC84B18E421C609149B2C75EEA4A392F4F418C92E2A499547C3FE45C6D3011EF712CD4CA700D8B75E86589CF860C2E66718258AD98D1129C51E92745C21621E5EEC19A3C5163E56321A399B18F5E7A8BF44BD1FF501F89A3AFFF0E0B9805DE773B97DCCBB323E297A8DCF15F03CDB021E9FA8BE07D8061EE7DF57815735F4B0406A01F35A50261F4EEB744B85EF56859510FC6C05606761ACB37087C458D9242E17E2538695B85C7E31FF06BF962F097E7A479F2CE12A2D6288C9BE6E139D22F9CEA30D3BE6B40387B7605DAFA65AE700D73D4E5C89E7C3986CB53860CA7F1EB0453609F82F050C6DC245269CE57B8DC652CD0671C080425EE01D9A17BF7D28B15696A24744A7463F1C3DAAD5F84324C088D813AC049E7384C7B13EE06735CFF22E18E125C07526D5F5969FD13CE9C458E3B457A3EB4DADF34D2FC7EDA6D835685BEF24851E72DD1BA67BA2F004BBC9FE172FC79C6537D5AEB00FF4E8B86F6B0D78EA09783C8DA8A94D3F03989D5A3C86598F71B02ED020F00B2E97CD42EBE27C6C16AC2910DC192DEC895E2244784602F32AEBA1338E7151DEA2241AD873858985B9143316E6BA93A87FF38F04FA17A0D61D731C1F55ABFC63E973601B9504F90F438C13B83C01691CE6B220CC28F372BAFB21F43013BD476BE8CA66F512205E3490AE163B2B51FE61C0DF4CB9B285A6429387EEE00A1381BF2E943F9E4FC24B0B613E26E3794FA103DF4A6C2C8256B9A4E8AC515754985B9848C69FD51BFBC36E4A22555278D41F202885F5C413C6F0B4B78A608C97DA04CE45C6E00CC4E582C13C0C79BB3881CD634E62B0C3E2110BB97E756DE19681CFE2C39670123CE4FF770C3A0FA74B1BC6ED340A1A46271F9B87E80ABBDBD9B11312252EDCC2662D199AB854E8DDADD23403875C260B577A58F6634AA5DF59563B412E2F2C0743E5B80985E5857AC8D331B18549DC3EB2DBA3D1ECE16AA003DEF43064252F3A7107404805B83B7480C46AC7D3C960B714C6EE42B710DE110D3C876609332E215A27BEA79BEE036DF465F25E532FDCBFF6C6B9D5D28B1B48C81B1C8C9720CF6F920561FFFA536704413EE573E293437936210DB2B301AE4E1EAE1A9268242466813319BC7C413E1ED45D909F8B1EEFCCC7E7CE38BFA76A75B2203AB9305914F7EA9803101343482C4A4EC25648E4243EB11778931D55872EBBA79FA062035B300BC5C80221357901C55E1506CD5462192F79722C8D3E1E21789E8A3A10D7AB03D89E2E2AC6BC388BA6A0C79FE6439A3CAB73C620F8E02C07EBB696D65E053D719D62DB5A61CA7742A912CBC7520ADB045B5223DD4B5C1306F1BBA97FF403BFB3E0E311EA9F833122A5FADF0FB3BFF42AAEC8F160AD0E360FE879F03142407F4E824133D19D8E4BD2874B2A16D982E17321B46E89E72D94D75929B287F250CA2F9AA3E98A6002CFB711A5C7C4E487D4BE130787A95A8BBD7B51CC2288BD63C516FD6D74974B1E46FF11E2311EA12BEDC0569832177D0B2BED5E6ACE5724DE980A7AD9894F8AC4ED1B98E312742CD44BC24DA2017C8F485114F32CCA3B8BB34DC4A224B7994624C9EEA47F5FE62F5F0EC329221FACF7653A445DC0199395C10AC6B0FB6179A985BC1FE96386B95E86CD070687C1AF343A9EC385FE2D086AF19914B83408A704C9E512E1295698BB3B36264D0948DDE618A07CF3BBA14FBC7D34761C27D2F042CF593993270CBD825BC61DBE0DC3E1AA07FE5ECE035C0B412627B71CA63D272E8830017AF5E85184F5B1C93E0630865DC1BE4131C2BAD8AD742F4D20E4DFEAC53C96CD2B7B62E6D167060E1E6CA38B3CB1D22DEAAF009B40178B69AD30984DC07521A027799C87F19169604267981808A99782E92E623C5C2E3947A5430DCF4178F106D5B53F0CD841C41E5F01BDD345999D60A1E19DCDFA331E2A9186D133A314C99973D8E7219817B614F8806601930C5C1FC7A982A9267B68686A86E0CFFF05D5103C628232139299E449158B4713424C18469E537A829CFE1C3E373FC895C8487DD91347087956434672A39F02ECEF809DEF31681D214B00BBCF24033607B0BE2679A152AF0FDF1DB0026C113971A1D2E23A573359A93798BF77326D3B7AE2AE411760E30CD896F5355FD016A33D75BDDE55B0BEF796CFA6A553E5810969843C0F79CFCDDA0979EF43DEC07B07BD44C83B90D76FD0C87715CC684BFC82968EEE6A1C06948B3424A9DBBD96AD040FE848B2244DDF47C8A31A3265F0C6BA0384CC07EC5AC22ED856BCA29137F0F732AE6BFDBBDB987F767FD078F1F8E42B93FBD6C50DDFF8C7EBD1972F1B89E61E9208210ED34BD3538FFD1D3D0496A42872CF482C1C3211AF239FC0EBC4D9787DE265BCCEFE2B5E5F5E85D7BF6EC4EBAA2FF0BAF1285EBFF801AF47AFE3F5070D5E19C33222E8243C830C008F2303C093C800F05032003C8F6C8E723419009E4A0680079401E0D96400784C19009E500680879501E0396500786419009E56068007970168F7B16CD8D3F27239F4C0B284AECFDCDC96519A91D3BD3463D79C8439FFDFF2E033CEBE6FFCDEFF7DE3CEA6D357EF9F7110FEFA10B91391988CCA6919002517B66D03C8AC6C9A0650520C77C5DBA6154C9B03507A75DB2E0050BC1260DBB6B28B004D733233001AB695940064DE2CA80428BD50560200AA170094545CB80A003D5B0000AA03CD0BCDBA0BF665B9AE3457DA6111AF425A4458CF94815DEFEBDA2BECBEAE837A47F4BE53F995B9DB0B00A6F9EBB64FC3F4CF61EFEE2CED5AF2F7F7C24AFE5ED6FBCFEFCBD38AB351F743C5BF976FF96F55DCF2E738B7341E7CE77EF8C32F1133400180E286D252808C9BCE4C00181E18F3D2CCECCC690025DBAF940180D27300AE9496340038611C01FC500F20A3297B0EC045E83C808C9B05D90017AE366C07806ECD0600BDA1EEB666C55D696BA6AE4DAF49BF915B035757BA86D1F1916111613A26222C92D370772ABF925D31ED4A76E334FF82C66957266D9FB66AC3474B4B3E2B7EE5A36BC5AF94CC5C552867161F47C55F283E26EFACD8797567C5F7672EFB9541A78A830200C5BB4A4A002A0BB22B018A611C01328E571E07B870A5B104009406E3C8D85E52EC07C83E9E3107A002EA016438334F016CBB52DC00001432011AB6FB4B012AE7646602146F035BDF56DAACF8DAF475C72F646CCBD839755B4643E5DA4A5C13348C8661085E0973A7F22B99DB8F0364C8D9DB33FCC7B757AEB5AE7BBDB84FF19275D6E225C57DD62E912B8B6FA2E2278B3F9373AEE634E65CBD5537BFA265C4F10043003CCB10008F3104C0130D01F03043003CD710008F3404C0D30D01F06043003CE310008F3704C0930E01F09043003CEF106001A17F78EA2100FEAA2770D461522A7C92933559C74FFE2DF3FB09C1A720DE7D1121F35EFA08221042CAC83C27443BA1A7F8A196FF6CD85E04402CD20280D5DF373A01D6553638011EFCBEFE0C40C9F1062780C0B90500FCDE0940FEF6BE9B001657CC1E00F9F8FA17017A9DDE5C07E0FFFDA063000DDF7D7613C022D0BFC653FFAC05C01F2A09F081C5CCE449940E7B0E13E3E5CB3A9E747BE0C1B8AEC33A938E4B9FABDB7EEACADC11A716D48D68F2D7354E7B935FBA7429BF54F8C7035BD6FC7DD8DF043136F68FBC0BB6342562AC45E68592869D8713A665A49F3CACDD51BC76471AAAFC93BFF43C80C0792D0035B7FC67002ECC59500470E8967F2EC0859BFE22002BE39100F6EEF5F300CEDAFD4D008535DC6000DBCD8BD300F6D4ADDF0950F18F033701166CBA5C0000D10EFEF9EBFEE003C0211224F888A27571FEC1A41777DC80AD1AC792B0A8A8F0B0286DC785DFD435365D39FE7DC137CE33050B6479DAEABEAB1701081F0E58BFE4C3016B04884BDE659F663DA4183099959EF197BD18F1CF8C8C07873283128A0775418DEB9D259F03488C9F036848A9D802D0F07EF6C700B50515EF0334EC747E0CA027F94900D7AEC98B00B27DD72B001E6F600E024C689A771CE0F99D1773107EDAD80490BD7E443600C437F867DB59E504408D252F7C3C1EFDE3D92F8C9F969382590C0B0ECA321D1555CB8D30AEB5D36666BF909DEDB465ACB5AE7D0D615DDF923FAFEBBBEE3588D1AAC9BB6407B9805F8011EFBF2B4A4E693EACCC78EC10F9CDFEE2D7BF426D61A9BEAAA41CA4463F1EC789404F4B2378E826009ECF0980476D02E0299C0078006739BD4B05C0633A01F0C44E003A8A21876EE201A0E072CDE9FFB73CF4605142C0611D840187F510CD353B3D2B09546A54D583D458C1CB782099EC22B0D321E452717109C05559BE0860600417C015861C00F88411CA004A19F22D80815BE8022865E18E45B7940E4B64996B59733A62C408C2F37C737AA7F22BE08F747955D3ED23B60BE89B81B4B1B19154545490404A48CAE1842C42A6826F12A2F8268E97AA9C1FC79195652F400D84FC008D09C5C5008DB2DC00C012473C40A3601F02709138EE03B828D8EF076019E969808B820877CA2EFD86979CAB39D79C1A8D46D846B0CDE99DCA71B6B902FE17484B07960AE887813478DC3085E17831E21F8474073F2444F1431C2E55BB0A1C4622E3596F72035406D8B5BFB8186017640210D11C01B04B3219001AE00EA001EE008898D713A0414A84BB44D46ED7CE5DA4BEA1BE390589F1C7A56AD271A95FAEC890E5C68C405AD2B784FA5C200D1E334C05C282CF09240C7C4E2491D4E75ABC6AD09DBCAAB90CEFE811B77567F0B45B003CE816809E797B7C3A1E770B8027DF02E0A1B700D48BF137AEFF655FC4D538381E46255B7CEBC09D7C4B2953EF4E15D41D0038CD3117017AFFA1BB09E0D49CE3AF03BCF9D27919E09DC7865A00125FD61300EACBA8E47FDB2545D01CCC07C3075BEF040B286B8B4AE86543655B7CEDFA9D7C4D2953EFEAB20BAE03D42D14E70170937FF52540DDB4393F00FCB8F22519A0FA778F710006EBCB0480FA362AFBDFF6504F9AEB3068E8C9751DF6F05C040738CF46E878D4B6C5F77C77F43D5AA6DEED3C7E261F60A7941B0BC01CFBEDF3003B8F4FCB03F09E5FE904A87FFBBB870158B05D00EAEBA8ED7FD3637DFF5A7B03B4F39D5CBBC9C742300C380B5131ABF76C954FC87A4FBC67A827CB2378BEF4C45F5B76CD7BEDA9EBFD6BC7D63E551BEF4120E424AB403CD4C2D40AC01856BCAAD55D22F1D1926082341A523BA443810ED6B927A84E0494992135AB759301B2801BD68B53EB613E6378C3C018DE263AFE1C05C87F23D0BE8B5AAEA7F597FF255E57430490773CBD5FB664A84E8254088FC5DFBC7665164FA1A9668A8696BFBD4407A946778E1880AE1EE9EB14FA6695AE89D667C723ED18A04DBA6AE9F19D5F7A965D1BABD248A66D1687E705D1D4439E5EA5AD55EF91AEA1599F15440BF2034EBAA8B2EB813E63788DD6877B82BAC443BF234DADCAC3AEF2B0ABF77F6A478F08C4953EBC2B3ECB6074F52ACD6495E628F57EB672DFAE6EFF292FEFB5FEB5482BC00FF3B11E8E69A0BE9277A9393F9067682E7F7BC9D8A0F65AB51E9607B70BA45AB5DDB00EC6E83FD5E3A9EB636BF729F6454C8ABD91A3EA7D7FF013BCFF52B97FDDAC944762F958F09EB6F2F54D8B6BD1F6F36BDFA0E9E25A572D8E378E278E2BE6BD51BBA9559E04B8ABF660ABBC17017F2ABA866CAAF5D4C6B084E6A1DF4407D5C953EB1CAC35DD68AB8E4EA5EDA94DBB1111286F87D602A54FE496FE557094D77463451BED6B5AB5670C3E12178DFD01FEDF01ADB41B87EF204B0DCDD3AA6528FF8A1B3137DB6B837C8D2ADF409B40FA845A9EA49623FFC337D24368D534EB82348D2134903F42CC4DD76D3204F3D6ABB402A9564DDF0DD11F21FDE68D56B4908E56A5630CA2AD0FC90BC8A4D224C1345D37936E85CAA70F69A7557905E84684E878E3A6702BB46F5AD3A869A615C80FED63A493746B53339D00CFFEADFAA9A57D80B7702BA64EAFD68D50EBC604D1C0B18908693B2FA86F638370D5DF97C03CA2334703400AF9E1D84F9B6EE5D745A8F4AC77479F04D127ADE95F52E9D3B98DD28FA93BD84C3F22A4BF0D77E07752E5618AAE69A6975F17E70DD033B461A32D745A6C2F744CEC01BABA16BA07EB6685D0AD69876E1BF205E91B07211AF2EAA2F26ADB9E6B549A35B7D11CA8D05C6855640B4BB8C398C21AA033409F631A1FDD32AEB3BC8BEB03B669606FB77F94A967880D2ABC57006FBA9E0778B73BDE740D8AAE51D6A968754D52EF71CC82FBF786D7D3AE3CBAA071D475D0170E95AF9EEA7B49D5FB920E78E9600C9A755F5CFF7443C03F0336670A991383FD5917E4D74A4CA57BC614D217D12CCB019D37C18620BDF4A6522F6CD57334E59E42BE9EFA830DAD75ACF94F74D404E9B810D6660DF812E631D359360C63957858CB9F6E486F6CAF1F51CFD89031C576314A4C4142750AB6ADA1CD7C2F35F3FDA5CA17DA87617B655D57E438D82051392254BE5D5AF9744D9BFA46A8F25855798C01DDA35BD93AB5B1792AAF40DD6EEABD1A33AA36ACC892DE38CBA7CE9361C1637CBB8DD5A8F228E3A257E58953691A42E459A3EA1F28EFD28E0C46B8275DF53486961A4FF8B4D00E7836835EBDD7410A7D11665453CC0719C230A6EAAF43D905A2A53C972D7E4DB9D746ABF706F5BE8B7AFF14DCCFF2E99B72694C77988DA3E5E222837A2FD0584C5C345CBDCF83FB13BEFCDA5C968D82F6581F63B54506F55E50EF87ABF758BF5C1EDB7452D5751FAE634D539B708F119C37B66956AB3A539B9637E5AAF7A857B21A3B2A7DB70C6C49B9C7BAB39AB636E5B5EE5B395DB997B17C79D325CA2FA40ECC2BD8DF112F8F0AB223D235F277D8666B93D99FD6C25F362BFCE47BD4B62A7D3A775F6A1AD566DDB836EA9AFDE9FE9341B28FF2E7FB557F90BBA8328F54EF5579651ADBF8D7F803B6ABD6236ABD66BDE8BAE63F78277AB4DE1AFF8DBBA277D01F2707FA5AA3F63D8E31F65B604CBA29FD3611F5B9E14F93B342E8E29C304A6D6B0DD23D4E7E5A9E14222B8D65650168509F59DC4599339ABFD29A14421BE908F21A19FA548BB05C2E97D18E10D6C8494DD8D70871DE59B0A22EAEF7C09C7E10E63E097CFD04D87D7EEDC1BAFCDA72E8DF7CE8E183D02B71721AC82500AF35402B09C636A9298D90CB97C346266342FE17E1A76C5C]]>
      </FileEmbedded>
    </File>
    <Group Comment="shader render" DesignDisable="255">
      <Children>
        <ZExpression Expression="MemSampler.ValueArrayRef=mem;"/>
        <UseMaterial Material="SpeccyMaterial"/>
        <RenderTransformGroup Scale="8 8 1">
          <Children>
            <RenderSprite/>
          </Children>
        </RenderTransformGroup>
        <ZExpression Expression="MemSampler.ValueArrayRef=null;"/>
        <Material Name="SpeccyMaterial" Shader="SpeccyShader"/>
        <Shader Name="SpeccyShader" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D mem;

void main()
{
  vec4 color;

  float specX=gl_TexCoord[0].s * 256.0;
  float specY=gl_TexCoord[0].t * 192.0;

  float index=0 + specY*32 + specX/8;
  float u=index / 65536.0;

  vec2 uv = vec2(u ,0.0);

  color.r=texture2D(mem, uv).r*8388607.0;

/*  int pixelbyte=int(texture2D(mem, uv).r);
  if(pixelbyte) & (1<<int(specX)&7) )
    color.r=1;
  else
    color.r=0;*/

//  if(color.r!=0)
//    color.g=1.0;
  color.b=0.3;
  color.a=1.0;

  gl_FragColor = color;
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable Name="MemSampler" VariableName="mem"/>
          </UniformVariables>
        </Shader>
      </Children>
    </Group>
    <Group Comment="gl raster render" DesignDisable="1">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[byte[6144] video;
//for(int i=0; i<video.SizeDim1; i++)
//  video[i]=mem[16384+i];//rnd()*255;

for(int addr=16384; addr<(16384+192*32); ) {
  int y = ((addr&0x00e0)>>2) +
       ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}

/*glMatrixMode(GL_PROJECTION_MATRIX);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW_MATRIX);
glLoadIdentity();*/
glRasterPos2f(-1,-2);
glBitmap(256,192,0,0,0,0,video[0]);]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
    <KeyPress Name="KeyTester" CharCode="17">
      <OnPressed>
        <ZExpression Expression="KeyTesterResult=1;"/>
      </OnPressed>
    </KeyPress>
    <Variable Name="KeyTesterResult" Type="1"/>
  </Content>
</ZApplication>
