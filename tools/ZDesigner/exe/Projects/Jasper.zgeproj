<?xml version="1.0" encoding="iso-8859-1" ?>
<ZApplication Name="App" Caption="14" ViewportRatio="2" FileVersion="2">
  <OnLoaded>
    <ZExternalLibrary ModuleName="kernel32.dll">
      <Source>
<![CDATA[//Import a DLL-library by setting ModuleName to name of the DLL
//and then declaring the function headers here. For example:
//
//  int SetWindowLongA(int hWnd, int nIndex, int dwNewLong) { }
//  int SetWindowTextA(int hWnd,string lpString) { }
int GetTickCount() { }]]>
      </Source>
    </ZExternalLibrary>
    <ZExternalLibrary Comment="OpenGL 4.0 graphics" ModuleName="opengl32" DefinitionsFile="opengl.txt">
      <BeforeInitExp>
<![CDATA[if(ANDROID) {
  if(App.GLBase==0)
    this.ModuleName="libGLESv1_CM.so";
  else
    this.ModuleName="libGLESv2.so";
}]]>
      </BeforeInitExp>
    </ZExternalLibrary>
    <ZLibrary Comment="util">
      <Source>
<![CDATA[int isKeyPressed(int key) {
  KeyTesterResult=0;
  KeyTester.CharCode=key;
  @CallComponent(Component : KeyTester);
  return KeyTesterResult;
}

private int nextScreenDumpFileName;

void saveScreenDump() {
  //Based on code by Kjell http://www.emix8.org/forum/viewtopic.php?f=1&t=1156&p=7242&hilit=save+image#p7242
  int w=App.ViewportWidth;
  int h=App.ViewportHeight;

  byte[18] header;

  header[2] = 2;
  header[16] = 32;
  header[17] = 8;

  header[12] = w;
  header[13] = w >> 8;

  header[14] = h;
  header[15] = h >> 8;

  byte[] buffer;
  buffer.SizeDim1 = header.SizeDim1 + w*h*4;

  int dst=0;
  for(int i=0; i<header.SizeDim1; i++)
    buffer[dst++]=header[i];

  glReadPixels(App.ViewportX, App.ViewportY, w, h, 0x80E1, 0x1401, buffer[dst]);

  string number=intToStr(nextScreenDumpFileName++);
  while(length(number)<5)
    number="0"+number;

  string filename="t:\\pic" + number + ".tga";
  @FileAction( File : @File(FileName : filename, Encoding : 1, TargetArray : buffer), Action : 1 );
}]]>
      </Source>
    </ZLibrary>
    <ZLibrary Comment="jasper" HasInitializer="1">
      <Source>
<![CDATA[//Based on https://github.com/begoon/jasper

    const int DEBUGTRACE = 0;
  const int PROFILE = 0;
  const int ANALYSE = 0;
  const int ANALYSE_CHECK_HOTSPOTS = 0;
  const int ANALYSE_CHECK_PC = 0;

  int analyse_frameRenderIndicator = 0;
  int analyse_checkFrameWrites = 0;
  int[65536] analyse_HotSpots;
  int[65536] analyse_AddrFlags;

  private const float clockSpeed = 3.5;
  private const int tstatesPerInterrupt = ((clockSpeed * 1e6) / 50);


  int Keys_B_SPC  = 0xff;
  int Keys_H_ENT  = 0xff;
  int Keys_Y_P    = 0xff;
  int Keys_6_0    = 0xff;
  int Keys_1_5    = 0xff;
  int Keys_Q_T    = 0xff;
  int Keys_A_G    = 0xff;
  int Keys_CAPS_V = 0xff;
  int JoyState = 0;

  const int IM0 = 0;
  const int IM1 = 1;
  const int IM2 = 2;

  private const int F_C  = 0x01;
  private const int F_N  = 0x02;
  private const int F_PV = 0x04;
  private const int F_3  = 0x08;
  private const int F_H  = 0x10;
  private const int F_5  = 0x20;
  private const int F_Z  = 0x40;
  private const int F_S  = 0x80;

  private const int PF = F_PV;
  private const int p_ = 0;

  private int[256] parity;

  private const int true = 1;
  private const int false = 0;

  int getSignedByte(int b) {
    if(b&0x80)
      return 0-((b^255) +1);
    else
      return b;
  }

  {
    for ( int i = 0; i < 256; i++ ) {
      int p = true;
      for ( int j = 0; j < 8; j++ ) {
        if ( (i & (1<<j)) != 0 ) {
          p = p ? false : true;
        }
      }
      parity[ i ] = p;
    }
  }

  /** Alternate registers */
   int        _AF_ = 0, _HL_ = 0, _BC_ = 0, _DE_ = 0;

  /** Index registers - ID used as temporary for ix/iy */
   int        _IX = 0, _IY = 0, _ID = 0;

  /** Stack Pointer and Program Counter */
   int        _SP = 0, _PC = 0;

  /** Interrupt and Refresh registers */
   int        _I = 0, _R = 0, _R7 = 0;

  /** Interrupt flip-flops */
   int    _IFF1 = true, _IFF2 = true;
   int        _IM = 2;

  /** Memory */
   byte[ 65536 ]  mem;

    /** Main registers */
   int        _A = 0, _HL = 0, _B = 0, _C = 0, _DE = 0;
   int    fS = false, fZ  = false, f5 = false, fH = false;
   int    f3 = false, fPV = false, fN = false, fC = false;

  /** Flag access */
    inline void setZ( int f ) { fZ = f; }
    inline void setC( int f ) { fC = f; }
    inline void setS( int f ) { fS = f; }
    inline void setH( int f ) { fH = f; }
    inline void setN( int f ) { fN = f; }
    inline void setPV( int f ) {fPV = f;}
    inline void set3( int f ) { f3 = f; }
    inline void set5( int f ) { f5 = f; }

    inline int Zset()  { return fZ; }
    inline int Cset()  { return fC; }
    inline int Sset()  { return fS; }
    inline int Hset()  { return fH; }
    inline int Nset()  { return fN; }
    inline int PVset() { return fPV; }


  /** 8 bit register access */
  inline int  A() { return _A; }

  inline void A( int bite ) {
    _A = bite;
  }

  inline int F() {
    return  (Sset()  ? F_S  : 0)  |
      (Zset()  ? F_Z  : 0)  |
      (f5      ? F_5  : 0)  |
      (Hset()  ? F_H  : 0)  |
      (f3      ? F_3  : 0)  |
      (PVset() ? F_PV : 0)  |
      (Nset()  ? F_N  : 0)  |
      (Cset()  ? F_C  : 0);
  }
  inline void F( int bite ) {
    fS  = (bite & F_S)  != 0;
    fZ  = (bite & F_Z)  != 0;
    f5  = (bite & F_5)  != 0;
    fH  = (bite & F_H)  != 0;
    f3  = (bite & F_3)  != 0;
    fPV = (bite & F_PV) != 0;
    fN  = (bite & F_N)  != 0;
    fC  = (bite & F_C)  != 0;
  }


  inline int  B() { return _B; }
  inline void B( int bite ) {
    _B = bite;
  }
  inline int  C() { return _C; }
  inline void C( int bite ) {
    _C = bite;
  }

  inline int D() { return (_DE >> 8); }
  inline void D( int bite ) {
    _DE = (bite << 8) | (_DE & 0x00ff);
  }
  inline int  E() { return (_DE & 0xff); }
  inline void E( int bite ) {
    _DE = (_DE & 0xff00) | bite;
  }

  inline int  H() { return (_HL >> 8); }

  inline void H( int bite ) {
    _HL = (bite << 8) | (_HL & 0x00ff);
  }

  inline int L() { return (_HL & 0xff); }
  inline void L( int bite ) {
    _HL = (_HL & 0xff00) | bite;
  }

  /** 16 bit register access */
  inline int AF() { return (A() << 8) | F(); }

  inline void AF( int word ) {
    A( word >> 8 );
    F( word & 0xff );
  }

  inline int BC() { return (B() << 8) | C(); }
  inline void BC( int word ) {
    B( word >> 8 );
    C( word & 0xff );
  }

  inline int  DE() { return _DE; }
  inline void DE( int word ) {
    _DE = word;
  }

  inline int  HL() { return _HL; }
  inline void HL( int word ) {
    _HL = word;
  }

  inline int PC() { return _PC; }

  inline void PC( int word ) {
    _PC = word;
  }

  inline int  SP() { return _SP; }
  inline void SP( int word ) {
    _SP = word;
  }

  inline int ID() { return _ID; }
  inline void ID( int word ) {
    _ID = word;
  }

  inline int IX() { return _IX; }
  inline void IX( int word ) {
    _IX = word;
  }

  inline int IY() { return _IY; }
  inline void IY( int word ) {
    _IY = word;
  }




  inline int  IDH() { return (_ID >> 8); }
  inline void IDH( int bite ) {
    _ID = (bite << 8) | (_ID & 0x00ff);
  }
  inline int  IDL() { return (_ID & 0xff); }
  inline void IDL( int bite ) {
    _ID = (_ID & 0xff00) | bite;
  }


  /** Memory refresh register */
  inline int  R7() { return _R7; }
  inline int  R() { return (_R & 0x7f) | _R7; }
  inline void R( int bite ) {
    _R  = bite;
    _R7 = bite & 0x80;
  }

  inline void REFRESH( int t ) {
    _R += t;
  }


  /** Interrupt modes/register */
  int  I() { return _I; }
  void I( int bite ) {
    _I = bite;
  }

  int IFF1() { return _IFF1; }
  void IFF1( int iff1 ) {
    _IFF1 = iff1;
  }

  int IFF2() { return _IFF2; }
  void IFF2( int iff2 ) {
    _IFF2 = iff2;
  }

  int IM() { return _IM; }
  void IM( int im ) {
    _IM = im;
  }



  /** Byte access */
  inline int peekb( int addr ) {
    return mem[ addr ];
  }

  void pokeb( int addr, int newByte ) {
    if ( addr < 16384 ) {
      return;
    }

    mem[ addr ] = newByte;

    if(ANALYSE) {
      //if(addr==50176)
      //  trace("mod: " + intToStr(_PC));

      if(analyse_checkFrameWrites && addr>16384 && addr<16384+6912) {
        analyse_frameRenderIndicator=1; //Trigger screen refresh on each byte written to video RAM
        if(ANALYSE_CHECK_HOTSPOTS)
          analyse_HotSpots[_PC]++;
      }
    }

  }


  /** Word access */
  void pokew( int addr, int word ) {
    pokeb( addr, word & 0xff );
    addr++;
    pokeb( addr & 0xffff, word >> 8 );
  }

  private  int peekw( int addr ) {
    int        t = peekb( addr );
    addr++;
    return t | (peekb( addr & 0xffff ) << 8);
  }


  /** Program access */
  int nxtpcb() {
    int pc = PC();
    int t = peekb( pc );
    PC( ++pc & 0xffff );
    return t;
  }
  private  int nxtpcw() {
    int pc = PC();
    int t = peekb( pc );
    t |= ( peekb( ++pc & 0xffff ) << 8 );
    PC( ++pc & 0xffff );
    return t;
  }

  /** Index register access */
  private  int ID_d() {
    return ((ID() + getSignedByte(nxtpcb()) ) & 0xffff);
  }


  /** Stack access */
  void pushw( int word ) {
    int        sp = ((SP()-2) & 0xffff);
    SP( sp );
    pokew( sp, word );
  }

  int popw() {
    int sp = SP();
    int t  = peekb( sp );
      sp++;
      t |= (peekb( sp & 0xffff) << 8);
      SP( ++sp & 0xffff );
    return t;
  }


  /** Call stack */
  void pushpc() { pushw( PC() ); }
  void poppc()  { PC( popw() ); }



  int bordercolor;

  /** IO ports */
  void outb( int port, int bite, int tstates ) {
    if ( (port & 0x0001) == 0 ) {
      bordercolor = (bite & 0x07);
    }
  }

  int inb( int port ) {
    int res = 0xff;

    if((port & 31) == 31) {
      res=JoyState;
    } else if ( (port & 0x0001) == 0 ) {
      if ( (port & 0x8000) == 0 ) { res &= Keys_B_SPC; }
      if ( (port & 0x0800) == 0 ) { res &= Keys_1_5;   }
      if ( (port & 0x4000) == 0 ) { res &= Keys_H_ENT; }
      if ( (port & 0x1000) == 0 ) { res &= Keys_6_0;   }
      if ( (port & 0x2000) == 0 ) { res &= Keys_Y_P;   }
      if ( (port & 0x0200) == 0 ) { res &= Keys_A_G;   }
      if ( (port & 0x0400) == 0 ) { res &= Keys_Q_T;   }
      if ( (port & 0x0100) == 0 ) { res &= Keys_CAPS_V;}

      /*if ( (port & 0x8000) == 0 ) { res &= _B_SPC; }
      if ( (port & 0x4000) == 0 ) { res &= _H_ENT; }
      if ( (port & 0x1000) == 0 ) { res &= _6_0;   }
      if ( (port & 0x0800) == 0 ) { res &= _1_5;   }
      if ( (port & 0x0400) == 0 ) { res &= _Q_T;   }
      if ( (port & 0x0100) == 0 ) { res &= _CAPS_V;}*/
    }

    return(res);
  }

  /** Interrupt handlers */
  private inline int interruptTriggered( int tstates ) {
    return (tstates >= 0);
  }

   int interrupt() {
    // If not a non-maskable interrupt
    if ( !IFF1() ) {
      return 0;
    }

    switch( IM() ) {
    case IM0:
    case IM1:
      pushpc();
      IFF1( false );
      IFF2( false );
      PC( 56 );
      return 13;
    case IM2:
      pushpc();
      IFF1( false );
      IFF2( false );
      int t = (I()<<8) | 0x00ff;
      PC( peekw(t) );
      return 19;
    }

    return 0;
  }

  /** EX AF,AF' */
  void ex_af_af() {
    int   t;
    t = AF(); AF( _AF_ ); _AF_ = t;
  }

  /** Quick Increment : no flags */
  private inline int inc16( int a ) { return (a + 1) & 0xffff; }
  private inline int qinc8( int a ) { return (a + 1) & 0xff; }

  /** Quick Decrement : no flags */
  private inline int dec16( int a ) { return (a - 1) & 0xffff; }
  private inline int qdec8( int a ) { return (a - 1) & 0xff; }

  /** Bit toggling */
  private inline int res( int bit, int val ) { return val & ~bit; }
  private inline int set( int bit, int val ) { return val |  bit; }

  private  int in_bc() {
    int        ans = inb( BC() );

    setZ( ans == 0 );
    setS( (ans & F_S)!=0 );
    set3( (ans & F_3)!=0 );
    set5( (ans & F_5)!=0 );
    setPV( parity[ ans ] );
    setN( false );
    setH( false );

    return ans;
  }

  /** Add with carry - alters all flags (CHECKED) */
  private  void
  adc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a + b + c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f) + c) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Add - alters all flags (CHECKED) */
  private  void
  add_a( int b )
  {
    int a    = A();
    int wans = a + b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) + (b & 0x0f)) & F_H) != 0 );
    setN( false );

    A( ans );
  }

  /** Subtract with carry - alters all flags (CHECKED) */
  private  void
  sbc_a( int b )
  {
    int a    = A();
    int c    = Cset() ? 1 : 0;
    int wans = a - b - c;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f) - c) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Subtract - alters all flags (CHECKED) */
  private  void
  sub_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S)  != 0 );
    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setZ( (ans)        == 0 );
    setC( (wans&0x100) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
    setH(  (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setN( true );

    A( ans );
  }

  /** Rotate Left - alters H N C 3 5 flags (CHECKED) */
  private  void
  rlc_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right - alters H N C 3 5 flags (CHECKED) */
  private  void
  rrc_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Left through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rl_a()
  {
    int     ans = A();
    int c   = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }

    ans &= 0xff;

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Rotate Right through Carry - alters H N C 3 5 flags (CHECKED) */
  private  void
  rr_a()
  {
    int     ans = A();
    int c   = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    set3( (ans & F_3)  != 0 );
    set5( (ans & F_5)  != 0 );
    setN( false );
    setH( false );
    setC( c );

    A( ans );
  }

  /** Compare - alters all flags (CHECKED) */
  private  void
  cp_a( int b )
  {
    int a    = A();
    int wans = a - b;
    int ans  = wans & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (b & F_3)   != 0 );
    set5( (b & F_5)   != 0 );
    setN( true );
    setZ( ans == 0 );
    setC( (wans & 0x100)!=0 );
    setH( (((a & 0x0f) - (b & 0x0f)) & F_H) != 0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x80) != 0 );
  }

  /** Bitwise and - alters all flags (CHECKED) */
  private  void
  and_a( int b )
  {
    int ans = A() & b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise or - alters all flags (CHECKED) */
  private  void
  or_a( int b )
  {
    int ans = A() | b;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Bitwise exclusive or - alters all flags (CHECKED) */
  private  void
  xor_a( int b )
  {
    int ans = (A() ^ b) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( false );
    setPV( parity[ ans ] );
    setZ( ans == 0 );
    setN( false );
    setC( false );

    A( ans );
  }

  /** Negate (Two's complement) - alters all flags (CHECKED) */
  private  void
  neg_a()
  {
    int t = A();

    A( 0 );
    sub_a(t);
  }

  /** One's complement - alters N H 3 5 flags (CHECKED) */
  private  void
  cpl_a()
  {
    int ans = A() ^ 0xff;

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setH( true );
    setN( true );

    A( ans );
  }

  /** Decimal Adjust Accumulator - alters all flags (CHECKED) */
  private  void
  daa_a()
  {
    int        ans = A();
    int        incr = 0;
    int    carry = Cset();

    if ((Hset()) || ((ans & 0x0f) > 0x09)) {
      incr |= 0x06;
    }
    if (carry || (ans > 0x9f) || ((ans > 0x8f) && ((ans & 0x0f) > 0x09))) {
      incr |= 0x60;
    }
    if (ans > 0x99) {
      carry = true;
    }
    if (Nset()) {
      sub_a(incr);
    } else {
      add_a(incr);
    }

    ans = A();

    setC( carry );
    setPV( parity[ ans ] );
  }

  /** Load a with i - (NOT CHECKED) */
  private  void
  ld_a_i()
  {
    int ans = I();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Load a with r - (NOT CHECKED) */
  private  void
  ld_a_r()
  {
    int ans = R();

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate right through a and (hl) - (NOT CHECKED) */
  private  void
  rrd_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t >> 4) | (ans << 4);
    ans = (ans & 0xf0) | (q & 0x0f);
    pokeb( HL(), t );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Rotate left through a and (hl) - (NOT CHECKED) */
  private  void
  rld_a()
  {
    int ans = A();
    int t   = peekb( HL() );
    int q   = t;

    t   = (t << 4) | (ans & 0x0f);
    ans = (ans & 0xf0) | (q >> 4);
    pokeb( HL(), (t & 0xff) );

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( ans == 0 );
    setPV( IFF2() );
    setH( false );
    setN( false );

    A( ans );
  }

  /** Test bit - alters all but C flag (CHECKED) */
  private  void
  bit( int b, int r )
  {
    int    bitSet = ((r & b) != 0);

    setN( false );
    setH( true );
    set3( (r & F_3) != 0 );
    set5( (r & F_5) != 0 );
    setS( (b == F_S) ? bitSet : false );
    setZ(  !bitSet );
    setPV( !bitSet );
  }

  /** Set carry flag - alters N H 3 5 C flags (CHECKED) */
  private  void
  scf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setH( false );
    setC( true );
  }

  /** Complement carry flag - alters N 3 5 C flags (CHECKED) */
  private  void
  ccf()
  {
    int        ans = A();

    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setN( false );
    setC( Cset() ? false : true );
  }

  /** Rotate left - alters all flags (CHECKED) */
  private  int
  rlc( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( c ) {
      ans = (ans << 1)|0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right - alters all flags (CHECKED) */
  private  int
  rrc( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( c ) {
      ans = (ans >> 1)|0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate left through carry - alters all flags (CHECKED) */
  private  int
  rl( int ans )
  {
    int c = (ans & 0x80) != 0;

    if ( Cset() ) {
      ans = (ans << 1) | 0x01;
    } else {
      ans <<= 1;
    }
    ans &= 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Rotate right through carry - alters all flags (CHECKED) */
  private  int
  rr( int ans )
  {
    int c = (ans & 0x01) != 0;

    if ( Cset() ) {
      ans = (ans >> 1) | 0x80;
    } else {
      ans >>= 1;
    }

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left Arithmetically - alters all flags (CHECKED) */
  private  int
  sla( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = (ans << 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Left and Set - alters all flags (CHECKED) */
  private  int
  sls( int ans )
  {
    int c = (ans & 0x80) != 0;
    ans = ((ans << 1) | 0x01) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Arithmetically - alters all flags (CHECKED) */
  private  int
  sra( int ans )
  {
    int c = (ans & 0x01) != 0;
    ans = (ans >> 1) | (ans & 0x80);

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Shift Right Logically - alters all flags (CHECKED) */
  private  int srl( int ans ) {
    int c = (ans & 0x01) != 0;
    ans = ans >> 1;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( parity[ ans ] );
    setH( false );
    setN( false );
    setC( c );

    return(ans);
  }

  /** Decrement - alters all but C flag (CHECKED) */
  private  int dec8( int ans ) {
    int    pv = (ans == 0x80);
    int    h  = (((ans & 0x0f) - 1) & F_H) != 0;
    ans = (ans - 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( true );

    return(ans);
  }

  /** Increment - alters all but C flag (CHECKED) */
  private  int inc8( int ans ) {
    int    pv = (ans == 0x7f);
    int    h  = (((ans & 0x0f) + 1) & F_H) != 0;
    ans = (ans + 1) & 0xff;

    setS( (ans & F_S) != 0 );
    set3( (ans & F_3) != 0 );
    set5( (ans & F_5) != 0 );
    setZ( (ans) == 0 );
    setPV( pv );
    setH( h );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int adc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a + b + c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ ~b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff) + c) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add - (NOT CHECKED) */
  private  int add16( int a, int b ) {
    int lans = a + b;
    int ans  = lans & 0xffff;

    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setC( (lans & 0x10000)!=0 );
    setH( (((a & 0x0fff) + (b & 0x0fff)) & 0x1000)!=0 );
    setN( false );

    return(ans);
  }

  /** Add with carry - (NOT CHECKED) */
  private  int sbc16( int a, int b ) {
    int c    = Cset() ? 1 : 0;
    int lans = a - b - c;
    int ans  = lans & 0xffff;

    setS( (ans & (F_S<<8)) != 0 );
    set3( (ans & (F_3<<8)) != 0 );
    set5( (ans & (F_5<<8)) != 0 );
    setZ( (ans) == 0 );
    setC( (lans & 0x10000)!=0 );
    setPV( ((a ^ b) & (a ^ ans) & 0x8000)!=0 );
    setH( (((a & 0x0fff) - (b & 0x0fff) - c) & 0x1000)!=0 );
    setN( true );

    return(ans);
  }

  /** EXX */
  void exx() {
    int t;

    t = HL();
    HL( _HL_ );
    _HL_ = t;

    t = DE();
    DE( _DE_ );
    _DE_ = t;

    t = BC();
    BC( _BC_ );
    _BC_ = t;
  }

  private  int execute_ed( int local_tstates ) {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case 0:  /* NOP */
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:

    case 164:
    case 165:
    case 166:
    case 167:

    case 172:
    case 173:
    case 174:
    case 175:

    case 180:
    case 181:
    case 182:
    case 183:
    {
      return ( 8 );
    }

    /* IN r,(c) */
    case 64:  /* IN B,(c) */
    { B( in_bc() ); return ( 12 ); }
    case 72:  /* IN C,(c) */
    { C( in_bc() ); return ( 12 ); }
    case 80:  /* IN D,(c) */
    { D( in_bc() ); return ( 12 ); }
    case 88:  /* IN E,(c) */
    { E( in_bc() ); return ( 12 ); }
    case 96:  /* IN H,(c) */
    { H( in_bc() ); return ( 12 ); }
    case 104:  /* IN L,(c) */
    { L( in_bc() ); return ( 12 ); }
    case 112:  /* IN (c) */
    { in_bc(); return ( 12 ); }
    case 120:  /* IN A,(c) */
    { A( in_bc() ); return ( 12 ); }

    /* OUT (c),r */
    case 65:  /* OUT (c),B */
    { outb( BC(), B(), local_tstates ); return ( 12 ); }
    case 73:  /* OUT (c),C */
    { outb( BC(), C(), local_tstates ); return ( 12 ); }
    case 81:  /* OUT (c),D */
    { outb( BC(), D(), local_tstates ); return ( 12 ); }
    case 89:  /* OUT (c),E */
    { outb( BC(), E(), local_tstates ); return ( 12 ); }
    case 97:  /* OUT (c),H */
    { outb( BC(), H(), local_tstates ); return ( 12 ); }
    case 105:  /* OUT (c),L */
    { outb( BC(), L(), local_tstates ); return ( 12 ); }
    case 113:  /* OUT (c),0 */
    { outb( BC(), 0, local_tstates ); return ( 12 ); }
    case 121:  /* OUT (c),A */
    { outb( BC(), A(), local_tstates ); return ( 12 ); }

    /* SBC/ADC HL,ss */
    case 66:  /* SBC HL,BC */
    { HL( sbc16( HL(), BC() ) ); return ( 15 ); }
    case 74:  /* ADC HL,BC */
    { HL( adc16( HL(), BC() ) ); return ( 15 ); }
    case 82:  /* SBC HL,DE */
    { HL( sbc16( HL(), DE() ) ); return ( 15 ); }
    case 90:  /* ADC HL,DE */
    { HL( adc16( HL(), DE() ) ); return ( 15 ); }
    case 98:  /* SBC HL,HL */
    {
      int hl = HL();
      HL( sbc16( hl, hl ) );
      return ( 15 );
    }
    case 106:  /* ADC HL,HL */
    {
      int hl = HL();
      HL( adc16( hl, hl ) );
      return ( 15 );
    }
    case 114:  /* SBC HL,SP */
    { HL( sbc16( HL(), SP() ) ); return ( 15 ); }
    case 122:  /* ADC HL,SP */
    { HL( adc16( HL(), SP() ) ); return ( 15 ); }

    /* LD (nn),ss, LD ss,(nn) */
    case 67:  /* LD (nn),BC */
    { pokew( nxtpcw(), BC() ); return ( 20 ); }
    case 75:  /* LD BC(),(nn) */
    { BC( peekw( nxtpcw() ) ); return ( 20 ); }
    case 83:  /* LD (nn),DE */
    { pokew( nxtpcw(), DE() ); return ( 20 ); }
    case 91:  /* LD DE,(nn) */
    { DE( peekw( nxtpcw() ) ); return ( 20 ); }
    case 99:  /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); return ( 20 ); }
    case 107:  /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); return ( 20 ); }
    case 115:  /* LD (nn),SP */
    { pokew( nxtpcw(), SP() ); return ( 20 ); }
    case 123:  /* LD SP,(nn) */
    { SP( peekw( nxtpcw() ) ); return ( 20 ); }

    /* NEG */
    case 68:  /* NEG */
    case 76:  /* NEG */
    case 84:  /* NEG */
    case 92:  /* NEG */
    case 100:  /* NEG */
    case 108:  /* NEG */
    case 116:  /* NEG */
    case 124:  /* NEG */
    { neg_a(); return ( 8 ); }

    /* RETn */
    case 69:  /* RETN */
    case 85:  /* RETN */
    case 101:  /* RETN */
    case 117:  /* RETN */
    {
      IFF1( IFF2() );
      poppc();
      return ( 14 );
    }
    case 77:  /* RETI */
    case 93:  /* RETI */
    case 109:  /* RETI */
    case 125:  /* RETI */
    {
      poppc();
      return ( 14 );
    }

    /* IM x */
    case 70:  /* IM 0 */
    case 78:  /* IM 0 */
    case 102:  /* IM 0 */
    case 110:  /* IM 0 */
    { IM( IM0 ); return ( 8 ); }
    case 86:  /* IM 1 */
    case 118:  /* IM 1 */
    { IM( IM1 ); return ( 8 ); }
    case 94:  /* IM 2 */
    case 126:  /* IM 2 */
    { IM( IM2 ); return ( 8 ); }

    /* LD A,s / LD s,A / RxD */
    case 71:  /* LD I,A */
    { I( A() ); return ( 9 ); }
    case 79:  /* LD R,A */
    { R( A() ); return ( 9 ); }
    case 87:  /* LD A,I */
    { ld_a_i(); return ( 9 ); }
    case 95:  /* LD A,R */
    { ld_a_r(); return ( 9 ); }
    case 103:  /* RRD */
    { rrd_a(); return ( 18 ); }
    case 111:  /* RLD */
    { rld_a(); return ( 18 ); }

    /* xxI */
    case 160:  /* LDI */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( inc16( DE() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 161:  /* CPI */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 162:  /* INI */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 163:  /* OUTI */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxD */
    case 168:  /* LDD */
    {
      pokeb( DE(), peekb( HL() ) );
      DE( dec16( DE() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setH( false );
      setN( false );

      return ( 16 );
    }
    case 169:  /* CPD */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      setPV( BC() != 0 );
      setC( c );

      return ( 16 );
    }
    case 170:  /* IND */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }
    case 171:  /* OUTD */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( b == 0 );
      setN( true );

      return ( 16 );
    }

    /* xxIR */
    case 176:  /* LDIR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH( -2 );

      pokeb(dest, peekb(from) );
      from  = inc16( from );
      dest  = inc16( dest );
      count = dec16( count );

      _local_tstates += ( 21 );
      REFRESH( 2 );

      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 177:  /* CPIR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( inc16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 178:  /* INIR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 179:  /* OTIR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( inc16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    /* xxDR */
    case 184:  /* LDDR */
    {
      int _local_tstates = 0;
      int count, dest, from;

      count = BC();
      dest = DE();
      from = HL();
      REFRESH ( -2 );

      pokeb(dest, peekb(from));
      from  = dec16( from );
      dest  = dec16( dest );
      count = dec16( count );

      _local_tstates += ( 21 );
      REFRESH( 2 );

      if (count != 0) {
        PC( (PC()-2)&0xffff );
        setH( false );
        setN( false );
        setPV( true );
      }
      else {
        _local_tstates += ( -5 );
        setH( false );
        setN( false );
        setPV( false );
      }
      DE( dest );
      HL( from );
      BC( count );

      return ( _local_tstates );
    }
    case 185:  /* CPDR */
    {
      int    c = Cset();

      cp_a( peekb( HL() ) );
      HL( dec16( HL() ) );
      BC( dec16( BC() ) );

      int    pv = (BC() != 0);

      setPV( pv );
      setC( c );
      if ( pv && !Zset() ) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 186:  /* INDR */
    {
      int b;
      pokeb( HL(), inb( BC() ) );
      B( b = qdec8( B() ) );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }
    case 187:  /* OTDR */
    {
      int b;
      B( b = qdec8( B() ) );
      outb( BC(), peekb( HL() ), local_tstates );
      HL( dec16( HL() ) );

      setZ( true );
      setN( true );
      if (b != 0) {
        PC( (PC()-2)&0xffff );
        return ( 21 );
      }
      return ( 16 );
    }

    } // end switch

    // NOP
    return ( 8 );
  }

  private  int execute_cb() {
    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case   0: /* RLC B */
    { B( rlc( B() ) ); return ( 8 ); }
    case   1: /* RLC C */
    { C( rlc( C() ) ); return ( 8 ); }
    case   2: /* RLC D */
    { D( rlc( D() ) ); return ( 8 ); }
    case   3: /* RLC E */
    { E( rlc( E() ) ); return ( 8 ); }
    case   4: /* RLC H */
    { H( rlc( H() ) ); return ( 8 ); }
    case   5: /* RLC L */
    { L( rlc( L() ) ); return ( 8 ); }
    case   6: /* RLC (HL) */
    {
      int hl = HL();
      pokeb( hl, rlc( peekb( hl ) ) );
      return ( 15 );
    }
    case   7: /* RLC A */
    { A( rlc( A() ) ); return ( 8 ); }

    case   8: /* RRC B */
    { B( rrc( B() ) ); return ( 8 ); }
    case   9: /* RRC C */
    { C( rrc( C() ) ); return ( 8 ); }
    case  10: /* RRC D */
    { D( rrc( D() ) ); return ( 8 ); }
    case  11: /* RRC E */
    { E( rrc( E() ) ); return ( 8 ); }
    case  12: /* RRC H */
    { H( rrc( H() ) ); return ( 8 ); }
    case  13: /* RRC L */
    { L( rrc( L() ) ); return ( 8 ); }
    case  14: /* RRC (HL) */
    {
      int hl = HL();
      pokeb( hl, rrc( peekb( hl ) ) );
      return ( 15 );
    }
    case  15: /* RRC A */
    { A( rrc( A() ) ); return ( 8 ); }

    case  16: /* RL B */
    { B( rl( B() ) ); return ( 8 ); }
    case  17: /* RL C */
    { C( rl( C() ) ); return ( 8 ); }
    case  18: /* RL D */
    { D( rl( D() ) ); return ( 8 ); }
    case  19: /* RL E */
    { E( rl( E() ) ); return ( 8 ); }
    case  20: /* RL H */
    { H( rl( H() ) ); return ( 8 ); }
    case  21: /* RL L */
    { L( rl( L() ) ); return ( 8 ); }
    case  22: /* RL (HL) */
    {
      int hl = HL();
      pokeb( hl, rl( peekb( hl ) ) );
      return ( 15 );
    }
    case  23: /* RL A */
    { A( rl( A() ) ); return ( 8 ); }

    case  24: /* RR B */
    { B( rr( B() ) ); return ( 8 ); }
    case  25: /* RR C */
    { C( rr( C() ) ); return ( 8 ); }
    case  26: /* RR D */
    { D( rr( D() ) ); return ( 8 ); }
    case  27: /* RR E */
    { E( rr( E() ) ); return ( 8 ); }
    case  28: /* RR H */
    { H( rr( H() ) ); return ( 8 ); }
    case  29: /* RR L */
    { L( rr( L() ) ); return ( 8 ); }
    case  30: /* RR (HL) */
    {
      int hl = HL();
      pokeb( hl, rr( peekb( hl ) ) );
      return ( 15 );
    }
    case  31: /* RR A */
    { A( rr( A() ) ); return ( 8 ); }

    case  32: /* SLA B */
    { B( sla( B() ) ); return ( 8 ); }
    case  33: /* SLA C */
    { C( sla( C() ) ); return ( 8 ); }
    case  34: /* SLA D */
    { D( sla( D() ) ); return ( 8 ); }
    case  35: /* SLA E */
    { E( sla( E() ) ); return ( 8 ); }
    case  36: /* SLA H */
    { H( sla( H() ) ); return ( 8 ); }
    case  37: /* SLA L */
    { L( sla( L() ) ); return ( 8 ); }
    case  38: /* SLA (HL) */
    {
      int hl = HL();
      pokeb( hl, sla( peekb( hl ) ) );
      return ( 15 );
    }
    case  39: /* SLA A */
    { A( sla( A() ) ); return ( 8 ); }

    case  40: /* SRA B */
    { B( sra( B() ) ); return ( 8 ); }
    case  41: /* SRA C */
    { C( sra( C() ) ); return ( 8 ); }
    case  42: /* SRA D */
    { D( sra( D() ) ); return ( 8 ); }
    case  43: /* SRA E */
    { E( sra( E() ) ); return ( 8 ); }
    case  44: /* SRA H */
    { H( sra( H() ) ); return ( 8 ); }
    case  45: /* SRA L */
    { L( sra( L() ) ); return ( 8 ); }
    case  46: /* SRA (HL) */
    {
      int hl = HL();
      pokeb( hl, sra( peekb( hl ) ) );
      return ( 15 );
    }
    case  47: /* SRA A */
    { A( sra( A() ) ); return ( 8 ); }

    case  48: /* SLS B */
    { B( sls( B() ) ); return ( 8 ); }
    case  49: /* SLS C */
    { C( sls( C() ) ); return ( 8 ); }
    case  50: /* SLS D */
    { D( sls( D() ) ); return ( 8 ); }
    case  51: /* SLS E */
    { E( sls( E() ) ); return ( 8 ); }
    case  52: /* SLS H */
    { H( sls( H() ) ); return ( 8 ); }
    case  53: /* SLS L */
    { L( sls( L() ) ); return ( 8 ); }
    case  54: /* SLS (HL) */
    {
      int hl = HL();
      pokeb( hl, sls( peekb( hl ) ) );
      return ( 15 );
    }
    case  55: /* SLS A */
    { A( sls( A() ) ); return ( 8 ); }

    case  56: /* SRL B */
    { B( srl( B() ) ); return ( 8 ); }
    case  57: /* SRL C */
    { C( srl( C() ) ); return ( 8 ); }
    case  58: /* SRL D */
    { D( srl( D() ) ); return ( 8 ); }
    case  59: /* SRL E */
    { E( srl( E() ) ); return ( 8 ); }
    case  60: /* SRL H */
    { H( srl( H() ) ); return ( 8 ); }
    case  61: /* SRL L */
    { L( srl( L() ) ); return ( 8 ); }
    case  62: /* SRL (HL) */
    {
      int hl = HL();
      pokeb( hl, srl( peekb( hl ) ) );
      return ( 15 );
    }
    case  63: /* SRL A */
    { A( srl( A() ) ); return ( 8 ); }

    case  64: /* BIT 0,B */
    { bit( 0x01, B() ); return ( 8 ); }
    case  65: /* BIT 0,C */
    { bit( 0x01, C() ); return ( 8 ); }
    case  66: /* BIT 0,D */
    { bit( 0x01, D() ); return ( 8 ); }
    case  67: /* BIT 0,E */
    { bit( 0x01, E() ); return ( 8 ); }
    case  68: /* BIT 0,H */
    { bit( 0x01, H() ); return ( 8 ); }
    case  69: /* BIT 0,L */
    { bit( 0x01, L() ); return ( 8 ); }
    case  70: /* BIT 0,(HL) */
    { bit( 0x01, peekb( HL() ) ); return ( 12 ); }
    case  71: /* BIT 0,A */
    { bit( 0x01, A() ); return ( 8 ); }

    case  72: /* BIT 1,B */
    { bit( 0x02, B() ); return ( 8 ); }
    case  73: /* BIT 1,C */
    { bit( 0x02, C() ); return ( 8 ); }
    case  74: /* BIT 1,D */
    { bit( 0x02, D() ); return ( 8 ); }
    case  75: /* BIT 1,E */
    { bit( 0x02, E() ); return ( 8 ); }
    case  76: /* BIT 1,H */
    { bit( 0x02, H() ); return ( 8 ); }
    case  77: /* BIT 1,L */
    { bit( 0x02, L() ); return ( 8 ); }
    case  78: /* BIT 1,(HL) */
    { bit( 0x02, peekb( HL() ) ); return ( 12 ); }
    case  79: /* BIT 1,A */
    { bit( 0x02, A() ); return ( 8 ); }

    case  80: /* BIT 2,B */
    { bit( 0x04, B() ); return ( 8 ); }
    case  81: /* BIT 2,C */
    { bit( 0x04, C() ); return ( 8 ); }
    case  82: /* BIT 2,D */
    { bit( 0x04, D() ); return ( 8 ); }
    case  83: /* BIT 2,E */
    { bit( 0x04, E() ); return ( 8 ); }
    case  84: /* BIT 2,H */
    { bit( 0x04, H() ); return ( 8 ); }
    case  85: /* BIT 2,L */
    { bit( 0x04, L() ); return ( 8 ); }
    case  86: /* BIT 2,(HL) */
    { bit( 0x04, peekb( HL() ) ); return ( 12 ); }
    case  87: /* BIT 2,A */
    { bit( 0x04, A() ); return ( 8 ); }

    case  88: /* BIT 3,B */
    { bit( 0x08, B() ); return ( 8 ); }
    case  89: /* BIT 3,C */
    { bit( 0x08, C() ); return ( 8 ); }
    case  90: /* BIT 3,D */
    { bit( 0x08, D() ); return ( 8 ); }
    case  91: /* BIT 3,E */
    { bit( 0x08, E() ); return ( 8 ); }
    case  92: /* BIT 3,H */
    { bit( 0x08, H() ); return ( 8 ); }
    case  93: /* BIT 3,L */
    { bit( 0x08, L() ); return ( 8 ); }
    case  94: /* BIT 3,(HL) */
    { bit( 0x08, peekb( HL() ) ); return ( 12 ); }
    case  95: /* BIT 3,A */
    { bit( 0x08, A() ); return ( 8 ); }

    case  96: /* BIT 4,B */
    { bit( 0x10, B() ); return ( 8 ); }
    case  97: /* BIT 4,C */
    { bit( 0x10, C() ); return ( 8 ); }
    case  98: /* BIT 4,D */
    { bit( 0x10, D() ); return ( 8 ); }
    case  99: /* BIT 4,E */
    { bit( 0x10, E() ); return ( 8 ); }
    case 100: /* BIT 4,H */
    { bit( 0x10, H() ); return ( 8 ); }
    case 101: /* BIT 4,L */
    { bit( 0x10, L() ); return ( 8 ); }
    case 102: /* BIT 4,(HL) */
    { bit( 0x10, peekb( HL() ) ); return ( 12 ); }
    case 103: /* BIT 4,A */
    { bit( 0x10, A() ); return ( 8 ); }

    case 104: /* BIT 5,B */
    { bit( 0x20, B() ); return ( 8 ); }
    case 105: /* BIT 5,C */
    { bit( 0x20, C() ); return ( 8 ); }
    case 106: /* BIT 5,D */
    { bit( 0x20, D() ); return ( 8 ); }
    case 107: /* BIT 5,E */
    { bit( 0x20, E() ); return ( 8 ); }
    case 108: /* BIT 5,H */
    { bit( 0x20, H() ); return ( 8 ); }
    case 109: /* BIT 5,L */
    { bit( 0x20, L() ); return ( 8 ); }
    case 110: /* BIT 5,(HL) */
    { bit( 0x20, peekb( HL() ) ); return ( 12 ); }
    case 111: /* BIT 5,A */
    { bit( 0x20, A() ); return ( 8 ); }

    case 112: /* BIT 6,B */
    { bit( 0x40, B() ); return ( 8 ); }
    case 113: /* BIT 6,C */
    { bit( 0x40, C() ); return ( 8 ); }
    case 114: /* BIT 6,D */
    { bit( 0x40, D() ); return ( 8 ); }
    case 115: /* BIT 6,E */
    { bit( 0x40, E() ); return ( 8 ); }
    case 116: /* BIT 6,H */
    { bit( 0x40, H() ); return ( 8 ); }
    case 117: /* BIT 6,L */
    { bit( 0x40, L() ); return ( 8 ); }
    case 118: /* BIT 6,(HL) */
    { bit( 0x40, peekb( HL() ) ); return ( 12 ); }
    case 119: /* BIT 6,A */
    { bit( 0x40, A() ); return ( 8 ); }

    case 120: /* BIT 7,B */
    { bit( 0x80, B() ); return ( 8 ); }
    case 121: /* BIT 7,C */
    { bit( 0x80, C() ); return ( 8 ); }
    case 122: /* BIT 7,D */
    { bit( 0x80, D() ); return ( 8 ); }
    case 123: /* BIT 7,E */
    { bit( 0x80, E() ); return ( 8 ); }
    case 124: /* BIT 7,H */
    { bit( 0x80, H() ); return ( 8 ); }
    case 125: /* BIT 7,L */
    { bit( 0x80, L() ); return ( 8 ); }
    case 126: /* BIT 7,(HL) */
    { bit( 0x80, peekb( HL() ) ); return ( 12 ); }
    case 127: /* BIT 7,A */
    { bit( 0x80, A() ); return ( 8 ); }

    case 128: /* RES 0,B */
    { B( res( 0x01, B() ) ); return ( 8 ); }
    case 129: /* RES 0,C */
    { C( res( 0x01, C() ) ); return ( 8 ); }
    case 130: /* RES 0,D */
    { D( res( 0x01, D() ) ); return ( 8 ); }
    case 131: /* RES 0,E */
    { E( res( 0x01, E() ) ); return ( 8 ); }
    case 132: /* RES 0,H */
    { H( res( 0x01, H() ) ); return ( 8 ); }
    case 133: /* RES 0,L */
    { L( res( 0x01, L() ) ); return ( 8 ); }
    case 134: /* RES 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 135: /* RES 0,A */
    { A( res( 0x01, A() ) ); return ( 8 ); }

    case 136: /* RES 1,B */
    { B( res( 0x02, B() ) ); return ( 8 ); }
    case 137: /* RES 1,C */
    { C( res( 0x02, C() ) ); return ( 8 ); }
    case 138: /* RES 1,D */
    { D( res( 0x02, D() ) ); return ( 8 ); }
    case 139: /* RES 1,E */
    { E( res( 0x02, E() ) ); return ( 8 ); }
    case 140: /* RES 1,H */
    { H( res( 0x02, H() ) ); return ( 8 ); }
    case 141: /* RES 1,L */
    { L( res( 0x02, L() ) ); return ( 8 ); }
    case 142: /* RES 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 143: /* RES 1,A */
    { A( res( 0x02, A() ) ); return ( 8 ); }

    case 144: /* RES 2,B */
    { B( res( 0x04, B() ) ); return ( 8 ); }
    case 145: /* RES 2,C */
    { C( res( 0x04, C() ) ); return ( 8 ); }
    case 146: /* RES 2,D */
    { D( res( 0x04, D() ) ); return ( 8 ); }
    case 147: /* RES 2,E */
    { E( res( 0x04, E() ) ); return ( 8 ); }
    case 148: /* RES 2,H */
    { H( res( 0x04, H() ) ); return ( 8 ); }
    case 149: /* RES 2,L */
    { L( res( 0x04, L() ) ); return ( 8 ); }
    case 150: /* RES 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 151: /* RES 2,A */
    { A( res( 0x04, A() ) ); return ( 8 ); }

    case 152: /* RES 3,B */
    { B( res( 0x08, B() ) ); return ( 8 ); }
    case 153: /* RES 3,C */
    { C( res( 0x08, C() ) ); return ( 8 ); }
    case 154: /* RES 3,D */
    { D( res( 0x08, D() ) ); return ( 8 ); }
    case 155: /* RES 3,E */
    { E( res( 0x08, E() ) ); return ( 8 ); }
    case 156: /* RES 3,H */
    { H( res( 0x08, H() ) ); return ( 8 ); }
    case 157: /* RES 3,L */
    { L( res( 0x08, L() ) ); return ( 8 ); }
    case 158: /* RES 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 159: /* RES 3,A */
    { A( res( 0x08, A() ) ); return ( 8 ); }

    case 160: /* RES 4,B */
    { B( res( 0x10, B() ) ); return ( 8 ); }
    case 161: /* RES 4,C */
    { C( res( 0x10, C() ) ); return ( 8 ); }
    case 162: /* RES 4,D */
    { D( res( 0x10, D() ) ); return ( 8 ); }
    case 163: /* RES 4,E */
    { E( res( 0x10, E() ) ); return ( 8 ); }
    case 164: /* RES 4,H */
    { H( res( 0x10, H() ) ); return ( 8 ); }
    case 165: /* RES 4,L */
    { L( res( 0x10, L() ) ); return ( 8 ); }
    case 166: /* RES 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 167: /* RES 4,A */
    { A( res( 0x10, A() ) ); return ( 8 ); }

    case 168: /* RES 5,B */
    { B( res( 0x20, B() ) ); return ( 8 ); }
    case 169: /* RES 5,C */
    { C( res( 0x20, C() ) ); return ( 8 ); }
    case 170: /* RES 5,D */
    { D( res( 0x20, D() ) ); return ( 8 ); }
    case 171: /* RES 5,E */
    { E( res( 0x20, E() ) ); return ( 8 ); }
    case 172: /* RES 5,H */
    { H( res( 0x20, H() ) ); return ( 8 ); }
    case 173: /* RES 5,L */
    { L( res( 0x20, L() ) ); return ( 8 ); }
    case 174: /* RES 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 175: /* RES 5,A */
    { A( res( 0x20, A() ) ); return ( 8 ); }

    case 176: /* RES 6,B */
    { B( res( 0x40, B() ) ); return ( 8 ); }
    case 177: /* RES 6,C */
    { C( res( 0x40, C() ) ); return ( 8 ); }
    case 178: /* RES 6,D */
    { D( res( 0x40, D() ) ); return ( 8 ); }
    case 179: /* RES 6,E */
    { E( res( 0x40, E() ) ); return ( 8 ); }
    case 180: /* RES 6,H */
    { H( res( 0x40, H() ) ); return ( 8 ); }
    case 181: /* RES 6,L */
    { L( res( 0x40, L() ) ); return ( 8 ); }
    case 182: /* RES 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 183: /* RES 6,A */
    { A( res( 0x40, A() ) ); return ( 8 ); }

    case 184: /* RES 7,B */
    { B( res( 0x80, B() ) ); return ( 8 ); }
    case 185: /* RES 7,C */
    { C( res( 0x80, C() ) ); return ( 8 ); }
    case 186: /* RES 7,D */
    { D( res( 0x80, D() ) ); return ( 8 ); }
    case 187: /* RES 7,E */
    { E( res( 0x80, E() ) ); return ( 8 ); }
    case 188: /* RES 7,H */
    { H( res( 0x80, H() ) ); return ( 8 ); }
    case 189: /* RES 7,L */
    { L( res( 0x80, L() ) ); return ( 8 ); }
    case 190: /* RES 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, res( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 191: /* RES 7,A */
    { A( res( 0x80, A() ) ); return ( 8 ); }

    case 192: /* SET 0,B */
    { B( set( 0x01, B() ) ); return ( 8 ); }
    case 193: /* SET 0,C */
    { C( set( 0x01, C() ) ); return ( 8 ); }
    case 194: /* SET 0,D */
    { D( set( 0x01, D() ) ); return ( 8 ); }
    case 195: /* SET 0,E */
    { E( set( 0x01, E() ) ); return ( 8 ); }
    case 196: /* SET 0,H */
    { H( set( 0x01, H() ) ); return ( 8 ); }
    case 197: /* SET 0,L */
    { L( set( 0x01, L() ) ); return ( 8 ); }
    case 198: /* SET 0,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x01, peekb( hl ) ) );
      return ( 15 );
    }
    case 199: /* SET 0,A */
    { A( set( 0x01, A() ) ); return ( 8 ); }

    case 200: /* SET 1,B */
    { B( set( 0x02, B() ) ); return ( 8 ); }
    case 201: /* SET 1,C */
    { C( set( 0x02, C() ) ); return ( 8 ); }
    case 202: /* SET 1,D */
    { D( set( 0x02, D() ) ); return ( 8 ); }
    case 203: /* SET 1,E */
    { E( set( 0x02, E() ) ); return ( 8 ); }
    case 204: /* SET 1,H */
    { H( set( 0x02, H() ) ); return ( 8 ); }
    case 205: /* SET 1,L */
    { L( set( 0x02, L() ) ); return ( 8 ); }
    case 206: /* SET 1,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x02, peekb( hl ) ) );
      return ( 15 );
    }
    case 207: /* SET 1,A */
    { A( set( 0x02, A() ) ); return ( 8 ); }

    case 208: /* SET 2,B */
    { B( set( 0x04, B() ) ); return ( 8 ); }
    case 209: /* SET 2,C */
    { C( set( 0x04, C() ) ); return ( 8 ); }
    case 210: /* SET 2,D */
    { D( set( 0x04, D() ) ); return ( 8 ); }
    case 211: /* SET 2,E */
    { E( set( 0x04, E() ) ); return ( 8 ); }
    case 212: /* SET 2,H */
    { H( set( 0x04, H() ) ); return ( 8 ); }
    case 213: /* SET 2,L */
    { L( set( 0x04, L() ) ); return ( 8 ); }
    case 214: /* SET 2,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x04, peekb( hl ) ) );
      return ( 15 );
    }
    case 215: /* SET 2,A */
    { A( set( 0x04, A() ) ); return ( 8 ); }

    case 216: /* SET 3,B */
    { B( set( 0x08, B() ) ); return ( 8 ); }
    case 217: /* SET 3,C */
    { C( set( 0x08, C() ) ); return ( 8 ); }
    case 218: /* SET 3,D */
    { D( set( 0x08, D() ) ); return ( 8 ); }
    case 219: /* SET 3,E */
    { E( set( 0x08, E() ) ); return ( 8 ); }
    case 220: /* SET 3,H */
    { H( set( 0x08, H() ) ); return ( 8 ); }
    case 221: /* SET 3,L */
    { L( set( 0x08, L() ) ); return ( 8 ); }
    case 222: /* SET 3,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x08, peekb( hl ) ) );
      return ( 15 );
    }
    case 223: /* SET 3,A */
    { A( set( 0x08, A() ) ); return ( 8 ); }

    case 224: /* SET 4,B */
    { B( set( 0x10, B() ) ); return ( 8 ); }
    case 225: /* SET 4,C */
    { C( set( 0x10, C() ) ); return ( 8 ); }
    case 226: /* SET 4,D */
    { D( set( 0x10, D() ) ); return ( 8 ); }
    case 227: /* SET 4,E */
    { E( set( 0x10, E() ) ); return ( 8 ); }
    case 228: /* SET 4,H */
    { H( set( 0x10, H() ) ); return ( 8 ); }
    case 229: /* SET 4,L */
    { L( set( 0x10, L() ) ); return ( 8 ); }
    case 230: /* SET 4,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x10, peekb( hl ) ) );
      return ( 15 );
    }
    case 231: /* SET 4,A */
    { A( set( 0x10, A() ) ); return ( 8 ); }

    case 232: /* SET 5,B */
    { B( set( 0x20, B() ) ); return ( 8 ); }
    case 233: /* SET 5,C */
    { C( set( 0x20, C() ) ); return ( 8 ); }
    case 234: /* SET 5,D */
    { D( set( 0x20, D() ) ); return ( 8 ); }
    case 235: /* SET 5,E */
    { E( set( 0x20, E() ) ); return ( 8 ); }
    case 236: /* SET 5,H */
    { H( set( 0x20, H() ) ); return ( 8 ); }
    case 237: /* SET 5,L */
    { L( set( 0x20, L() ) ); return ( 8 ); }
    case 238: /* SET 5,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x20, peekb( hl ) ) );
      return ( 15 );
    }
    case 239: /* SET 5,A */
    { A( set( 0x20, A() ) ); return ( 8 ); }

    case 240: /* SET 6,B */
    { B( set( 0x40, B() ) ); return ( 8 ); }
    case 241: /* SET 6,C */
    { C( set( 0x40, C() ) ); return ( 8 ); }
    case 242: /* SET 6,D */
    { D( set( 0x40, D() ) ); return ( 8 ); }
    case 243: /* SET 6,E */
    { E( set( 0x40, E() ) ); return ( 8 ); }
    case 244: /* SET 6,H */
    { H( set( 0x40, H() ) ); return ( 8 ); }
    case 245: /* SET 6,L */
    { L( set( 0x40, L() ) ); return ( 8 ); }
    case 246: /* SET 6,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x40, peekb( hl ) ) );
      return ( 15 );
    }
    case 247: /* SET 6,A */
    { A( set( 0x40, A() ) ); return ( 8 ); }

    case 248: /* SET 7,B */
    { B( set( 0x80, B() ) ); return ( 8 ); }
    case 249: /* SET 7,C */
    { C( set( 0x80, C() ) ); return ( 8 ); }
    case 250: /* SET 7,D */
    { D( set( 0x80, D() ) ); return ( 8 ); }
    case 251: /* SET 7,E */
    { E( set( 0x80, E() ) ); return ( 8 ); }
    case 252: /* SET 7,H */
    { H( set( 0x80, H() ) ); return ( 8 ); }
    case 253: /* SET 7,L */
    { L( set( 0x80, L() ) ); return ( 8 ); }
    case 254: /* SET 7,(HL) */
    {
      int hl = HL();
      pokeb( hl, set( 0x80, peekb( hl ) ) );
      return ( 15 );
    }
    case 255: /* SET 7,A */
    { A( set( 0x80, A() ) ); return ( 8 ); }

    } // end switch

    return 0;
  }

  private  void execute_id_cb(int op, int z) {

    switch ( op ) {

    case   0: /* RLC B */
    { B( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   1: /* RLC C */
    { C( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   2: /* RLC D */
    { D( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   3: /* RLC E */
    { E( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   4: /* RLC H */
    { H( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   5: /* RLC L */
    { L( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   6: /* RLC (HL) */
    { pokeb( z, rlc( peekb( z ) ) ); return; }
    case   7: /* RLC A */
    { A( op = rlc( peekb( z ) ) ); pokeb( z, op ); return; }

    case   8: /* RRC B */
    { B( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case   9: /* RRC C */
    { C( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  10: /* RRC D */
    { D( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  11: /* RRC E */
    { E( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  12: /* RRC H */
    { H( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  13: /* RRC L */
    { L( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }
    case  14: /* RRC (HL) */
    { pokeb( z, rrc( peekb( z ) ) ); return; }
    case  15: /* RRC A */
    { A( op = rrc( peekb( z ) ) ); pokeb( z, op ); return; }

    case  16: /* RL B */
    { B( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  17: /* RL C */
    { C( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  18: /* RL D */
    { D( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  19: /* RL E */
    { E( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  20: /* RL H */
    { H( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  21: /* RL L */
    { L( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  22: /* RL (HL) */
    { pokeb( z, rl( peekb( z ) ) ); return; }
    case  23: /* RL A */
    { A( op = rl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  24: /* RR B */
    { B( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  25: /* RR C */
    { C( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  26: /* RR D */
    { D( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  27: /* RR E */
    { E( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  28: /* RR H */
    { H( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  29: /* RR L */
    { L( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }
    case  30: /* RR (HL) */
    { pokeb( z, rr( peekb( z ) ) ); return; }
    case  31: /* RR A */
    { A( op = rr( peekb( z ) ) ); pokeb( z, op ); return; }

    case  32: /* SLA B */
    { B( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  33: /* SLA C */
    { C( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  34: /* SLA D */
    { D( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  35: /* SLA E */
    { E( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  36: /* SLA H */
    { H( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  37: /* SLA L */
    { L( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }
    case  38: /* SLA (HL) */
    { pokeb( z, sla( peekb( z ) ) ); return; }
    case  39: /* SLA A */
    { A( op = sla( peekb( z ) ) ); pokeb( z, op ); return; }

    case  40: /* SRA B */
    { B( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  41: /* SRA C */
    { C( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  42: /* SRA D */
    { D( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  43: /* SRA E */
    { E( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  44: /* SRA H */
    { H( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  45: /* SRA L */
    { L( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }
    case  46: /* SRA (HL) */
    { pokeb( z, sra( peekb( z ) ) ); return; }
    case  47: /* SRA A */
    { A( op = sra( peekb( z ) ) ); pokeb( z, op ); return; }

    case  48: /* SLS B */
    { B( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  49: /* SLS C */
    { C( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  50: /* SLS D */
    { D( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  51: /* SLS E */
    { E( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  52: /* SLS H */
    { H( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  53: /* SLS L */
    { L( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }
    case  54: /* SLS (HL) */
    { pokeb( z, sls( peekb( z ) ) ); return; }
    case  55: /* SLS A */
    { A( op = sls( peekb( z ) ) ); pokeb( z, op ); return; }

    case  56: /* SRL B */
    { B( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  57: /* SRL C */
    { C( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  58: /* SRL D */
    { D( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  59: /* SRL E */
    { E( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  60: /* SRL H */
    { H( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  61: /* SRL L */
    { L( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }
    case  62: /* SRL (HL) */
    { pokeb( z, srl( peekb( z ) ) ); return; }
    case  63: /* SRL A */
    { A( op = srl( peekb( z ) ) ); pokeb( z, op ); return; }

    case  64: /* BIT 0,B */
    case  65: /* BIT 0,B */
    case  66: /* BIT 0,B */
    case  67: /* BIT 0,B */
    case  68: /* BIT 0,B */
    case  69: /* BIT 0,B */
    case  70: /* BIT 0,B */
    case  71: /* BIT 0,B */
    { bit( 0x01, peekb( z ) ); return; }

    case  72: /* BIT 1,B */
    case  73: /* BIT 1,B */
    case  74: /* BIT 1,B */
    case  75: /* BIT 1,B */
    case  76: /* BIT 1,B */
    case  77: /* BIT 1,B */
    case  78: /* BIT 1,B */
    case  79: /* BIT 1,B */
    { bit( 0x02, peekb( z ) ); return; }

    case  80: /* BIT 2,B */
    case  81: /* BIT 2,B */
    case  82: /* BIT 2,B */
    case  83: /* BIT 2,B */
    case  84: /* BIT 2,B */
    case  85: /* BIT 2,B */
    case  86: /* BIT 2,B */
    case  87: /* BIT 2,B */
    { bit( 0x04, peekb( z ) ); return; }

    case  88: /* BIT 3,B */
    case  89: /* BIT 3,B */
    case  90: /* BIT 3,B */
    case  91: /* BIT 3,B */
    case  92: /* BIT 3,B */
    case  93: /* BIT 3,B */
    case  94: /* BIT 3,B */
    case  95: /* BIT 3,B */
    { bit( 0x08, peekb( z ) ); return; }

    case  96: /* BIT 4,B */
    case  97: /* BIT 4,B */
    case  98: /* BIT 4,B */
    case  99: /* BIT 4,B */
    case 100: /* BIT 4,B */
    case 101: /* BIT 4,B */
    case 102: /* BIT 4,B */
    case 103: /* BIT 4,B */
    { bit( 0x10, peekb( z ) ); return; }

    case 104: /* BIT 5,B */
    case 105: /* BIT 5,B */
    case 106: /* BIT 5,B */
    case 107: /* BIT 5,B */
    case 108: /* BIT 5,B */
    case 109: /* BIT 5,B */
    case 110: /* BIT 5,B */
    case 111: /* BIT 5,B */
    { bit( 0x20, peekb( z ) ); return; }

    case 112: /* BIT 6,B */
    case 113: /* BIT 6,B */
    case 114: /* BIT 6,B */
    case 115: /* BIT 6,B */
    case 116: /* BIT 6,B */
    case 117: /* BIT 6,B */
    case 118: /* BIT 6,B */
    case 119: /* BIT 6,B */
    { bit( 0x40, peekb( z ) ); return; }

    case 120: /* BIT 7,B */
    case 121: /* BIT 7,B */
    case 122: /* BIT 7,B */
    case 123: /* BIT 7,B */
    case 124: /* BIT 7,B */
    case 125: /* BIT 7,B */
    case 126: /* BIT 7,B */
    case 127: /* BIT 7,B */
    { bit( 0x80, peekb( z ) ); return; }

    case 128: /* RES 0,B */
    { B( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 129: /* RES 0,C */
    { C( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 130: /* RES 0,D */
    { D( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 131: /* RES 0,E */
    { E( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 132: /* RES 0,H */
    { H( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 133: /* RES 0,L */
    { L( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 134: /* RES 0,(HL) */
    { pokeb( z, res( 0x01, peekb( z ) ) ); return; }
    case 135: /* RES 0,A */
    { A( op = res( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 136: /* RES 1,B */
    { B( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 137: /* RES 1,C */
    { C( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 138: /* RES 1,D */
    { D( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 139: /* RES 1,E */
    { E( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 140: /* RES 1,H */
    { H( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 141: /* RES 1,L */
    { L( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 142: /* RES 1,(HL) */
    { pokeb( z, res( 0x02, peekb( z ) ) ); return; }
    case 143: /* RES 1,A */
    { A( op = res( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 144: /* RES 2,B */
    { B( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 145: /* RES 2,C */
    { C( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 146: /* RES 2,D */
    { D( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 147: /* RES 2,E */
    { E( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 148: /* RES 2,H */
    { H( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 149: /* RES 2,L */
    { L( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 150: /* RES 2,(HL) */
    { pokeb( z, res( 0x04, peekb( z ) ) ); return; }
    case 151: /* RES 2,A */
    { A( op = res( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 152: /* RES 3,B */
    { B( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 153: /* RES 3,C */
    { C( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 154: /* RES 3,D */
    { D( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 155: /* RES 3,E */
    { E( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 156: /* RES 3,H */
    { H( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 157: /* RES 3,L */
    { L( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 158: /* RES 3,(HL) */
    { pokeb( z, res( 0x08, peekb( z ) ) ); return; }
    case 159: /* RES 3,A */
    { A( op = res( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 160: /* RES 4,B */
    { B( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 161: /* RES 4,C */
    { C( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 162: /* RES 4,D */
    { D( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 163: /* RES 4,E */
    { E( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 164: /* RES 4,H */
    { H( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 165: /* RES 4,L */
    { L( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 166: /* RES 4,(HL) */
    { pokeb( z, res( 0x10, peekb( z ) ) ); return; }
    case 167: /* RES 4,A */
    { A( op = res( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 168: /* RES 5,B */
    { B( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 169: /* RES 5,C */
    { C( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 170: /* RES 5,D */
    { D( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 171: /* RES 5,E */
    { E( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 172: /* RES 5,H */
    { H( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 173: /* RES 5,L */
    { L( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 174: /* RES 5,(HL) */
    { pokeb( z, res( 0x20, peekb( z ) ) ); return; }
    case 175: /* RES 5,A */
    { A( op = res( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 176: /* RES 6,B */
    { B( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 177: /* RES 6,C */
    { C( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 178: /* RES 6,D */
    { D( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 179: /* RES 6,E */
    { E( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 180: /* RES 6,H */
    { H( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 181: /* RES 6,L */
    { L( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 182: /* RES 6,(HL) */
    { pokeb( z, res( 0x40, peekb( z ) ) ); return; }
    case 183: /* RES 6,A */
    { A( op = res( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 184: /* RES 7,B */
    { B( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 185: /* RES 7,C */
    { C( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 186: /* RES 7,D */
    { D( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 187: /* RES 7,E */
    { E( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 188: /* RES 7,H */
    { H( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 189: /* RES 7,L */
    { L( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 190: /* RES 7,(HL) */
    { pokeb( z, res( 0x80, peekb( z ) ) ); return; }
    case 191: /* RES 7,A */
    { A( op = res( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    case 192: /* SET 0,B */
    { B( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 193: /* SET 0,C */
    { C( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 194: /* SET 0,D */
    { D( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 195: /* SET 0,E */
    { E( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 196: /* SET 0,H */
    { H( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 197: /* SET 0,L */
    { L( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }
    case 198: /* SET 0,(HL) */
    { pokeb( z, set( 0x01, peekb( z ) ) ); return; }
    case 199: /* SET 0,A */
    { A( op = set( 0x01, peekb( z ) ) ); pokeb( z, op ); return; }

    case 200: /* SET 1,B */
    { B( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 201: /* SET 1,C */
    { C( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 202: /* SET 1,D */
    { D( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 203: /* SET 1,E */
    { E( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 204: /* SET 1,H */
    { H( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 205: /* SET 1,L */
    { L( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }
    case 206: /* SET 1,(HL) */
    { pokeb( z, set( 0x02, peekb( z ) ) ); return; }
    case 207: /* SET 1,A */
    { A( op = set( 0x02, peekb( z ) ) ); pokeb( z, op ); return; }

    case 208: /* SET 2,B */
    { B( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 209: /* SET 2,C */
    { C( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 210: /* SET 2,D */
    { D( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 211: /* SET 2,E */
    { E( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 212: /* SET 2,H */
    { H( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 213: /* SET 2,L */
    { L( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }
    case 214: /* SET 2,(HL) */
    { pokeb( z, set( 0x04, peekb( z ) ) ); return; }
    case 215: /* SET 2,A */
    { A( op = set( 0x04, peekb( z ) ) ); pokeb( z, op ); return; }

    case 216: /* SET 3,B */
    { B( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 217: /* SET 3,C */
    { C( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 218: /* SET 3,D */
    { D( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 219: /* SET 3,E */
    { E( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 220: /* SET 3,H */
    { H( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 221: /* SET 3,L */
    { L( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }
    case 222: /* SET 3,(HL) */
    { pokeb( z, set( 0x08, peekb( z ) ) ); return; }
    case 223: /* SET 3,A */
    { A( op = set( 0x08, peekb( z ) ) ); pokeb( z, op ); return; }

    case 224: /* SET 4,B */
    { B( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 225: /* SET 4,C */
    { C( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 226: /* SET 4,D */
    { D( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 227: /* SET 4,E */
    { E( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 228: /* SET 4,H */
    { H( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 229: /* SET 4,L */
    { L( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }
    case 230: /* SET 4,(HL) */
    { pokeb( z, set( 0x10, peekb( z ) ) ); return; }
    case 231: /* SET 4,A */
    { A( op = set( 0x10, peekb( z ) ) ); pokeb( z, op ); return; }

    case 232: /* SET 5,B */
    { B( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 233: /* SET 5,C */
    { C( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 234: /* SET 5,D */
    { D( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 235: /* SET 5,E */
    { E( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 236: /* SET 5,H */
    { H( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 237: /* SET 5,L */
    { L( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }
    case 238: /* SET 5,(HL) */
    { pokeb( z, set( 0x20, peekb( z ) ) ); return; }
    case 239: /* SET 5,A */
    { A( op = set( 0x20, peekb( z ) ) ); pokeb( z, op ); return; }

    case 240: /* SET 6,B */
    { B( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 241: /* SET 6,C */
    { C( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 242: /* SET 6,D */
    { D( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 243: /* SET 6,E */
    { E( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 244: /* SET 6,H */
    { H( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 245: /* SET 6,L */
    { L( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }
    case 246: /* SET 6,(HL) */
    { pokeb( z, set( 0x40, peekb( z ) ) ); return; }
    case 247: /* SET 6,A */
    { A( op = set( 0x40, peekb( z ) ) ); pokeb( z, op ); return; }

    case 248: /* SET 7,B */
    { B( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 249: /* SET 7,C */
    { C( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 250: /* SET 7,D */
    { D( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 251: /* SET 7,E */
    { E( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 252: /* SET 7,H */
    { H( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 253: /* SET 7,L */
    { L( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }
    case 254: /* SET 7,(HL) */
    { pokeb( z, set( 0x80, peekb( z ) ) ); return; }
    case 255: /* SET 7,A */
    { A( op = set( 0x80, peekb( z ) ) ); pokeb( z, op ); return; }

    } // end switch
  }

  private  int execute_id() {

    REFRESH( 1 );

    switch ( nxtpcb() ) {

    case  0: /* NOP */
    case  1:
    case  2:
    case  3:
    case  4:
    case  5:
    case  6:
    case  7:
    case  8:

    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:

    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:

    case 39:
    case 40:

    case 47:
    case 48:
    case 49:
    case 50:
    case 51:

    case 55:
    case 56:

    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:

    case 71:
    case 72:
    case 73:
    case 74:
    case 75:

    case 79:
    case 80:
    case 81:
    case 82:
    case 83:

    case 87:
    case 88:
    case 89:
    case 90:
    case 91:

    case 95:

    case 120:
    case 121:
    case 122:
    case 123:

    case 127:
    case 128:
    case 129:
    case 130:
    case 131:

    case 135:
    case 136:
    case 137:
    case 138:
    case 139:

    case 143:
    case 144:
    case 145:
    case 146:
    case 147:

    case 151:
    case 152:
    case 153:
    case 154:
    case 155:

    case 159:
    case 160:
    case 161:
    case 162:
    case 163:

    case 167:
    case 168:
    case 169:
    case 170:
    case 171:

    case 175:
    case 176:
    case 177:
    case 178:
    case 179:

    case 183:
    case 184:
    case 185:
    case 186:
    case 187:

    case 191:
    case 192:
    case 193:
    case 194:
    case 195:
    case 196:
    case 197:
    case 198:
    case 199:
    case 200:
    case 201:
    case 202:

    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 219:
    case 220:
    case 221:
    case 222:
    case 223:
    case 224:

    case 226:

    case 228:

    case 230:
    case 231:
    case 232:

    case 234:
    case 235:
    case 236:
    case 237:
    case 238:
    case 239:
    case 240:
    case 241:
    case 242:
    case 243:
    case 244:
    case 245:
    case 246:
    case 247:
    case 248:
    {
      PC( dec16( PC() ) );
      REFRESH( -1 );
      return ( 4 );
    }

    case  9: /* ADD ID,BC */
    { ID( add16( ID(), BC() ) ); return ( 15 ); }
    case 25: /* ADD ID,DE */
    { ID( add16( ID(), DE() ) ); return ( 15 ); }
    case 41: /* ADD ID,ID */
    {
      int id = ID();
      ID( add16( id, id ) );
      return ( 15 );
    }
    case 57: /* ADD ID,SP */
    { ID( add16( ID(),SP() ) ); return ( 15 ); }

    case 33: /* LD ID,nn */
    { ID( nxtpcw() ); return ( 14 ); }
    case 34: /* LD (nn),ID */
    { pokew( nxtpcw(), ID() ); return ( 20 ); }
    case 42: /* LD ID,(nn) */
    { ID( peekw( nxtpcw() ) ); return ( 20 ); }
    case 35:/* INC ID */
    { ID( inc16( ID() ) ); return ( 10 ); }
    case 43:/* DEC ID */
    { ID( dec16( ID() ) ); return ( 10 ); }
    case 36:/* INC IDH */
    { IDH( inc8( IDH() ) ); return ( 8 ); }
    case 44:/* INC IDL */
    { IDL( inc8( IDL() ) ); return ( 8 ); }
    case 52:/* INC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, inc8( peekb(z) ) );
        return ( 23 );
    }
    case 37:/* DEC IDH */
    { IDH( dec8( IDH() ) ); return ( 8 ); }
    case 45:/* DEC IDL */
    { IDL( dec8( IDL() ) ); return ( 8 ); }
    case 53:/* DEC (ID+d) */
    {
        int z = ID_d();
        pokeb( z, dec8( peekb(z) ) );
        return ( 23 );
    }

    case 38: /* LD IDH,n */
    { IDH( nxtpcb() ); return ( 11 ); }
    case 46: /* LD IDL,n */
    { IDL( nxtpcb() ); return ( 11 ); }
    case 54: /* LD (ID+d),n */
    { int z = ID_d(); pokeb(z,nxtpcb()); return ( 19 ); }

    case 68: /* LD B,IDH */
    { B( IDH() ); return ( 8 ); }
    case 69: /* LD B,IDL */
    { B( IDL() ); return ( 8 ); }
    case 70: /* LD B,(ID+d) */
    { B( peekb( ID_d() ) ); return ( 19 ); }

    case 76: /* LD C,IDH */
    { C( IDH() ); return ( 8 ); }
    case 77: /* LD C,IDL */
    { C( IDL() ); return ( 8 ); }
    case 78: /* LD C,(ID+d) */
    { C( peekb( ID_d() ) ); return ( 19 ); }

    case 84: /* LD D,IDH */
    { D( IDH() ); return ( 8 ); }
    case 85: /* LD D,IDL */
    { D( IDL() ); return ( 8 ); }
    case 86: /* LD D,(ID+d) */
    { D( peekb( ID_d() ) ); return ( 19 ); }

    case 92: /* LD E,IDH */
    { E( IDH() ); return ( 8 ); }
    case 93: /* LD E,IDL */
    { E( IDL() ); return ( 8 ); }
    case 94: /* LD E,(ID+d) */
    { E( peekb( ID_d() ) ); return ( 19 ); }

    case 96: /* LD IDH,B */
    { IDH( B() ); return ( 8 ); }
    case 97: /* LD IDH,C */
    { IDH( C() ); return ( 8 ); }
    case 98: /* LD IDH,D */
    { IDH( D() ); return ( 8 ); }
    case 99: /* LD IDH,E */
    { IDH( E() ); return ( 8 ); }
    case 100: /* LD IDH,IDH */
    { return ( 8 ); }
    case 101: /* LD IDH,IDL */
    { IDH( IDL() ); return ( 8 ); }
    case 102: /* LD H,(ID+d) */
    { H( peekb( ID_d() ) ); return ( 19 ); }
    case 103: /* LD IDH,A */
    { IDH( A() ); return ( 8 ); }

    case 104: /* LD IDL,B */
    { IDL( B() ); return ( 8 ); }
    case 105: /* LD IDL,C */
    { IDL( C() ); return ( 8 ); }
    case 106: /* LD IDL,D */
    { IDL( D() ); return ( 8 ); }
    case 107: /* LD IDL,E */
    { IDL( E() ); return ( 8 ); }
    case 108: /* LD IDL,IDH */
    { IDL( IDH() ); return ( 8 ); }
    case 109: /* LD IDL,IDL */
    { return ( 8 ); }
    case 110: /* LD L,(ID+d) */
    { L( peekb( ID_d() ) ); return ( 19 ); }
    case 111: /* LD IDL,A */
    { IDL( A() ); return ( 8 ); }

    case 112: /* LD (ID+d),B */
    { pokeb( ID_d(), B() ); return ( 19 ); }
    case 113: /* LD (ID+d),C */
    { pokeb( ID_d(), C() ); return ( 19 ); }
    case 114: /* LD (ID+d),D */
    { pokeb( ID_d(), D() ); return ( 19 ); }
    case 115: /* LD (ID+d),E */
    { pokeb( ID_d(), E() ); return ( 19 ); }
    case 116: /* LD (ID+d),H */
    { pokeb( ID_d(), H() ); return ( 19 ); }
    case 117: /* LD (ID+d),L */
    { pokeb( ID_d(), L() ); return ( 19 ); }
    case 119: /* LD (ID+d),A */
    { pokeb( ID_d(), A() ); return ( 19 ); }

    case 124: /* LD A,IDH */
    { A( IDH() ); return ( 8 ); }
    case 125: /* LD A,IDL */
    { A( IDL() ); return ( 8 ); }
    case 126: /* LD A,(ID+d) */
    { A( peekb( ID_d() ) ); return ( 19 ); }

    case 132: /* ADD A,IDH */
    { add_a(IDH()); return ( 8 ); }
    case 133: /* ADD A,IDL */
    { add_a(IDL()); return ( 8 ); }
    case 134: /* ADD A,(ID+d) */
    { add_a(peekb( ID_d() )); return ( 19 ); }

    case 140: /* ADC A,IDH */
    { adc_a(IDH()); return ( 8 ); }
    case 141: /* ADC A,IDL */
    { adc_a(IDL()); return ( 8 ); }
    case 142: /* ADC A,(ID+d) */
    { adc_a(peekb( ID_d() )); return ( 19 ); }

    case 148: /* SUB IDH */
    { sub_a(IDH()); return ( 8 ); }
    case 149: /* SUB IDL */
    { sub_a(IDL()); return ( 8 ); }
    case 150: /* SUB (ID+d) */
    { sub_a(peekb( ID_d() )); return ( 19 ); }

    case 156: /* SBC A,IDH */
    { sbc_a(IDH()); return ( 8 ); }
    case 157: /* SBC A,IDL */
    { sbc_a(IDL()); return ( 8 ); }
    case 158: /* SBC A,(ID+d) */
    { sbc_a(peekb( ID_d() )); return ( 19 ); }

    case 164: /* AND IDH */
    { and_a(IDH()); return ( 8 ); }
    case 165: /* AND IDL */
    { and_a(IDL()); return ( 8 ); }
    case 166: /* AND (ID+d) */
    { and_a(peekb( ID_d() )); return ( 19 ); }

    case 172: /* XOR IDH */
    { xor_a(IDH()); return ( 8 ); }
    case 173: /* XOR IDL */
    { xor_a(IDL()); return ( 8 ); }
    case 174: /* XOR (ID+d) */
    { xor_a(peekb( ID_d() )); return ( 19 ); }

    case 180: /* OR IDH */
    { or_a(IDH()); return ( 8 ); }
    case 181: /* OR IDL */
    { or_a(IDL()); return ( 8 ); }
    case 182: /* OR (ID+d) */
    { or_a(peekb( ID_d() )); return ( 19 ); }

    case 188: /* CP IDH */
    { cp_a(IDH()); return ( 8 ); }
    case 189: /* CP IDL */
    { cp_a(IDL()); return ( 8 ); }
    case 190: /* CP (ID+d) */
    { cp_a(peekb( ID_d() )); return ( 19 ); }

    case 225: /* POP ID */
    { ID( popw() ); return ( 14 ); }

    case 233: /* JP (ID) */
    { PC( ID() ); return ( 8 ); }

    case 249: /* LD SP,ID */
    { SP( ID() ); return ( 10 ); }

    case 203: /* prefix CB */
    {
      // Get index address (offset byte is first)
      int z = ID_d();
      // Opcode comes after offset byte
      int op = nxtpcb();
      execute_id_cb( op, z );
      // Bit instructions take 20 T states, rest 23
      return ( (( op & 0xc0 ) == 0x40) ? 20 : 23 );
    }

    case 227: /* EX (SP),ID */
    {
      int t = ID();
      int sp = SP();
      ID( peekw( sp ) );
      pokew( sp, t );
      return ( 23 );
    }

    case 229:    /* PUSH ID */
    { pushw( ID() ); return ( 15 ); }

    } // end switch

    return 0;
  }


  int global_tstates = -tstatesPerInterrupt;

  /** Z80 fetch/execute loop */
  void execute(float time) {

    const float timelimit=1.0 / 15;
    if(time>timelimit)
      time=timelimit; //avoid maxing cpu, slow down emulation speed instead

    int    local_tstates = global_tstates;

    int ticksLimit = local_tstates + round(time * clockSpeed * 1e6);

    //trace("delta: " + inttostr(time*1000));
    //trace("ticks: " + inttostr(round(time * clockSpeed * 1e6)));

    int lastticks;
    if(PROFILE)
      lastticks=GetTickCount();

    while ( local_tstates < ticksLimit ) {

    int instruction;

    if(PROFILE) {
      int now=GetTickCount();
      if(now-lastticks>15) {
        trace("Instruction " + intToStr(instruction) + " took " + inttostr(now-lastticks) + "ms");
      }
      lastticks=GetTickCount();
    }

    if(ANALYSE) {
      if(analyse_frameRenderIndicator) {
        //saveScreenDump();
        analyse_frameRenderIndicator = 0;
        break;
      }
      if(ANALYSE_CHECK_PC) {
        if(_PC==0x6792)
          analyse_AddrFlags[_HL]=1;
        //if(_PC==0x00008ea8 && _B==4 && ((_BC_ & 255)==3))
        //  analyse_AddrFlags[_DE]=1;
      }
    }


    if ( interruptTriggered( local_tstates ) ) {
      int intTime=tstatesPerInterrupt - interrupt();
      local_tstates -= intTime;
      ticksLimit -= intTime;
    }


    if(DEBUGTRACE) {
      trace("pc: " + inttostr(_PC));
    }

    REFRESH( 1 );


    instruction=nxtpcb();
    switch ( instruction ) {

    case 0:    /* NOP */
    {
      local_tstates += ( 4 );
      break;
    }
    case 8:    /* EX AF,AF' */
    {
      ex_af_af();
      local_tstates += ( 4 );
      break;
    }
    case 16:    /* DJNZ dis */
    {
      int  b;

      B( b = qdec8( B() ) );
      if (b != 0) {
        int d =  getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 13 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 8 );
      }
      break;
    }
    case 24: /* JR dis */
    {
      int d = getSignedByte(nxtpcb());
      PC( (PC()+d)&0xffff );
      local_tstates += ( 12 );
      break;
    }
    /* JR cc,dis */
    case 32:    /* JR NZ,dis */
    {
      if (!Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 40:    /* JR Z,dis */
    {
      if ( Zset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 48:    /* JR NC,dis */
    {
      if (!Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }
    case 56:    /* JR C,dis */
    {
      if ( Cset()) {
        int d = getSignedByte(nxtpcb());
        PC( (PC()+d)&0xffff );
        local_tstates += ( 12 );
      }
      else {
        PC( inc16( PC() ) );
        local_tstates += ( 7 );
      }
      break;
    }

    /* LD rr,nn / ADD HL,rr */
    case 1:    /* LD BC(),nn */
    {
      BC( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 9:    /* ADD HL,BC */
     {
      HL( add16( HL(), BC() ) );
      local_tstates += ( 11 );
      break;
    }
    case 17:    /* LD DE,nn */
    {
      DE( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 25:    /* ADD HL,DE */
    {
      HL( add16( HL(), DE() ) );
      local_tstates += ( 11 );
      break;
    }
    case 33:    /* LD HL,nn */
    {
      HL( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 41:    /* ADD HL,HL */
    {
      int hl = HL();
      HL( add16( hl, hl ) );
      local_tstates += ( 11 );
      break;
    }
    case 49:    /* LD SP,nn */
    {
      SP( nxtpcw() );
      local_tstates += ( 10 );
      break;
    }
    case 57:    /* ADD HL,SP */
    {
      HL( add16( HL(), SP() ) );
      local_tstates += ( 11 );
      break;
    }

    /* LD (**),A/A,(**) */
    case 2:    /* LD (BC),A */
    { pokeb( BC(), A() ); local_tstates += ( 7 ); break; }
    case 10:    /* LD A,(BC) */
    { A( peekb( BC() ) ); local_tstates += ( 7 ); break; }
    case 18:    /* LD (DE),A */
    { pokeb( DE(), A() ); local_tstates += ( 7 ); break; }
    case 26:    /* LD A,(DE) */
    { A( peekb( DE() ) ); local_tstates += ( 7 ); break; }
    case 34:    /* LD (nn),HL */
    { pokew( nxtpcw(), HL() ); local_tstates += ( 16 ); break; }
    case 42:    /* LD HL,(nn) */
    { HL( peekw( nxtpcw() ) ); local_tstates += ( 16 ); break; }
    case 50:    /* LD (nn),A */
    { pokeb( nxtpcw(), A() ); local_tstates += ( 13 ); break; }
    case 58:    /* LD A,(nn) */
    { A( peekb( nxtpcw() ) ); local_tstates += ( 13 ); break; }

    /* INC/DEC * */
    case 3:    /* INC BC */
    { BC( inc16( BC() ) ); local_tstates += ( 6 ); break; }
    case 11:    /* DEC BC */
    { BC( dec16( BC() ) ); local_tstates += ( 6 ); break; }
    case 19:    /* INC DE */
    { DE( inc16( DE() ) ); local_tstates += ( 6 ); break; }
    case 27:    /* DEC DE */
    { DE( dec16( DE() ) ); local_tstates += ( 6 ); break; }
    case 35:    /* INC HL */
    { HL( inc16( HL() ) ); local_tstates += ( 6 ); break; }
    case 43:    /* DEC HL */
    { HL( dec16( HL() ) ); local_tstates += ( 6 ); break; }
    case 51:    /* INC SP */
    { SP( inc16( SP() ) ); local_tstates += ( 6 ); break; }
    case 59:    /* DEC SP */
    { SP( dec16( SP() ) ); local_tstates += ( 6 ); break; }

    /* INC * */
    case 4:    /* INC B */
    { B( inc8( B() ) ); local_tstates += ( 4 ); break; }
    case 12:    /* INC C */
    { C( inc8( C() ) ); local_tstates += ( 4 ); break; }
    case 20:    /* INC D */
    { D( inc8( D() ) ); local_tstates += ( 4 ); break; }
    case 28:    /* INC E */
    { E( inc8( E() ) ); local_tstates += ( 4 ); break; }
    case 36:    /* INC H */
    { H( inc8( H() ) ); local_tstates += ( 4 ); break; }
    case 44:    /* INC L */
    { L( inc8( L() ) ); local_tstates += ( 4 ); break; }
    case 52:    /* INC (HL) */
    {
      int hl = HL();
      pokeb( hl, inc8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 60:    /* INC A() */
    { A( inc8( A() ) ); local_tstates += ( 4 ); break; }

    /* DEC * */
    case 5:    /* DEC B */
    { B( dec8( B() ) ); local_tstates += ( 4 ); break; }
    case 13:    /* DEC C */
    { C( dec8( C() ) ); local_tstates += ( 4 ); break; }
    case 21:    /* DEC D */
    { D( dec8( D() ) ); local_tstates += ( 4 ); break; }
    case 29:    /* DEC E */
    { E( dec8( E() ) ); local_tstates += ( 4 ); break; }
    case 37:    /* DEC H */
    { H( dec8( H() ) ); local_tstates += ( 4 ); break; }
    case 45:    /* DEC L */
    { L( dec8( L() ) ); local_tstates += ( 4 ); break; }
    case 53:    /* DEC (HL) */
    {
      int hl = HL();
      pokeb( hl, dec8( peekb( hl ) ) );
      local_tstates += ( 11 );
      break;
    }
    case 61:    /* DEC A() */
    { A( dec8( A() ) ); local_tstates += ( 4 ); break; }

    /* LD *,N */
    case 6:    /* LD B,n */
    { B( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 14:    /* LD C,n */
    { C( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 22:    /* LD D,n */
    { D( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 30:    /* LD E,n */
    { E( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 38:    /* LD H,n */
    { H( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 46:    /* LD L,n */
    { L( nxtpcb() ); local_tstates += ( 7 ); break; }
    case 54:    /* LD (HL),n */
    {
      pokeb( HL(), nxtpcb() );
      local_tstates += ( 10 );
      break;
    }
    case 62:    /* LD A,n */
    { A( nxtpcb() ); local_tstates += ( 7 ); break; }

    /* R**A */
    case 7: /* RLCA */
    { rlc_a(); local_tstates += ( 4 ); break; }
    case 15: /* RRCA */
    { rrc_a(); local_tstates += ( 4 ); break; }
    case 23: /* RLA */
    { rl_a(); local_tstates += ( 4 ); break; }
    case 31: /* RRA */
    { rr_a(); local_tstates += ( 4 ); break; }
    case 39: /* DAA */
    { daa_a(); local_tstates += ( 4 ); break; }
    case 47: /* CPL */
    { cpl_a(); local_tstates += ( 4 ); break; }
    case 55: /* SCF */
    { scf(); local_tstates += ( 4 ); break; }
    case 63: /* CCF */
    { ccf(); local_tstates += ( 4 ); break; }

    /* LD B,* */
    case 64:    /* LD B,B */
    { local_tstates += ( 4 ); break; }
    case 65:    /* LD B,C */
    { B( C() ); local_tstates += ( 4 ); break; }
    case 66:    /* LD B,D */
    { B( D() ); local_tstates += ( 4 ); break; }
    case 67:    /* LD B,E */
    { B( E() ); local_tstates += ( 4 ); break; }
    case 68:    /* LD B,H */
    { B( H() ); local_tstates += ( 4 ); break; }
    case 69:    /* LD B,L */
    { B( L() ); local_tstates += ( 4 ); break; }
    case 70:    /* LD B,(HL) */
    { B( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 71:    /* LD B,A */
    { B( A() ); local_tstates += ( 4 ); break; }

    /* LD C,* */
    case 72:    /* LD C,B */
    { C( B() ); local_tstates += ( 4 ); break; }
    case 73:    /* LD C,C */
    { local_tstates += ( 4 ); break; }
    case 74:    /* LD C,D */
    { C( D() ); local_tstates += ( 4 ); break; }
    case 75:    /* LD C,E */
    { C( E() ); local_tstates += ( 4 ); break; }
    case 76:    /* LD C,H */
    { C( H() ); local_tstates += ( 4 ); break; }
    case 77:    /* LD C,L */
    { C( L() ); local_tstates += ( 4 ); break; }
    case 78:    /* LD C,(HL) */
    { C( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 79:    /* LD C,A */
    { C( A() ); local_tstates += ( 4 ); break; }

    /* LD D,* */
    case 80:    /* LD D,B */
    { D( B() ); local_tstates += ( 4 ); break; }
    case 81:    /* LD D,C */
    { D( C() ); local_tstates += ( 4 ); break; }
    case 82:    /* LD D,D */
    { local_tstates += ( 4 ); break; }
    case 83:    /* LD D,E */
    { D( E() ); local_tstates += ( 4 ); break; }
    case 84:    /* LD D,H */
    { D( H() ); local_tstates += ( 4 ); break; }
    case 85:    /* LD D,L */
    { D( L() ); local_tstates += ( 4 ); break; }
    case 86:    /* LD D,(HL) */
    { D( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 87:    /* LD D,A */
    { D( A() ); local_tstates += ( 4 ); break; }

    /* LD E,* */
    case 88:    /* LD E,B */
    { E( B() ); local_tstates += ( 4 ); break; }
    case 89:    /* LD E,C */
    { E( C() ); local_tstates += ( 4 ); break; }
    case 90:    /* LD E,D */
    { E( D() ); local_tstates += ( 4 ); break; }
    case 91:    /* LD E,E */
    { local_tstates += ( 4 ); break; }
    case 92:    /* LD E,H */
    { E( H() ); local_tstates += ( 4 ); break; }
    case 93:    /* LD E,L */
    { E( L() ); local_tstates += ( 4 ); break; }
    case 94:    /* LD E,(HL) */
    { E( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 95:    /* LD E,A */
    { E( A() ); local_tstates += ( 4 ); break; }

    /* LD H,* */
    case 96:    /* LD H,B */
    { H( B() ); local_tstates += ( 4 ); break; }
    case 97:    /* LD H,C */
    { H( C() ); local_tstates += ( 4 ); break; }
    case 98:    /* LD H,D */
    { H( D() ); local_tstates += ( 4 ); break; }
    case 99:    /* LD H,E */
    { H( E() ); local_tstates += ( 4 ); break; }
    case 100: /* LD H,H */
    { local_tstates += ( 4 ); break; }
    case 101:    /* LD H,L */
    { H( L() ); local_tstates += ( 4 ); break; }
    case 102:    /* LD H,(HL) */
    { H( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 103:    /* LD H,A */
    { H( A() ); local_tstates += ( 4 ); break; }

    /* LD L,* */
    case 104:    /* LD L,B */
    { L( B() ); local_tstates += ( 4 ); break; }
    case 105:    /* LD L,C */
    { L( C() ); local_tstates += ( 4 ); break; }
    case 106:    /* LD L,D */
    { L( D() ); local_tstates += ( 4 ); break; }
    case 107:    /* LD L,E */
    { L( E() ); local_tstates += ( 4 ); break; }
    case 108:    /* LD L,H */
    { L( H() ); local_tstates += ( 4 ); break; }
    case 109:    /* LD L,L */
    { local_tstates += ( 4 ); break; }
    case 110:    /* LD L,(HL) */
    { L( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 111:    /* LD L,A */
    { L( A() ); local_tstates += ( 4 ); break; }

    /* LD (HL),* */
    case 112:    /* LD (HL),B */
    { pokeb( HL(), B() ); local_tstates += ( 7 ); break; }
    case 113:    /* LD (HL),C */
    { pokeb( HL(), C() ); local_tstates += ( 7 ); break; }
    case 114:    /* LD (HL),D */
    { pokeb( HL(), D() ); local_tstates += ( 7 ); break; }
    case 115:    /* LD (HL),E */
    { pokeb( HL(), E() ); local_tstates += ( 7 ); break; }
    case 116:    /* LD (HL),H */
    { pokeb( HL(), H() ); local_tstates += ( 7 ); break; }
    case 117:    /* LD (HL),L */
    { pokeb( HL(), L() ); local_tstates += ( 7 ); break; }
    case 118:    /* HALT */
    {
      int  haltsToInterrupt = (((-local_tstates-1) / 4)+1);
      local_tstates += (haltsToInterrupt*4);
      REFRESH( haltsToInterrupt-1 );

      if(ANALYSE) {
        if(analyse_checkFrameWrites)
          for(int i=16384; i<16384+6144; i++)
            mem[i]=0xff;
      }

      break;
    }
    case 119:    /* LD (HL),A */
    { pokeb( HL(), A() ); local_tstates += ( 7 ); break; }

    /* LD A,* */
    case 120:    /* LD A,B */
    { A( B() ); local_tstates += ( 4 ); break; }
    case 121:    /* LD A,C */
    { A( C() ); local_tstates += ( 4 ); break; }
    case 122:    /* LD A,D */
    { A( D() ); local_tstates += ( 4 ); break; }
    case 123:    /* LD A,E */
    { A( E() ); local_tstates += ( 4 ); break; }
    case 124:    /* LD A,H */
    { A( H() ); local_tstates += ( 4 ); break; }
    case 125:    /* LD A,L */
    { A( L() ); local_tstates += ( 4 ); break; }
    case 126:    /* LD A,(HL) */
    { A( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 127:    /* LD A,A */
    { local_tstates += ( 4 ); break; }

    /* ADD A,* */
    case 128:    /* ADD A,B */
    { add_a( B() ); local_tstates += ( 4 ); break; }
    case 129:    /* ADD A,C */
    { add_a( C() ); local_tstates += ( 4 ); break; }
    case 130:    /* ADD A,D */
    { add_a( D() ); local_tstates += ( 4 ); break; }
    case 131:    /* ADD A,E */
    { add_a( E() ); local_tstates += ( 4 ); break; }
    case 132:    /* ADD A,H */
    { add_a( H() ); local_tstates += ( 4 ); break; }
    case 133:    /* ADD A,L */
    { add_a( L() ); local_tstates += ( 4 ); break; }
    case 134:    /* ADD A,(HL) */
    { add_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 135:    /* ADD A,A */
    { add_a( A() ); local_tstates += ( 4 ); break; }

    /* ADC A,* */
    case 136:    /* ADC A,B */
    { adc_a( B() ); local_tstates += ( 4 ); break; }
    case 137:    /* ADC A,C */
    { adc_a( C() ); local_tstates += ( 4 ); break; }
    case 138:    /* ADC A,D */
    { adc_a( D() ); local_tstates += ( 4 ); break; }
    case 139:    /* ADC A,E */
    { adc_a( E() ); local_tstates += ( 4 ); break; }
    case 140:    /* ADC A,H */
    { adc_a( H() ); local_tstates += ( 4 ); break; }
    case 141:    /* ADC A,L */
    { adc_a( L() ); local_tstates += ( 4 ); break; }
    case 142:    /* ADC A,(HL) */
    { adc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 143:    /* ADC A,A */
    { adc_a( A() ); local_tstates += ( 4 ); break; }

    /* SUB * */
    case 144:    /* SUB B */
    { sub_a( B() ); local_tstates += ( 4 ); break; }
    case 145:    /* SUB C */
    { sub_a( C() ); local_tstates += ( 4 ); break; }
    case 146:    /* SUB D */
    { sub_a( D() ); local_tstates += ( 4 ); break; }
    case 147:    /* SUB E */
    { sub_a( E() ); local_tstates += ( 4 ); break; }
    case 148:    /* SUB H */
    { sub_a( H() ); local_tstates += ( 4 ); break; }
    case 149:    /* SUB L */
    { sub_a( L() ); local_tstates += ( 4 ); break; }
    case 150:    /* SUB (HL) */
    { sub_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 151:    /* SUB A() */
    { sub_a( A() ); local_tstates += ( 4 ); break; }

    /* SBC A,* */
    case 152:    /* SBC A,B */
    { sbc_a( B() ); local_tstates += ( 4 ); break; }
    case 153:    /* SBC A,C */
    { sbc_a( C() ); local_tstates += ( 4 ); break; }
    case 154:    /* SBC A,D */
    { sbc_a( D() ); local_tstates += ( 4 ); break; }
    case 155:    /* SBC A,E */
    { sbc_a( E() ); local_tstates += ( 4 ); break; }
    case 156:    /* SBC A,H */
    { sbc_a( H() ); local_tstates += ( 4 ); break; }
    case 157:    /* SBC A,L */
    { sbc_a( L() ); local_tstates += ( 4 ); break; }
    case 158:    /* SBC A,(HL) */
    { sbc_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 159:    /* SBC A,A */
    { sbc_a( A() ); local_tstates += ( 4 ); break; }

    /* AND * */
    case 160:    /* AND B */
    { and_a( B() ); local_tstates += ( 4 ); break; }
    case 161:    /* AND C */
    { and_a( C() ); local_tstates += ( 4 ); break; }
    case 162:    /* AND D */
    { and_a( D() ); local_tstates += ( 4 ); break; }
    case 163:    /* AND E */
    { and_a( E() ); local_tstates += ( 4 ); break; }
    case 164:    /* AND H */
    { and_a( H() ); local_tstates += ( 4 ); break; }
    case 165:    /* AND L */
    { and_a( L() ); local_tstates += ( 4 ); break; }
    case 166:    /* AND (HL) */
    { and_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 167:    /* AND A() */
    { and_a( A() ); local_tstates += ( 4 ); break; }

    /* XOR * */
    case 168:    /* XOR B */
    { xor_a( B() ); local_tstates += ( 4 ); break; }
    case 169:    /* XOR C */
    { xor_a( C() ); local_tstates += ( 4 ); break; }
    case 170:    /* XOR D */
    { xor_a( D() ); local_tstates += ( 4 ); break; }
    case 171:    /* XOR E */
    { xor_a( E() ); local_tstates += ( 4 ); break; }
    case 172:    /* XOR H */
    { xor_a( H() ); local_tstates += ( 4 ); break; }
    case 173:    /* XOR L */
    { xor_a( L() ); local_tstates += ( 4 ); break; }
    case 174:    /* XOR (HL) */
    { xor_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 175:    /* XOR A() */
    { xor_a( A() ); local_tstates += ( 4 ); break; }

    /* OR * */
    case 176:    /* OR B */
    { or_a( B() ); local_tstates += ( 4 ); break; }
    case 177:    /* OR C */
    { or_a( C() ); local_tstates += ( 4 ); break; }
    case 178:    /* OR D */
    { or_a( D() ); local_tstates += ( 4 ); break; }
    case 179:    /* OR E */
    { or_a( E() ); local_tstates += ( 4 ); break; }
    case 180:    /* OR H */
    { or_a( H() ); local_tstates += ( 4 ); break; }
    case 181:    /* OR L */
    { or_a( L() ); local_tstates += ( 4 ); break; }
    case 182:    /* OR (HL) */
    { or_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 183:    /* OR A() */
    { or_a( A() ); local_tstates += ( 4 ); break; }

    /* CP * */
    case 184:    /* CP B */
    { cp_a( B() ); local_tstates += ( 4 ); break; }
    case 185:    /* CP C */
    { cp_a( C() ); local_tstates += ( 4 ); break; }
    case 186:    /* CP D */
    { cp_a( D() ); local_tstates += ( 4 ); break; }
    case 187:    /* CP E */
    { cp_a( E() ); local_tstates += ( 4 ); break; }
    case 188:    /* CP H */
    { cp_a( H() ); local_tstates += ( 4 ); break; }
    case 189:    /* CP L */
    { cp_a( L() ); local_tstates += ( 4 ); break; }
    case 190:    /* CP (HL) */
    { cp_a( peekb( HL() ) ); local_tstates += ( 7 ); break; }
    case 191:    /* CP A() */
    { cp_a( A() ); local_tstates += ( 4 ); break; }

    /* RET cc */
    case 192:    /* RET NZ */
    {
      if(!Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 200:    /* RET Z */
    {
      if(Zset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 208:    /* RET NC */
    {
      if(!Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 216:    /* RET C */
    {
      if(Cset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 224:    /* RET PO */
    {
      if(!PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 232:    /* RET PE */
    {
      if(PVset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 240:    /* RET P */
    {
      if(!Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }
    case 248:    /* RET M */
    {
      if(Sset()) {
        poppc();
        local_tstates += ( 11 );
      }
      else {
        local_tstates += ( 5 );
      }
      break;
    }

    /* POP,Various */
    case 193:    /* POP BC */
    { BC( popw() ); local_tstates += ( 10 ); break; }
    case 201: /* RET */
    { poppc(); local_tstates += ( 10 ); break; }
    case 209:    /* POP DE */
    { DE( popw() ); local_tstates += ( 10 ); break; }
    case 217:    /* EXX */
    {
      exx();
      local_tstates += ( 4 );
      break;
    }
    case 225:    /* POP HL */
    { HL( popw() ); local_tstates += ( 10 ); break; }
    case 233: /* JP (HL) */
    { PC( HL() ); local_tstates += ( 4 ); break; }
    case 241:    /* POP AF */
    { AF( popw() ); local_tstates += ( 10 ); break; }
    case 249:    /* LD SP,HL */
    { SP( HL() ); local_tstates += ( 6 ); break; }

    /* JP cc,nn */
    case 194:    /* JP NZ,nn */
    {
      if(!Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 202:    /* JP Z,nn */
    {
      if( Zset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 210:    /* JP NC,nn */
    {
      if(!Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 218:    /* JP C,nn */
    {
      if( Cset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 226:    /* JP PO,nn */
    {
      if(!PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 234:    /* JP PE,nn */
    {
      if( PVset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 242:    /* JP P,nn */
    {
      if(!Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }
    case 250:    /* JP M,nn */
    {
      if( Sset()) {
        PC( nxtpcw() );
      }
      else {
        PC( (PC()+2)&0xffff );
      }
      local_tstates += ( 10 );
      break;
    }


    /* Various */
    case 195:    /* JP nn */
    { PC( peekw( PC() ) ); local_tstates += ( 10 ); break; }
    case 203:    /* prefix CB */
    { local_tstates += execute_cb(); break; }
    case 211:    /* OUT (n),A */
    {
      outb( nxtpcb(), A(), local_tstates );
      local_tstates += ( 11 );
      break;
    }
    case 219:    /* IN A,(n) */
    {
      A( inb((A() << 8) | nxtpcb()) );
      local_tstates += ( 11 );
      break;
    }
    case 227:    /* EX (SP),HL */
    {
      int t = HL();
      int sp = SP();
      HL( peekw( sp ) );
      pokew( sp, t );
      local_tstates += ( 19 );
      break;
    }
    case 235:    /* EX DE,HL */
    {
      int t = HL();
      HL( DE() );
      DE( t );
      local_tstates += ( 4 );
      break;
    }
    case 243:    /* DI */
    {
      IFF1( false );
      IFF2( false );
      local_tstates += ( 4 );
      break;
    }
    case 251:    /* EI */
    {
      IFF1( true );
      IFF2( true );
      local_tstates += ( 4 );
      break;
    }

    /* CALL cc,nn */
    case 196: /* CALL NZ,nn */
    {
      if( !Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 204: /* CALL Z,nn */
    {
      if( Zset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 212: /* CALL NC,nn */
    {
      if( !Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 220: /* CALL C,nn */
    {
      if( Cset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 228: /* CALL PO,nn */
    {
      if( !PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 236: /* CALL PE,nn */
    {
      if( PVset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 244: /* CALL P,nn */
    {
      if( !Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }
    case 252: /* CALL M,nn */
    {
      if( Sset() ) {
        int t = nxtpcw();
        pushpc();
        PC( t );
        local_tstates += ( 17 );
      }
      else {
        PC( (PC() + 2)&0xffff );
        local_tstates += ( 10 );
      }
      break;
    }

    /* PUSH,Various */
    case 197:    /* PUSH BC */
    { pushw( BC() ); local_tstates += ( 11 ); break; }
    case 205:    /* CALL nn */
    {
      int t = nxtpcw();
        //if(t==0x6794)
        //  trace("Height " + intToStr(_C*2) + " de: " + intToStr(DE()));

      pushpc();
      PC( t );
      local_tstates += ( 17 );
      break;
    }
    case 213:    /* PUSH DE */
    { pushw( DE() ); local_tstates += ( 11 ); break; }
    case 221:    /* prefix IX */
    {
      ID( IX() );
      local_tstates += execute_id();
      IX( ID() );
      break;
    }
    case 229:    /* PUSH HL */
    { pushw( HL() ); local_tstates += ( 11 ); break; }
    case 237:    /* prefix ED */
    { local_tstates += execute_ed( local_tstates ); break; }
    case 245:    /* PUSH AF */
    { pushw( AF() ); local_tstates += ( 11 ); break; }
    case 253:    /* prefix IY */
    {
      ID( IY() );
      local_tstates += execute_id();
      IY( ID() );
      break;
    }

    /* op A,N */
    case 198: /* ADD A,N */
    { add_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 206: /* ADC A,N */
    { adc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 214: /* SUB N */
    { sub_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 222: /* SBC A,N */
    { sbc_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 230: /* AND N */
    { and_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 238: /* XOR N */
    { xor_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 246: /* OR N */
    { or_a(nxtpcb()); local_tstates += ( 7 ); break; }
    case 254: /* CP N */
    { cp_a(nxtpcb()); local_tstates += ( 7 ); break; }

    /* RST n */
    case 199:    /* RST 0 */
    { pushpc(); PC( 0 ); local_tstates += ( 11 ); break; }
    case 207:    /* RST 8 */
    { pushpc(); PC( 8 ); local_tstates += ( 11 ); break; }
    case 215:    /* RST 16 */
    { pushpc(); PC( 16 ); local_tstates += ( 11 ); break; }
    case 223:    /* RST 24 */
    { pushpc(); PC( 24 ); local_tstates += ( 11 ); break; }
    case 231:    /* RST 32 */
    { pushpc(); PC( 32 ); local_tstates += ( 11 ); break; }
    case 239:    /* RST 40 */
    { pushpc(); PC( 40 ); local_tstates += ( 11 ); break; }
    case 247:    /* RST 48 */
    { pushpc(); PC( 48 ); local_tstates += ( 11 ); break; }
    case 255:    /* RST 56 */
    { pushpc(); PC( 56 ); local_tstates += ( 11 ); break; }

    }

    } // end while

    global_tstates = local_tstates;
  }





    /** Reset all registers to power on state */
   void reset() {
    PC( 0 );
    SP( 0 );

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    exx();
    ex_af_af();

    A( 0 );
    F( 0 );
    BC( 0 );
    DE( 0 );
    HL( 0 );

    IX( 0 );
    IY( 0 );

    R( 0 );

    I( 0 );
    IFF1( false );
    IFF2( false );
    IM( IM0 );
  }

  private int readBytes(byte[] data, ref int position, byte[] dest, int offset, int count) {
    if(count>data.SizeDim1-position)
      count=data.SizeDim1-position;
    for(int i=0; i<count; i++)
      dest[offset+i]=data[position++];
    return count;
  }

  void loadSna(byte[] data) {
    int position=0;
    byte[27] header;

    readBytes( data, position, header, 0,        27 );
    readBytes( data, position, mem,    16384, 49152 );

    I( header[0] );

    HL( header[1] | (header[2]<<8) );
    DE( header[3] | (header[4]<<8) );
    BC( header[5] | (header[6]<<8) );
    AF( header[7] | (header[8]<<8) );

    exx();
    ex_af_af();

    HL( header[9]  | (header[10]<<8) );
    DE( header[11] | (header[12]<<8) );
    BC( header[13] | (header[14]<<8) );

    IY( header[15] | (header[16]<<8) );
    IX( header[17] | (header[18]<<8) );

    if ( (header[19] & 0x04)!= 0 ) {
      IFF2( true );
    }
    else {
      IFF2( false );
    }

    R( header[20] );

    AF( header[21] | (header[22]<<8) );
    SP( header[23] | (header[24]<<8) );

    switch( header[25] ) {
    case 0:
      IM( IM0 );
      break;
    case 1:
      IM( IM1 );
      break;
    default:
      IM( IM2 );
      break;
    }

    outb( 254, header[26], 0 ); // border

    /* Emulate RETN to start */
    IFF1( IFF2() );
    REFRESH( 2 );
    poppc();
  }


  private int loadZ80_page(byte[] data, int i ) {
    int blocklen;
    int page;

    blocklen  = data[i++];
    blocklen |= (data[i++]) << 8;
    page = data[i++];

    int addr;
    switch(page) {
    case 4:
      addr = 32768;
      break;
    case 5:
      addr = 49152;
      break;
    case 8:
      addr = 16384;
      break;
    default:
      quit();
    }

    int        k = 0;
    while (k < blocklen) {
      int        tbyte = data[i++]; k++;
      if ( tbyte != 0xed ) {
        pokeb(addr, ~tbyte);
        pokeb(addr, tbyte);
        addr++;
      }
      else {
        tbyte = data[i++]; k++;
        if ( tbyte != 0xed ) {
          pokeb(addr, 0);
          pokeb(addr, 0xed);
          addr++;
          i--; k--;
        }
        else {
          int        count;
          count = data[i++]; k++;
          tbyte = data[i++]; k++;
          while ( count-- > 0 ) {
            pokeb(addr, ~tbyte);
            pokeb(addr, tbyte);
            addr++;
          }
        }
      }
    }


    return i;
  }

  private void loadZ80_v301(byte[] data, int position, int bytesLeft ) {
    byte[58]        header;
    bytesLeft -= readBytes(data, position, header, 0, 58);

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - 48K + MGT
     * 3 - SamRam
     * 4 - 128K
     * 5 - 128K + IF1
     * 6 - 128K + MGT
     * 7 - +3
     */
    int type = header[2];

    if ( type > 7 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesLeft;
    readBytes(data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_v201( byte[] data, int position, int bytesLeft ) {
    byte[23] header;
    bytesLeft -= readBytes( data, position, header, 0, 23 );

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - SamRam
     * 3 - 128K
     * 4 - 128K + IF1
     */
    int type = header[2];

    if ( type > 1 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesleft;
    readBytes( data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_v300( byte[] data, int position, int bytesLeft ) {
    byte[54]        header;
    bytesLeft -= readBytes( data, position, header, 0, 54 );

    PC( header[0] | (header[1]<<8) );

    /* 0 - 48K
     * 1 - 48K + IF1
     * 2 - 48K + MGT
     * 3 - SamRam
     * 4 - 128K
     * 5 - 128K + IF1
     * 6 - 128K + MGT
     */
    int type = header[2];

    if ( type > 6 ) {
      quit();
    }

    byte[0] moredata;
    moredata.SizeDim1=bytesLeft;
    readBytes( data, position, moredata, 0, bytesLeft );

    for ( int offset = 0, j = 0; j < 3; j++ ) {
      offset = loadZ80_page( moredata, offset );
    }
  }

  private void loadZ80_extended( byte[] data, int position, int bytesLeft ) {
    byte[2] header;
    bytesLeft -= readBytes( data, position, header, 0, 2 );

    int type = header[0] | (header[1] << 8);

    switch( type ) {
    case 23: /* V2.01 */
      loadZ80_v201( data, position, bytesLeft );
      break;
    case 54: /* V3.00 */
      loadZ80_v300( data, position, bytesLeft );
      break;
    case 58: /* V3.01 */
      loadZ80_v301( data, position, bytesLeft );
      break;
    default:
       quit();
    }
  }

  void loadZ80(byte[] data, int bytesLeft) {
    byte[30]   header;
    int    compressed = false;
    int position=0;

    bytesLeft -= readBytes(data, position, header, 0, 30 );

    A( header[0] );
    F( header[1] );

    C( header[2] );
    B( header[3] );
    L( header[4] );
    H( header[5] );

    PC( header[6] | (header[7]<<8) );
    SP( header[8] | (header[9]<<8) );

    I( header[10] );
    R( header[11] );

    int tbyte = header[12];
    if ( tbyte == 255 ) {
      tbyte = 1;
    }

    outb( 254, ((tbyte >> 1) & 0x07), 0 ); // border

    if ( (tbyte & 0x01) != 0 ) {
      R( R() | 0x80 );
    }
    compressed = ((tbyte & 0x20) != 0);

    E( header[13] );
    D( header[14] );

    ex_af_af();
    exx();

    C( header[15] );
    B( header[16] );
    E( header[17] );
    D( header[18] );
    L( header[19] );
    H( header[20] );

    A( header[21] );
    F( header[22] );

    ex_af_af();
    exx();

    IY( header[23] | (header[24]<<8) );
    IX( header[25] | (header[26]<<8) );

    IFF1( header[27] != 0 );
    IFF2( header[28] != 0 );

    switch ( header[29] & 0x03 ) {
    case 0:
      IM( IM0 );
      break;
    case 1:
      IM( IM1 );
      break;
    default:
      IM( IM2 );
      break;
    }

    if ( PC() == 0 ) {
      loadZ80_extended( data, position, bytesLeft );
      return;
    }

      /* Old format Z80 snapshot */

    if ( compressed ) {
      byte[0] moredata;
      moredata.SizeDim1=bytesLeft;
      int addr   = 16384;

      int size = readBytes( data, position, moredata, 0, bytesLeft );
      int i    = 0;

      while ( (addr < 65536) && (i < size) ) {
        tbyte = moredata[i++];
        if ( tbyte != 0xed ) {
          pokeb( addr, tbyte );
          addr++;
        }
        else {
          tbyte = moredata[i++];
          if ( tbyte != 0xed ) {
            pokeb( addr, 0xed );
            i--;
            addr++;
          }
          else {
            int        count;
            count = moredata[i++];
            tbyte = moredata[i++];
            while ( (count--) != 0 ) {
              pokeb( addr, tbyte );
              addr++;
            }
          }
        }
      }
    }
    else {
      readBytes( data, position, mem, 16384, 49152 );
    }
  }]]>
      </Source>
    </ZLibrary>
    <ZExpression Comment="init emulator">
      <Expression>
<![CDATA[trace("Loading rom...");
byte[] RomBytes;
getBinaryProp(RomFile.FileEmbedded,RomBytes);
for(int i=0; i<RomBytes.SizeDim1; i++)
  mem[i]=RomBytes[i];
trace("done");



trace("Loading game...");
byte[] GameBytes;

//@FileAction(Action : 0, File : @File(FileName : "Z80Example.z80", TargetArray : GameBytes));
getBinaryProp(GameFile.FileEmbedded,GameBytes);

if(GameBytes.SizeDim1==49179)
  loadSna(GameBytes);
else
  loadZ80(GameBytes,GameBytes.SizeDim1);
trace("done");


//Cheat code for Ghost'n'Goblins
if(0) {
  mem[36056]=0;
  mem[24756]=0;
/*  mem[36432]=0;
  mem[36433]=195;
  mem[36434]=163;
  mem[36435]=96;*/
  mem[39857]=135;
  mem[39858]=50;
  mem[39859]=180;
  mem[39860]=191;
}

//dump ram
//@FileAction(Action : 1, File : @File(FileName : "dump.bin", TargetArray : Mem));


//fill ram
/*for(int i=0; i<mem.SizeDim1; i++) {
  mem[i]=0;//45;
}*/]]>
      </Expression>
    </ZExpression>
    <ZExpression Comment="timing test">
      <Expression>
<![CDATA[/*
int start=GetTickCount();
int ticksleft=60000;
while(ticksleft>0) {
  ticksleft-=4;
    int pc = PC();
     int t = peekb( pc );
    PC( ++pc & 0xffff );
}
int end=GetTickCount();
trace("Time: " + inttostr(end-start));

quit();
*/]]>
      </Expression>
    </ZExpression>
  </OnLoaded>
  <OnUpdate>
    <ZExpression>
      <Expression>
<![CDATA[execute(App.DeltaTime);

App.Caption = intToStr(App.FpsCounter);]]>
      </Expression>
    </ZExpression>
    <Group Comment="input">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[Keys_1_5=0xff;
Keys_6_0=0xff;
Keys_H_ENT=0xff;
Keys_A_G=0xff;
Keys_CAPS_V=0xff;
Keys_B_SPC=0xff;
Keys_Q_T=0xff;
Keys_Y_P=0xff;]]>
          </Expression>
        </ZExpression>
        <Condition Expression="return ANALYSE;">
          <OnTrue>
            <KeyPress Name="KeyAnalyse" Keys="F" RepeatDelay="0.5">
              <OnPressed>
                <ZExpression>
                  <Expression>
<![CDATA[if(analyse_checkFrameWrites)
  analyse_checkFrameWrites = 0;
else {
  for(int i=16384; i<16384+6144; i++)
    mem[i]=0xff;
  for(int i=16384+6144; i<16384+6144+768; i++)
    mem[i]=0x07;

  analyse_checkFrameWrites=1;
}]]>
                  </Expression>
                </ZExpression>
              </OnPressed>
            </KeyPress>
          </OnTrue>
        </Condition>
        <KeyPress Name="KeyTest1_5" Keys="12345">
          <OnPressed>
            <ZExpression Expression="Keys_1_5 &amp;=  (~(1 &lt;&lt; KeyTest1_5.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTest6_0" Keys="67890">
          <OnPressed>
            <ZExpression Expression="Keys_6_0 &amp;=  (~(1 &lt;&lt; (4-KeyTest6_0.KeyIndex)))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestEnter" CharCode="13">
          <OnPressed>
            <ZExpression Expression="Keys_H_ENT = 254;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestL_H" Keys="LKJH">
          <OnPressed>
            <ZExpression Expression="Keys_H_ENT &amp;=  (~(2 &lt;&lt; KeyTestL_H.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestA_G" Keys="ASDFG">
          <OnPressed>
            <ZExpression Expression="Keys_A_G &amp;=  (~(1 &lt;&lt; KeyTestA_G.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestP_Y" Keys="POIUY">
          <OnPressed>
            <ZExpression Expression="Keys_Y_P &amp;=  (~(1 &lt;&lt; KeyTestP_Y.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <KeyPress Name="KeyTestM_B" Keys="MNB">
          <OnPressed>
            <ZExpression Expression="Keys_B_SPC &amp;=  (~(4 &lt;&lt; KeyTestM_B.KeyIndex))&amp;0xff;"/>
          </OnPressed>
        </KeyPress>
        <ZExpression Comment="kempston">
          <Expression>
<![CDATA[JoyState=0;
const float threshold = 0.25;

float axis=joyGetAxis(0,0);
if( (axis<-threshold) || isKeyPressed(ord("<")) )
  JoyState |= 2;
if( (axis>threshold) || isKeyPressed(ord(">")))
  JoyState |= 1;

axis=joyGetAxis(0,1);
if( (axis<-threshold) || isKeyPressed(ord("^")) )
  JoyState |= 8;
if( (axis>threshold) || isKeyPressed(ord("_")) )
  JoyState |= 4;

if(joyGetButton(0,0) || isKeyPressed(17))
  JoyState |= 16;]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
  </OnUpdate>
  <OnRender>
    <Group Comment="gl texture render">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[/*byte[6144] video;

for(int addr=16384; addr<(16384+192*32); ) {
  int y = ((addr&0x00e0)>>2) +
       ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}*/


if(VideoBitmap.Handle) {
  glBindTexture(GL_TEXTURE_2D, VideoBitmap.Handle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, VideoBitmap.Width, VideoBitmap.Height, GL_RGBA, GL_UNSIGNED_BYTE, mem[16384]);
}

if(AttributesBitmap.Handle) {
  glBindTexture(GL_TEXTURE_2D, AttributesBitmap.Handle);
  glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, AttributesBitmap.Width, AttributesBitmap.Height, GL_RGBA, GL_UNSIGNED_BYTE, mem[16384+6144]);
}]]>
          </Expression>
        </ZExpression>
        <Material Name="SpeccyMaterial1" Shader="SpeccyShader1">
          <Textures>
            <MaterialTexture Texture="VideoBitmap" TexCoords="1"/>
            <MaterialTexture Texture="AttributesBitmap" TexCoords="1"/>
            <MaterialTexture Texture="PaletteBitmap" TexCoords="1"/>
          </Textures>
        </Material>
        <Shader Name="SpeccyShader1" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  vec4 vertex = gl_Vertex;
  vertex.xy *= 2.0;
  gl_Position = vertex;
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D tex1, tex2, tex3;
uniform float bordercolor;
uniform float flashtime;

void main()
{
  const float sideborder=0.1;
  const float topborder=0.135;

  vec4 color;
  float u,v;

  u=gl_TexCoord[0].s;
  v=gl_TexCoord[0].t;

  if( (u<sideborder) || (u>1.0-sideborder) ||
    (v<topborder) || (v>1.0-topborder)) {
    int bor=int(bordercolor);
    color = texture2D(tex3, vec2( float(bor)/7.0 ,0.0) );
  } else {
    u -= sideborder;
    u *= (1.0/(1.0-(sideborder*2.0)));

    v -= topborder;
    v *= (1.0/(1.0-(topborder*2.0)));

    int specX=int(u * 256.0);
    int specY=int(v * 192.0);

    u=(specX >> 5) / 8.0;

    vec2 uv;

    //get attribute
    uv = vec2(u , 1.0-((specY >>3) / 23.0) );
    int attr=int( texture2D(tex2, uv)[ (specX>>3)&3 ] *255.1 );
    int ink=attr&7;

    vec4 inkColor = texture2D(tex3, vec2( float(ink)/7.0 ,0.0) );

    int pap = ((attr>>3) & 0x07);
    vec4 papColor = texture2D(tex3, vec2( float(pap)/7.0 ,0.0) );

    //flash bit
    if( ((attr&128)>0) && (flashtime>0.0)) {
      vec4 temp=papColor;
      papColor=inkColor;
      inkColor=temp;
    }

    //bright bit
    if( (attr&64)>0 ) {
      papColor*=1.1;
      inkColor*=1.1;
    }

    //test pixel
    //     zzxxxnnn
    //zznnnxxxRRRRR
    int addroffset = ((specY&(128+64))<<5) |
       ((specY&(1+2+4))<<8) |
       ((specY&(8+16+32))<<2);
    v=1.0 - (addroffset/(6144.0-32.0));

    uv = vec2(u ,v);
    int byte=int( texture2D(tex1, uv)[ (specX>>3)&3 ] * 255.1 );

    int lit=0;
    if( (byte & (1 <<( 7-(specX & 7)))) != 0)
      lit=1;
    if(lit==1)
      color=inkColor;
      //color=vec4(1.0,0.0,0.0,0.0);
    else
      color=papColor;
  }

  gl_FragColor = vec4(color.xyz,1.0);
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable VariableName="bordercolor" ValuePropRef="bordercolor"/>
            <ShaderVariable VariableName="flashtime" ValuePropRef="frac(App.Time)&lt;0.5"/>
          </UniformVariables>
        </Shader>
        <Bitmap Name="VideoBitmap" Width="8" Height="192" Filter="1"/>
        <Bitmap Name="AttributesBitmap" Width="8" Height="24" Filter="1"/>
        <Bitmap Name="PaletteBitmap" Width="8" Height="1" Filter="1">
          <Producers>
            <BitmapExpression>
              <Expression>
<![CDATA[//X,Y : current coordinate (0..1)
//Pixel : current color (rgb)
//Sample expression: Pixel.R=abs(sin(X*16));

/*const float sat = 0.9;
const float[8] rLookup = { 0.0, 0.0, sat, sat, 0.0, 0.0, sat, sat };
const float[8] gLookup = { 0.0, 0.0, 0.0, 0.0, sat, sat, sat, sat };
const float[8] bLookup = { 0.0, sat, 0.0, sat, 0.0, sat, 0.0, sat };*/

const float sat = 0.9;
switch( round(X*7) ) {
  case 0 : Pixel=vector4(0.0, 0.0, 0.0, 0.0); break;
  case 1 : Pixel=vector4(0.0, 0.0, sat, 0.0); break;
  case 2 : Pixel=vector4(sat, 0.0, 0.0, 0.0); break;
  case 3 : Pixel=vector4(sat, 0.0, sat, 0.0); break;
  case 4 : Pixel=vector4(0.0, sat, 0.0, 0.0); break;
  case 5 : Pixel=vector4(0.0, sat, sat, 0.0); break;
  case 6 : Pixel=vector4(sat, sat, 0.0, 0.0); break;
  case 7 : Pixel=vector4(sat, sat, sat, 0.0); break;
}]]>
              </Expression>
            </BitmapExpression>
          </Producers>
        </Bitmap>
        <UseMaterial Material="SpeccyMaterial1"/>
        <RenderSprite/>
      </Children>
    </Group>
  </OnRender>
  <OnClose>
    <ZExpression>
      <Expression>
<![CDATA[MemSampler.ValueArrayRef=null;

if(ANALYSE_CHECK_HOTSPOTS) {
  int prevWasHotSpot=0;
  for(int i=16384; i<analyse_hotspots.SizeDim1; i++) {
    int count=analyse_hotspots[i];
    if(count>10) {
      if(!prevWasHotSpot) {
        trace("hotspot at " + intToStr(i) + " count " + intToStr(count));
        prevWasHotSpot=1;
      }
    } else
      prevWasHotSpot=0;
  }
}

if(ANALYSE_CHECK_PC)
  for(int i=16384+6912; i<analyse_AddrFlags.SizeDim1; i++) {
    if(analyse_AddrFlags[i])
      trace(intToStr(i));
  }]]>
      </Expression>
    </ZExpression>
  </OnClose>
  <Content>
    <File Name="RomFile" Comment="Imported from spectrum.rom">
      <FileEmbedded>
<![CDATA[789CED7BFB4314D7F5F8CCBE17D817CF010CCCEEA08EBBA20BE2324558E5251A9425A092E8A8C194A8890145121EEA86A4ADA9E923266DD3E6FBE9A76A9A863C45F3F063FA30ACEB52C6714454D03525B09A5D92EE67251851A361F89E3B60DAEF7FF0FDA1139C997BEFB9E79C7BCEB9E77167F34DA76972D2CB9BACEB59CB469628F6DE48984417B4DDC21EEC9CD08411B7A1ED5DB740EAF7596BD9A0F70F89E3416B0B4B595AD8DD1F93F2899C25BE7EE153599F2730768F0BD44F3C8D457615B05E5FE2E4D405D0471024FE55602C520AB8290BE0E744F33951D7231A2F8BC4E2CB9498C8E0542E0C709F56559C5A5E515EFAC81B95DCD2B395AEE51517AB8BAB4A4B2BDE285CB5EA7CE1C5558527D714AE78A3D855E25B53786645E9D9EAE5678B5D1756159E2DAC3E5B587CA170D5D915674B1F3E87E63D74BEBAEC6C61D185CAD2527EF9D9D5D5E7AB5755BD51BCACEA8D0AD7C5A2E5675DE70B2B4EE5FFCDF9B7FC132B9657F8562D2B3DBBAAB77A55E9B992D2A5E4D2B3C5851797BAAA56165E5CE95AE32BAD2AACF6B92A4B2BC83F16AF705597927F5C595A55E65B535AB57CA9BFA8B4F45CF1F2AAE215BEE5157C656165E9F9A52B0AAB7B8AAA96972DBBB8BC028060EE9AD2F3AED51757545601672B562CAFBE58BDCA75AEAAB4F05449E12A4F5529B4AA7C15A5978A5C5525A5E78B5D15AB9657ACF6952C17AA4A85A5AEF3652E72552FDCAA579F5C5E5109785C85A7109215A5172B0B5757C3CC872F56BACA7D12FACA15AE8B55ABCF5617AEF155155694B8562E5FEB5BDE5DBCE2424955E1A5E215A585E7AB4A57ADAE02B955FA8B963DE258B8AA6C4DC583AB7373AA9616AF2C5FCE2C282D7958BFC2F583EC9AEAB5A4AED29EF550E1B553C35F7CF4D7BFFDA5F3C8D1AE8E374FBCFFC19F837F3A19F8F013CF71F73FAEB0FFB36BCFE54F0FBFF3EEE0E743CF7E3CB0BB7FFD67C7FCEB2EC5A8550AA5262A5A6BB86A5D2CF49CE137BC97692B98377791E5EFF95EA76F3EF76877DEB9B36F9DBE70B1EFFCDBBDF3E68335E2A21869991F4AA7F59BF7C4770D68F87CFBDDEA8DE4CD4C1E63426DF93D22DD2326F7EC5A5B23129CF04B599719637937A9A616DA489963728F59C1FE8DBC2EA4C9CFC1C0097A5E183A4ED0B3014411E6DD3D1B9B298792CAD3B2CDD444857A620D1E1416C803CDD91A7682C7AF73687061575E140CBB897F162562BBC4D9E7448294F32D5D66A52CD99DCBED12F398F9BABB2E392DEF7671E630AEA0E530948825BB39F31C19BF84BEC9AFA5A32678FB862E455737C975FF8913ED977577FF5B4E269B57C9F82DF40591B1AB0748454FB7861B70C043E4CC7699F803FACFA29D3E165277B72B7AAE1B38450FBF05FAC937068CA285568964977323E75CC27DB3872FE00BE687E42E153668EE930F6AF396B121C66030DCD26018A688D19113FAC5CA9303F2EBC60B62898BDF4C6ADB3EA4B5AD2B5307BF5A1933F8D53D6E346B76973CE77FB7FD2E7D5C71C8C0985F61DD1DE406AA825ADA9274E01372157582AC6CE9CEBF315371759B427557311063BFD71DE333D72B04558EF0D182510533B6B779B44B96C508BF4E13A3ED96D161C5704E7BF1EA03EDB83267E10E3923BC96E6837F81CA47DA3EEC49F57E2CEF8DDA273B17BB775FD46F1F7D7A5F6C7F52FABED4FD85B27D19E7AA4FEF9BF7DF8EA3FB98C9E5CE7DC5934FECDCE7EAC056ED63612DFBB6C6DFCAD8F7CC985129DCCBC85BC4BE70F7C51981734161CCB6E949DD1D2D0F825BAC0C9ADBD3F967410BBF8BD1C40DDABE71CACA8CE205F1BA41F5462639AE9C79E3B242351FF53875AA5CF4C4F58B340D5EB512841233588FED7E7FB313CFF5CE546E236EB6F22D46D1AE5015213895931C5576E6F30927E395A983942ACBF9EC6762FAB9B6FC93A242B5C82872E3F7050FB8D1D03D46D61B33C6C56B12BE71421FE20D7A43E42D99EBD32E614469BF6B4E5018451BF8C26F856B4A7B58F57BF4F8C2D97DDC3E9C418EA93804D4DF225EB4DF84B773ADD7E5AE5998EA0891AE21D576C3E0D31861E04DEF77B5A6BBE208F5A01B7BBF6B904AD5A83E9887039E734EFE389FA03A72FEB41296D4F621797AB788238CE79C8905E44487A2678AFFB74324FD4DEB7C57487D4B7341CCE5C6F29AD881E1EC2656F8F90CC13E93CEC74D187475D032BDE576FF604015ED2463E38CDF0D3AF04990BCF9D664B4566E37201052D6AB6F394A47E151D860304085234786C42FC8E53024CA4FBF386344F880E6BFB5479B3184B0804EE8C54FBE28D12028F7607334BAC550833BF44E9CDF41E3F983CD5878449C435E1911AEA786BD6BD5E23B64FABF905D4F1D744463838E985433B664F069DD60939E58297692AE7F812C23C918C4183484D00CC2203C3F63489C4BFF7B9F62043A011718E7E08EE8C1ED31D28B6E70BBFED1AD830E4C4E9488A769AD444CDF4E24A1992711EA7F4D42B00089591F6123EBAAD9DC48D5E0D3D1834D31D67216BD1A069B8C6189E0766D106439A81D0C9A4C5867AEB0463918B0DF708A029E38E1A892EBDB41858327464999FE96A8B0FB4D5D5A9F1015E3190CF699BF9E4C5645B9F349796BBB2B2EE50445E231978CB7F856F243A7EE5200E68972695505A7351A5176FA982638587F77F0F17B831BA207D7C4ECFE98D645AA9859B45A82241F0880C9A906EB75838FEB838301242F592E8977382781A7CBBD2953B38208282E2E2E4CC44C210BC3D218AD49892597AC1494E9886C07ED04E471B6A5B60A9B5C2E1F84B441F83279D0BA910569D8062BA20797C6F8D0807B625C589D488D35F7513BA9460AA8E63A27BD324D58828369D3B04230D913F40128C2410D561806971AB596721638DD1DEA22A380694B113BE188C2FAEEA3B84FE5B6A33DDC179CC22CC83401A40C37CC494E890381C9524EA4DAEC9A6058389E1C20FE5798AB25AEBA5D627B4F10F4E416DBE9999FD01A1F0C7AC2C4D7A161F12019DBD71FA440D8A42AC97E3B40C803C4B073B22F9C9F8BE69E228D1AE01A6183058781598DA61F1AD067AD66AFF9348CDA86164CC8D1DDD317A9AE06EBD8C8FAFA6157043CFD30A98F0B3A2740F79DA6435AD0F3042FBB2E5C4C98320EE1A402765AF633C689295D38270703DE938AF6EAA6DAC626B2A9767BDD5CB2694B5D3DB9BDB16EE74EB2B6BE957CB2AEF5B0AEB2B1617363ED53790775154F3FB5A9AE91AC6D6CAC6D8566F196DAC6DAC79AFEADA7A8B5A96E67DE41411E2D92E7FD51A28AD92A12F63A7374D446885E1B92835E7974458D71CEAAEAAADC4AD7C60DEBD9756B5755C7382D9F9026888E15A456A1973989E3A45CA9377BFDBABC97D9F109470DEE2485BAE8B1EC97590E419D14F47AB3B03A46091040AAB5A0206424D63A1713DB4C2F44651B5822DAF4541421470D3D6B7D8805E3E04C37B5427B9455CFD6EC1113AF982CE49C92079DE92F3331DD32974439D199B8FFCA81B4FC3205086DE9C9D5311327B2AEEC8D0112BB81C67305A1F49E1A00EC065616C52490773821235A9A9882E0494DA4F8A7ACE5C72C17297E918D143FCF5AF602B33B4A2DED533C93F191F29FB2D61FB308BA2752FE226B450015A5560010DB990271BF7D5699C0440331D32B2C510601537046F3C48190C185EE5F1FD52B9A291D798F1BF8935DDB9DE08B94EF82950AC6189029341C6CD8BC88E5F78A2429E3BB67610D73E6CCD17AC2AD054E33A9574A6BA455FD82A0EF6BFDA4FFCCEA983E5F10A4AB9A4C6770457AFA019753D321C12821AD389B1BD6A41C3CFC76AC86898BA70AC81BE19968ECCC67D1018F8EE2344EF2471B3544683784A590FCD6C39B23EB5E62DDEFBEFEEE045FF30CAD09FD9DAF2165D719683D0EAD3B7C03B4D4CD5C7016768D50987E838D0B85318CD64902CEA56716C5A4849E0591A6C4BD601FEF1397D172F1F9CB6DA2FCB293ECF75FF2F771E3E17CDE4DD1F70AC83BE13191BC9C32502849B4CBE4D7F5B748CA92E940594C6A17341EA7132736643E40AF7562B00D22BB162381BFC9F52A26165691A54E627FF6CF59EB4B2C5AFBF8F44EB91333BD5390FC3EE70FFB61C7F845922E15AFD285B748B19E5E24F953647F01CB4BAC20EA26966629F4669FF05FFAEF65601A5E9B52A122C3B13BE228E35D0FD7BEF3B1C6866DDB3EED8D11654CFBC4DEAC81E47391125F19226E7D990D0A2B752DE3E627D9A52DF9CDE67DEC09469EA322044C3F56407E199878BA06514226038CED15FC3A78747BB84EEB2F2403A2159B27EAF500617E9925656EC3E1D0EAC3CD9CD0A933E7B3FC61BE1B90038B4289DEDCB536EF17AC9250EB495B33188FF1F684234B262D1C36066C8A0EE4394D6F191733B77073126185386AD90334EC7B855FEBA465032E60AC443F050FE0105770DC4C98B1759261C74A3A00BB812512BE329089C7697E19ED77EF3FA25449D0D66B7CC19690BA858C099B87EF248771122B881C81F7C9E47059480D1274B5A8B0C811955A1BBA437E16C8F0E84841F8A95E02806EDCF72F24D3C0BA55EB1D585CE4880957271784EE94914169D63F60D6A627E3F2A6A52487E4A9393A72C4A33773485105B72A37876BB7CC4157C94A0EACA106A96FB8A12D44DC5AB299FB467504C23E848A9B7A4F206377484D46EDE9261B161F08DDF9F166E308A1FB0616ADD248E3C66F9D8A0BF7EE21293CBDB4B3AC99327E0752FBA5E4B65A44F98190ECC2BD1A61553A1325C10943FADE98CFEEBD70C71ED6431AACD2F0B17C1C9FF2D9BD74FBBDB60BF78C5FEBC8AF386B011B343F6B0C467616B06084E389D8C48649730F267C2C1F33338620F8D22C51CD648A46260F97613550D0C6C827F85CF7E93423C06F847FFDD675B076F55E88101E6A3BB58388422DE814AA1263E322D5EB580E54637ECD80BC317473DAC79FA8FC78BBBBF7A275394CCCAD3FF95BA3509F2CFC26B1EDC3D3BF350651C26E8EC2B45274167E6B042BB81684588827066C130B0DC26A6222C700F19682CBB28E0D0809891C42436ACCCB59C1904C3C35E1C08CC40342969150BAA11847501CB4701CF37E990C1CC35F2010B0140075CCDDF52D972BFCC614A94AA63C977D252B373D49A584BE168DA4964A19483A8B9138D51129D286999044A50B98066EC3C0AEF9415698017C2739312FE43E2014FA2DEF7306D0C9E3F421E06112095334EF4F01617AED86A0B0DF6483C400B89970A8B100A0936D38F5800939C1FA9E3CA9583B3C0E9DF5A7EA75E076EC55A2D19E29AAEC516521DCD592DE1D4B5849ADF909D6A939DC4CE845FDE5019DB9903DD10C252206D33EFF9403D376398DFCC3249E3FB1E38249672254793A16F69AD505E2828D94CBA17DCACBFE00FF0E5B5F04BF80F4BFD924E9DFFA3C1B44A2080B7B88B0102060FC5A18E0F37EC6BEC2CC2255BB265EADB4A78193146E6AFB88AFFE6D7568B191752FB284AC4F922B24067E5DC0F23C2C7416C6596B595B4764DD2392B27B22EB6AD9CBD6C758CE2DEA711576E6CB643725EAC831EE1B27E0F880F547CA3F821C8361ADBB587F99530D55C8E24819265D9B9E74C86C7F25EF76206DD9550B69F942FA1B9B3F520C33AA19D602331474B2E523D6D4E9C4DFC2C291E3610A3A6DF8122C520CE31FB0662CDFE260AD1FB00EA7ED5B9B0D788DAC9930E7B1F7CCC7588B0BE625E00930EF48D866A961294B350B499BA39DB23CC23A74147AA9652D8FB1963AD6C964FF82CD7E89CD5EC69A29A545CB4E2CEC9E5878DADC9D6032B2B81E7C0BA8F32CEC41E4FD8427759D262661DAE9136AA9EF3749C29144296608730D42522A32463256B29E2560DE4287098995188477CB7A56B897DC72F4E4FA8421514743D4B12F3DD5A913EA75CEE489575D1060809888C021A5C48517539F41B6045015A7047D5E1E9B3F0E4E76A22977A26996259A35E398259105E2A08FC38003F13456264631B26EB5309AE0242FB5985E8E03663B4D0EC473A4BC941552539C7997262A742A0C5E615722AC74AAA8A51562023A2DD3E172CCB49D3597B0BC9BC6B591E3C0C92470F107EF7BB1ED2EBEA2F4E15564F3D6A62D0D4F37914B5DE7D7D4366EADDDB4AD8EAC6F68221F6F78BAFE8BEAA73741FCDABABD896C6E6CA81F71015CC3E3E453754F35347E3BDD80F1BABAEBD32961534303B969EB8874E253F13DEA3257F5EA93A5F53F44E08F6FDD16AC5EE5AA247736D536D53D55577F7379FD33B5DBB6FE1092C7CD4F4FB59BEA3603AE8629FC8DB5F59B83150DF53BEBE08FDC5A4F1615562FF716559516969399243ABB221BEBB6D7D5367D33CD103AE2BA8F13A8C16A6A9F0204646343C353B0AA4672DBD6FA2916009974BEB5D455F53DAFE86CEBFEECE5F35DE40FEB9ED9FA58F07ECF630DDB1A9EBE31457C6B7D5303E4C828298E5415AE4408EB1BC8CD0D0D5F544F2FAD89DCD6B0F3FBF5ED6C6AACAB8D2CFD97584A4ABB2B21737EAA0EA5CE758D8D0D375641F20D736A7FB8B57EF354CFDC83CF92593F60B2C9EAADF58F6DABDDDA4856D5EDACAB6D7C6C0BB9A2E90BA711C7306F5C5CA478396B5D0F99DFEA84206C6CA8A5828F6E058748AAA66A084F6BC1119A46C592DC864A977E080B01D8471E5F1CF203B6C87170A061CF76DB0EDB4E5BE398F7F5D89BDAB78CE537B5A712AA9F339C4AA8426F95EDBDB138A6C2A2311C434F23F26FF524CA933F17420997E9BBBD6A7F10020345119A34FB8FA4F70DD49AB0303731E0E75EE84E6C9885DA6D1F422D9F940ADE2FD9F2104A31DE4441A3C29C9928FC23F15C22B621F9AB7255756C652AC2DF3DBD674204A2B3175ABFF42267899FE520720451A928FC30D15AC7825BE1C683E672D6A9071AD79033BA66D7F687B5E146DB4EAA0FB2D72FC37D63D05DB2529E1CE6302C6C7A29119570B7D7501B38707D5249457922C5B5AC274C7156E45C202A4CFB17ABE462AC929709424E6ED9C20638E43EBDC164CADDD1F30945DE013F9E9624E049A013D3D53F869319357E31410B8133BC83DACE0561C15AB4D0B0393109565AA1C2B45F952BABE595788043475B4606C4D22D579B8DAC0BC6609E8D1BC519C0D972944E0C4F4F7787C5725A2356C316AF247B85F549A8AA41C7542D47D111892F2534E432B72102F63144C28384A9A98CC2D2704295A6226469C66800EDAF0970C4FEC84EC88B1D3223648C92ACA55C714ACEF66E3089C8BA6D2C922463E9076B3275C9C291AA6BF0E6918A592DA30F83F06C91EA6D2C11B16C63ADDB5014A6F1B0B08090D26DA79C903965400113EC334FE18943C27692891F121701F77349153AE92034E8A4442E7C3E7DE6D1125ABC79AB450AE76938A41597A464FE56DE932CF854F2FABB3DC17EF3369451F441CD1C2907C0F6E44427AD3461181F37B133D32D2EF19CF309740AC80ACC646F5B07ADBC840AB6FE302CEA5594DBBF8A421E2DE307A0B286D5914AE762C143406C0DBB856304C43D5A1516729389E13E4ED47751D2E5E6FC2863E7FFCA4F4CA5DB6BFA1D1884DCC0449394A2FB3948A20059575E21CBAB69457731918868FDC159CEAFA1A3F9CFF3D1312D2D7316F703AD3E0E6C3418A6A632AC8094C2809972BB3AEE10BA4E6D3EF35DA4A8801EF38E2608A99976BB6866E6C2125E15793A43CC23F552620581C2BE868E879CC342468DE73DC15E57643FC18E01DCC02530B66A76D57A0FC8E61C525598B8E93EDE45B96D9F70283F5BCFEAB1849E91BF908A0E8E426B861EC082EBC43C500C4F2AF8421A421A792D21970B82409924BE818E7FE1EEDF9317E34ACC2ED3C726516EFB3D4245A1B490D2F649DB0A76953098EC6B995FD63ADF25875D190E24F7478E04D056B2018511B46DEA586151A6F07A26A3307F7D597BE5C5195E5F627FB0936F21C947B7A64D129A7EB0A860388DC489EF046B32FEFB49B8EB6FC16D0F44C1401F7794FFEBA7A73A3FFAD5CBAFFCE67753D7B3CFCDDB56BF7DD9AFD72C2EB425A5E73697181EB115673E94F754916E395B92B01E2F90A9B0CD692A5EF9F50C282FD2B0EB33302A5D51A03AA352CA1F5060EF3EA014D295FB48A56CAEF28354EC7F4CF24369CA6F9334587B9ADC95866D4C93BF97863DA9D362FFB0A8B0BC7465E401E5EC3479519A56F93C85BDA75772E9CAF1A468B834D81DB95649526AE9D2606D692AECD716E5A3E9AAB951982349850513A3B05F2545CD95EEF00FFE405D27208BE8CC2E630BB2F358021F113E4D84C07DF7C519432A0C4CB10D7412363F931A748DB40E9C0581B9CCCB52B4155A426E6D62DD94A589C5AB527D2EC84C63CCF80CE437B4C1212537F4093A49E450E121EB8D9FE0A3DCE40E6B11CBEFA6E3CDE2A4A51439341BF25FA979252CB1000C119E747207595C064EB18536F44E7A60CFF65857B3CEAE37BB3A45FC2C069A895497B214F2E9C99465351B06ADD6A46128A9489868D49DA653E3859F25D39ADE4498DAE5F1A0B4E8CF621EF47B5F9C6178A05CBB397AD72F777CF45C2FECF64F3D67AEA786610DC83FFA38E1037AC2918BD93560DB6749A2173FF3EA1C90CD33A4AE13B98E319B79077BAC391C296E642D2B59CE23AC41FE82CB5BC48E0BF732C626D6E0EF849690197CDBC9492B4236DE7AEB403E193F46BC8D9C0C381BED08C0218C5DBDD1D36F3DC44D78B891BF3BB552279D4DC709DF99012F6C75CB2FD02E77AB0F87DE4125B57D261D2795E02B75E6FDACFBD69DE609BEE6D89070D54C1CF02A55B05005ECCCDF23918D1E64B85E0D921E1D352A63C2C25739573E4CF5CE491505C48574B84BA8E0367A8819ED92E1C3E0E327AD10506C6E5E84E45BAB66547A1D8A46C151998C0984F5519123D652368C6AEE35BA78AA51B8F2C0B989A50CF4598AD8BC3236525203D13FED1B5FA47C352BEC7D2052BC9AF530A6915BE4715A3E427C39E2C45FC92E61B95E931BAC89A040C3B95D4BA98A4871118B767010CABA4022E603E579CE11C3A0828A93F3665857A2AC319D02CE4687AF1ABA640CD0BD6CDDC29A0C5832D800F578D8BB33AD171B0D0C5F7560325C9E8B29980E8EC9E5468474E9E87DCE103AB2AC61DDE25C5A9BF605706697F5EA84660CB43704A93CF85F548B082D183A39E79042611A89F423CE3D753D758418777E5116F9C484C9BC3F4B86E0202535A808E050A4384A2A22E52D6CA4F81996B3D6B3136B1C448C049488ED16BFB6CF4587B98D519CF093B4482BBACB38A13F9349A065919271801B434D883CE08CF09EDE2861731A046EA1340DBAEE23FF80F545D6954BE7CD502342C1008986291B4BEE8B54D935D68F90C387152584A186E9F3A0E2C5874AB6F0577D138FEB32AE2D4039BA4FAAE2FA11F6780CA66B99A8B0B9124B66E491C6CBF3E4DED518A2AA4C2F59C979027D6DA2938E5E742D8CE6F840BAFDC15E1570F30C846C3AA6E5503E89CB51614A5F476911277D64B9EC14E12E59A8D279D6FB833418BA25FC62AE3D7144CC2095D03A3622D264FE88388726A1FFFC8B33C26844161E0983B549598F430F3B042C65589C43C68D8805A47EE4FB9D75180F2D419F52203ADB67067ABE9A8AE953F11C768330948EF436249492B44EA820E97BC277E9E8F98D38A747F0A63B7597B821F13D5227B4CE80A6A0A69C8984517C9F8C95B602F4BC96E64CBAD47AA9E51227DC309F830CE11CD08501B445CF8CD94E5ECB6C391ADD93127789B80D28D177FC3C0EA510F1C073145A76B45375895089B3BB84F1F411E083C43D9F722295DB852874201228BB3AAF4F84AAAE431294C689A30A0FAA2C870C173C24AC009DB14192719C91EBCD65E810D799BC5F2AE1A463376FFDD4DA4090FA1158F2903807F957EF0766F1346942F60E9B46441C4337A14362EE344FF59E0082A73F30835B0717C61FE3AF43DECABBC9681030782C995E7EACF9B643D76A30D8954E4BACAD199D44F0B96E722E6CE9A993803C73502A4015D27940EDFD22140A54297A7C62068B857787051306CC2092074C91F2E759E01A113CCCBBF913E40CE9042000DB11D5A430657AEB8103279220AB45F57F2E0AE2C207567046805052E2690F890E0A006A48BC4AC7E4ED608547668057EF011F0A9EAED72865FB901D89E5B0E96F982FA37D7C0B7473031CBEE8BF2C0E2DBE3C3E3236C08D8326C6902AC64117356397DA2E7103A6B318FDC0800CEE6B44BC4D85930AB55AA570B589327B622BF85E826953A9192584521503BD5009F7C6995F62450D13EDA6D547E6873268BCC5D52A6CB338D57F3E000FB53A5459E6D4FCF9C0E183879BA916EE409B41D54ECA0DAA25305D030E5A66FF5B2B60005010B781B88CEC42637FFB820834A64EA7B397B19CB373FF956F33CA3AD273D33BD2DF0ADD796B732B8CBF15FAFB5B6A75436B48CD810D0BEF58CA146EB57122847BE94CD411B4405D1229DEC34A434ED1609C28734F54D4F085247E907F8894BD35BFD9FB59B4104F95F9E0F688E72117F23F40498FF7E827C1A2E7FEEBDBDFA8B580718BCFD995103F8843A37F641C3F1AF581FFDD93E11BCD0A2860ACDDAE41C1C1E3FD8765F424DE2593E3C3862E3C6B18FE0E7A64CC44CE26585C43106E81CD963DACC74B6620DDA0B0E36DCEB84FC6F7BA223DCB6EC75432067ABB641E5996358007AC8661A575189FE2418DE8C0A8445C16C0951E190E3C9C94EE5783C3F2D71559E93E19D9253B29F30415C357158600EE910DC398427ED20AC8644C8AF89CE74A33CCC7993C90109D39DA658057B7F4EA330C07198F92CE27E2470359D71457BF50C83DB22F1457AF290C27658C0F6264C090757FA21C85227CF8FE643923FC4F86C7D80D4C7E8F5B8EFF3FA3A097D12C3A271BC395415C696550105085BEEB56D865CEEFC611187467A59F926581343C20CB2C4596E1903CD50BE245BA6E3D6E576DEDEFDC48A88FF66C29EC4FC41E6D49FF0923FF2BA3FEB5CBEFF1110A57BFDF63DDC3B6FCB8AC35FF278C8ED615B8C01CFCAD467F1F477FD31B05899CCF657E7526D464ADE77F3C4B855568BF129A30B9A83B0DBBC4427E030DD1C2212FAD022F39E55B506682A85B1DAC09C3935BA503EAB736B68688EB4B6A548FFAFA83298769453E9952E052A9E3A994C36F9306E36D8FC7E36CDF0F1EE6762C111530692054798C1796796157C342D0A139200123965F7F78B31B2CD7328376CDBB618B7D6BCD9F6A3A7EFCE64BA742EF7CFAEEDFDF3E8B8D78273386A8208A4D8699642ADCC0B183E734DD0EF4BBA9D83860FB8E9B122DF48DE83E54E71CE3DDA73EB07A6367A3346BDA39C6CEF6FE6D369A4447CA9F61055BE6E821434E6EA222A7BD10C3DAB36587E4590C445F14BFDD1DB47CC0D84C6811B8020C3E67C4EB9D85AF358E88D469DDEC690A74BAF04B991E23E38434B95D9FB05158201F476B1D8B45879682445FB0CC3CB570E688F7B399E8AD7DE608B10CBDF0961162B1F0D3B9F63562A13D1F651994F05F7387A603A0434F852136EB951D91222851D049236429847E083C9B9EBC4B091F2D001F88022B110FC9E5957933203D05072E76310A34482CC03FD38A99F46C1C42DB619A1CE884441DFF5A21C6D3F1106F55C6EE7FB8C421BB8C3F2A5E6764FC273E49BCA0EF1829C74D12AAAC23C4D72ACC65FECD6C54B9AB2ACC9159DAA57D6DC799BC8ED304E60301EC1223A48A7F8694A5BDD68FA4A4DD155A5C36BA8821B4BBEEC7684913B7F85DA48C3FE6213CFDAD12F684D0E26E8D4B344259374668984B6212D4BEDF4A2CD87A33BDD653F37D1BBA0BCE3ACFE40B7FE77A4E73BCEFEFDD3D984AA38992C995D2A542F25A3832953C40EE304EE2C85863514A61047D0F4D650FE3537A97943506346E2173080D958D0C64B860C6082A4A6DE0F57D90087A206F2282C2BB7468E838A981E740C627744CC006A99E948612973ACEBC4BF7F545AAD7B3301A044A454819894B68B50D3AA8448C0AF67F9FA090B600522054A7FF52E0BB344CD2051173BA9100348913D09843CB7A93FB50E5628D66AF59A2D9FE1164B201E808400B592DD0313377D1C7C55B43536B0E86D25D234191A6697E4CCCA04DFC57C8940CE896C81F1D216E8DA0342B2F86EDA091AC4E3E34A710894CD31A1AE6275D442EFA1940E8593AF313D292F4C28DC573183BFAFE9F122792F4DD5BE409FAE6ADF613A42A05E14B084805BB8738CBDFE90313A1B5FC9784AEAFAF2F38848641CC7702BC91DFCE01FB6E71CEE951DA7DEBD132249A69C1F06FB57C42C74A871692080002ADDDCF6F2563A8C83A28C0BB168441467D7D9DF95C6719DF4A96433AA2CF974AF9306CA221EF722B4C5ECAEFA0A394F4976164A7B5E13091111C0A400821F956BA8ADF41AA2057CC1FE140A0DBC43364F6102AF1890D660C0B8E045AC52E528B64FD9078860EFA82C275EBB5B070C6CA24470B37AD5AF0491F02DDC7838026AEA87C4A29B291804989A1610E81C38B474B15958785A35604A006357E86F60988E40E9236375517221BACECEF1CF799700CF83B43278D098275BCF291A0D4D24A36B9E949220ED802D0186974E8D1ADC07D68EC5AB20D9D14829763D454C75DD25AB2B20FE146C94D277AF1096F2FF08061354BBF2CD9416DA740725C677F504A68D0368C45A5445FCBD15C5A190882FB68FB1C0BF471615424230E7B84B7ED5712D23928A65059456F00139583B640F1F668D1C898C444BB8E2222A05B0676D6E92E5BAB546DA0AC3CDC0FB352075465B469CA246F9171B146B0955867178C1CBE4506847FDAA04864202A63409B5882363CAD32A9B06462044022E58D88EC52D2DE72B42778BBDFB76A3DE52023C7D17961E01AFA82669795ACBC1686EA421639E2E90BC05B8F746663B3D9DC419FD06DF304E472B9F7CB64E710E07B731C2686B53E1BD4E0D03DCD290C787C72F459079D208FD99A513F0752937EBAB3C6B6C1E6465203C739F5932C52C31F155E9D03090823FD2A061D50F3DF4290344366BC8394CD538647664D82B95C21AD015F063ACABE690DA3F4E54BD0DA5F463CAD5B66611435271904DBEF0B96ACBC2FB1664F747434D292A7856ADEF464AA03D0D13207E9891C97CEB60BD0CF355233175F160B179F13D75D166BE1B18B134F91C9260C1B19C83A8B9151E1C59127AEBC9F1526468BCABDB64C711E6D1016C183A447602E6321A2D013FC3BD4F9A387A02A1E122C994CF4E8F01BCA2E8581192146C5525A2ED675A92647441BAD14334999429ACAFBD0D9577FA607D077DC7D3F4B812A51AF2B53B45F16F31623CE2E0FD85D2A0C7DFAEADCF8D0B232E19875142AEA71A03406442E8FE26F0005F44BE931B5C12E9B9F3F8E7E1D12BD70F40D668C5F6CD78D8F7A86318562814C1960C668CDF86896821923908170B0BBDD6FBFBC9172EF7BBB86D36341070672DAF5F6CBCD54DBBEB79B290716E0461988C2CAD1D70DB3199811EC0F2F159ECDECDCCFB71695EFEA0B7035490736BA3A259E724653C8FFF313C56C14BD2F8F2B15B47C2C971BE346B31C5874562EA693314EFB25CECA38332F8D1EF49E82CCD51FF48F66CD3E29BF8A4346E7EE20CB00B5CAD8D641AA3EA4B5D52A4DBFBFCF4FD48C5E65DC036EC1935993F71EFB4AF67B6C9BE0CA84791E7900656DC1EC436C41D2817CF3BBB01FF73607BCBDF306DAC5194C1CCC18509799DF63F736B7444A600EF14A58F8F37C3F7F778F7FA0BD8CA7F8583F1F0737F33B10E3DD2FCD6EB6E9C83BC6914EF39BACE910ABD2461AF493910652A18B21A362E32672764CE434EA317E098D53C691BC77D901A8DA2716EE702A264E341085A3B2AB8C84DFD9FE9B79187FD72F0CCE9F70EF80C244E50722048963B25DC2CFE66F6C835B8DCFEF318E990FB1AD13153BB4CD809BB8300E4D68A9306DE198CD7D166B06B98B518BED1AE398035700ED89ED3B4005FE803F52FE2E0BC02DA2965188DF31B33ACE8C2674EEBF5B35BF8C8869859CC94DE984D104E3CDD68E1E8573DE25A7DD78AF90085526A870E1C1F9CED24B0FB676DCF8D1FC4889CB990955BBED920AF3A6A6F437CCC2D6AF9A332779CE23C92BF6F4716E07D6D143419D28DA7A7CE049B485AE5C9B7B3EF065BCD3EAE182E310199AA9D60A1F0A11E19A0DFDD41A6A03682CE0F1A3B7B100D7D1239AED89BE323F9FC9A7F0A97E7433DEF09C1314F62E7FE73CAC66BD1F361837A32BBECB3F83C4E3FD5C58A8CF09A71C2367F55341E42B511189D007C2DAF02F0DB00FA30F483E17FC501F67EB137E950D26D41F14FE6B7E59186EAEE376794B61787C3FA801A43F16680E6EA94DF687230F8677FFA221FD7D7F38906E4755FEE0FC1C9AF2EF09B5FBA9661B9DBE2B52B278631B2CADC6BF0BEED2AB5D9DEECF39FD7E96BFC6DFE95D9DE5531977AF8430368789E24D4976793223337E0385C0573997A9C320220EB8B6F443EEF16C66F85A21DC5BDE7605C0CB87034C54DB8724EE127E99D9C7218E3B852EFB65C476185EC2CCDA2030DBD211D9E40FC23F959930D995C9FEC85ABF9F9FC13F307D23F8643F9F9C6EFC22EC0FFB3D8196E748BCA36071D2E2F41B4BB3EC5B3AF249C9C8DAFC24DBEC6FF1DB13DC1DCE761AEFF4BF2EDC9BAF6E66E6C12A89392A520289554B462FDD16D2978CFF242E25D9634027A4DA9FD8EECFA18920E587DAA525894F4C6F067FD048ED0CF481D571BD4A603F8CF8676E86EFAF02B1EF0767ECAFDDD2A91A228C49BCC9CF9B78A37F8E3FF2849F3146AAFCF06737486BEA20341D531DB98ABBE7B3C6E9C0C687FC8F548EF104FCA185BDEC2DC87283DD3C6757393027493C24BE4CA26F36CEF6376DC76CA4DCD97ED8463AC0334DDA9C04B1C03EB77F7EF7CBC8DC6C36D8996D34AEE3EFAA34FBDB19C5DA446C3FAD2EE3F3C0E6EE4AC2770F1CFC3A52D21FB695F10CFA8F563A309BF15E484D6BCB9C93FC6CE3776F3687FB38E1D5ECB0BBA30B69B213E4D6AC7A191C92E6C322DA58FDB06A5F5839C7FE1DAF456A09A3AFA2B6ED7D1C76045B7204C3EDD8D872C395D7E135EA25477ECEA10506FB697B67D6434CEAC28C858BFEEDBF787BE6FFD3FEFDC2CF17FE35A7D4519FB3D5F1F9C226C7C7B9EFE45EC95DC014335773E3724F393A1D0F32AFE43C91F35ECE9F723ECC4977700BF1855D0B0E3AF63ABA17B439540BBFCDF92FC78F72E3B35F5FE0CAFC6DF6F29CD49CCC1C438EF0E9C296ECCDACFF9A3F525DC7FADD54B0E346FB829AD0A350EF19BA7737B485D209BD48D8357EFCDEE4AAF55ABFBAC174297B9674886BAE5B70AD1FDCCCE32C37960738086F3F54C3E84012B298E96C1161E520118A1CE1363D094F30866B3E77A84BAD76C5B8438B4919E5EEAE8C752A5FA6E2D0CFB73CD7C084CA3A953DB171C4DD8E9EF17ED8FA42CF82BEB102E2864BAD7E0E7DDCE4FAAD5B58F403FFAE050140EA0F9A7DD97EE1F6028043F6170C4F0D8751AE1AE054CA948A70EC0E2ACE783BCC95091B166419BA64074F660D2BAE7AA0C4EF5E206C5A6080C8B2F07A40CE70AA49428576AB0A8378164DB584DA8FC1FE69B67160C1CF66065A8ECE9FDAA208A61FB2468A4FB41D98EE7A2D2DD24228E011858E755E4B33DB32833E0E921EF4CD944A816A80D10EEC6792C5047B427EC10B2FBC20BE658F41BFC07CCE65C715902EF46A83BE3237750CFDD7E20974E54A649C532C11CA4EEAB04D1D7462CD543395D49C0EF7E60087BE10842FE71223D2CBB90EE2F3A997FED4CED8D4D83EAE6540C3D7907881C1AE190F0AF9397DE13168AB0DE382C14E2C30A09CACDF8732BADD1F5F6B21A38F7A68C5D86222718C883B4AEB525E65B464243A8EBA6623863C631D523231FE0F7CE1D8F8C56F73C60C17F185DCF70882FD3E6DC9CADB5004C00E9DCA09A79FE8E0FBDE6430B94F3A43D79331D385378086B9DE287456D9D27DED80C48BFC7600956DFDA80A73E8A6BE7065A0EF89EAC0F7C7C953E5B4385D7911071136CB3A16FD6460EA6765C2B54CF423B2BEA9CFAAD2C16478EA33F9F90369080AC184122075B7CB636E233E10B8F7D385D2A7701A4F410A1CB3814AC0B836B30B03A482F273FE0DBB920ED424FBB9B8B894D4D40E72D40F9D63B07338F47F980C2B670FE35D0AF93023E5328A3C86CBCAEB920FC386971F02CB1A2DC81963DE5934479135DB2B4767443F8D733C5CF7F87FB7D42D79FDD16C6EC47CBB33233CFFC891F8EBEEBFFCFAE1B13CF79DDE6B287121D58C7CAF5DDBAB64D4AFDA159192666E547610A1CB429F4C7AB507212772B4A393A81C0693E359395FAF38734690E7621AFC901C677246F19CAFB31A93EE28F0D7E5AFCBB372B249C5EBF29F9BDE8BD7AEB9F2A747EC3E76FF3B7FD8DE507B88BFF2EA1B59073E1A3928B2DFFD33B5F8B423D2F17BF786AFEBA9F65F41DE88D8BF6EF9F647F58A2CC8F1807FF8CF7A489E95DB85292043044A0E4C960A603F80DE614C95BA403EFA83ACA9C3B0BDF121363DFA8F2F31D7BF4A78EC2FD4F5577442648C5A9FFA4F0512553A4E2A194EF86DB65B7C8ED18F1E4AC595598E3FE253280EE2D3387E6EFC204EBFFA8B5F3CFC83BFAEFBDDC41F30C7D3073FFBF2A3C78A4E853ED63A4E7CE5D899BAFE7F2F7FFED889AF6B0F7D1823F10B130FC953E943066546166A5BFE2847FC65D9B1B4D799511C9EEA990AC67BCA218357ED413C17531DC295B2430C37F99FEB3FD77FAEFF5CFFDF5CD8FDCB081766C4B08C8CA976863B03FE304CE3A49D514E0DB6E9871AE3ACA500471BAD2579D06F9C825368E0526018891090D011AF716AE2E1A981A7660A463305ECBC4F8B20E0265368107CFED207AB36E5431F0D780022BF4896BFC48D9E31B222E8D710F43237E0712FD92DB5F397EC2E424F379A6F4470F9521BEE4E59BEB412E94F7A20020086F843E42506A0A591E6293418E0CD7F70CD862553F3DD454518B6BB08F0EF46ED254B10DE9692A2A2921689FE12C497F45C228D57A071691ACC736AA6F897C964123F25CBB62F2B81FE25E88279458FAF95E08A36553DB8B448A227C1216A53F88AAA1E9C6EA379F94BF2A5F58A46493358D1343C7A641053CFB5A01F68101900FF7C092DC1B99158819E1EF1A387F52E21A5F56F4768B6C3F2995512DCD43589CDB0B490081E6314F925809F24F32D1624C7192449CE00F14137EAC798921624A7182331351F752B18585F4B49490912B7DD6864001E6628804192B6DBE98C29BB32C600FC9655706148A0123CE02B2961A6DA2D9200103ED5145D6447CC1246D182F89D9E5F320D5F5242D3887E09A0A3D19336D22553E3881F6C37AC7F375ABF5D5ABF46BAD0FA63A4F5C7D3D2C2F38B5E3B74E8B5A2FCFF0B5E9D65D3]]>
      </FileEmbedded>
    </File>
    <File Name="GameFile" Comment="Imported from Batman (1986)(Ocean Software).z80">
      <FileEmbedded>
<![CDATA[789CECBC79405347BB303E27CB4958840414022A24046D0497181562C40002828AC4026AD556E82268AAE2529BB08500022E08EEC5AAA0AD8ADA2A6E75AF06D194188F75A9D468634995586BA3A0053792F33D27A0B5EFBDF777EF7BBFDF9F5FE29933F3EC33F3CC33F39C13447B1C67FBD792E4EFE448311F432CCEE6B0F7DE092C94BD7F750142349B8D85022232223411111FA1084DBA86AAE96D360FE49EC1C379BC7435C2D3E1C3E365DCB1D942514644068AD0A743A1D14005AE8C087D84C6661BD205D1A0BC88880C68BFFBEF89CDC8401994D88C741E55419A0C8D5E934E89A5203C00F2323278945877A0E5F13414697ABA0604BC253663AE532CE0332E53622328B1D6F408944E89B5A6537AAC194EB1E9AFC5A6FFFB627994D80E1090AE06091D6A94AE81A6DA2956ED149BC703195D6223D29D02D2BB055829B173A137FFAAAC5BEC1D4A2C65ED9D74949EA1B993FEB6B573FFB6F6DF147B9912495D97A941D05CCE787B6CE7FE3DB6BC08E7E444A8D3D594820E4AAC3402A05D13A9D150B5BFC5EA4180E6CD9465744F99E6F5D86AFE1762232228BFE221195C5D0E96D1ED604E08888D9051622B105D8710FA489311E10EC51B77B3D9425050AC13A3CF0388FE2D8C2B2A7000469DAE4FC7C1F3DE3823C5E394A68191D3E4BDC591D805CF48CFC87087E28D9BFC5F6949A7E6E76D59DD5AE6A6C3AC42F1667A298E61979CFA1F016D86FE2D1E5744924E1EA796CB6F5CF53F6A792DAB5B8B5A0DE30EC59B69F9BFD2A2062DEABCB7642522CF5667EF79B8188A7FF4DE392E73D31DE07719D6B72C734586754EFD100228FDAF1D99E2714A73F665EE5BB21211ABD9290BB4CC7DA3A5CBAEFF8D16A7B47F68796BC42841E9D45A799BA36B8ED54D7911E0CF6FF5DF1569B12EBF4807A7D6BF71F37F9D97BF6525224CEBE4E045A443F10F8EFF8D16A7B4746A5565BC05DF8BF2F2C03F11C455F0704D4477584611795DA139B81B1FA1CFA0161545A187480EEB0F227A9ECDB603E206AC0294AE872004ABBF3BC820CA53329CFC5D788D9E423929C09B202CD86CCC8C6EF6748869D66EF6AEC8D5C56EED66077C8635825A0714858362CF704AA5F8F3F2D4609EBA8307EE06D8AE588232F2BAE24970373EA38347793845D1949101A119CCCF709A9F3E371DC751FA1D1E4C3160BBF61F6A6E9D7B5070375E738747F92E45A107CF01FEB938E50A6FF82FBFC59FD1CD7FF92DFECB3CCA2BDFF067FCCDFF9F0F5FFAEBE1EBC267E8BB02B5939FF7D6F0C166E09C3D2ABEF322BA832602DFEE9EBD2E3CC54EF9108F9A3D1ECC1E4425D8B291CD86C7DB6CDE636DB61EDDF750B8FBC6415C85BB3BDC2BE0EE130B9E05F73EB1F1F081F6D8AEF6EB7B9FB15DF09E40E7EEA4B3D98AE08E033F1368B87017429B057796B3CDD6B95FCB1EFE459BC3A3BECFB9C5B2AD3FBE73F8412759D9CA3E27E882F768E8A95F32AA5A9179FD0519D8EC76DEE77A765E75A46F6781D6EF82EB0FF38E4AB73EEFA77F7AF2CEE3633F5F6F7BB128FB83C0E7A4BBFE027DED8351D5F25F818CFD03B34B52CFC61F6AEF9ADBAE3E7FB858333744D3E3CCE101CF491783E7B92511358AE7A4C7459D5B738FC64ECDE8215F6822756EC68B912D594F992FB464ABCB25E1B5EC615B89E7A41711A06FCFB9F338EBE7EB7FBC587492528608BE2A2452D9926F658B02E53D98016E51881EFC62DBE22A0589E37D8DD19883CDEAB512AB2C0A277D59FD26200F8C76419D34A4B347F3A929B5573D4F41B77CD60BB51CCF22DF90EA85C4E3C70EF6CB5BF38E82E95CD6083736EA276CF6DE1DBE75F48CCCBB9D38272298BFD281732382A3563A82BD865A31142FDBB6F852DFE3CD05F5017FB43C3991A59BF247D6594655FEFD5F2B7FA546D257BC324AF0258B74F3934F588B7DC9725B5BD08AFB470447BB397AF4167F12ED56CE1A76672179B7D3BB8FF85EB46B49C48B8445F3DE49137CF17BC10FCFBDFA8EFE241A7DDCA765E819C5A6A7D979056D0EB780C8E0792BFA1EBC47FEF0DC25302258E01AED4F36E303C257B2050ECEA0C817475C3397DB485D40E8D7D0357C70C48EE8090E5C12B1564477708645AC8D2A2E21056B5ABF0FA87044EA7A0D1F992CECB19A1552D176E97CC6779B1FA94E916D0EDE8891C9CDAB007AF9FEB76D2F9EF7B9FCF9A8D1677E8611191536D4CB8255B27EA85C1B55FF0B0A8C5207B8B5918CAAAF781C0DE3AF5675DECCC848DA71E9407F9748BA7A47EA80D2713B171D4C0DAAC80455EEE1122F138DB9A36349240CA434A21306001F1999E712EAC047878F64843A3CA3875F5B0AC6D4D32B32F3CE82EF8D89BCD64FB8823574FCCB0F9E933D6222AFB18BCB599217F35420203EACD37D94A3D7B8A111AB13FB695BB3239B1747DEFF6D015973F639898F0FDBECE2E27099183E92ED1F3D8C6CF67E77F835469F98419B501E67E4FC8DA736C0C4F4480679DE20CFF8E931909712763AE11D8777EA50035631999629F62C7DA7CFAFAD3787801993E579036196864E79F9FD73923D459E97BE7205CCE754791E1692E9F55C57D0EA362DB203C94796B7C09C784D1F71A7933FF9BBA6C73AEBE713F2EE3CFEE1396746444034A68DD4B1D65B9F6E323F27DDD2E55E3A36D6CFE21DE8E07C38FC1A77CB0CFF7B43CF525D27B56E1FC923A2FA7F083E0C823F0625DDF55EB3469C6687A485B45C4B52F5BC77FCCED49F5B60827D95C366B2F9BD7AFDAE4E0AECF4FC3037EDD79A5A03C0FB2C1CEAB53A215BD462BACCEAF4FAE8F3DB03C7FEBA64E3F97CF2832C18A04572AF717487CB62D969018AEE4936BB7C263B1DA58D16426D49641E972F1C4836BBAB476DE67844EE6D7F0513D62B47D29B2DFA78D3E3025DD2E253243623290DFC21A87044938EEFF2FD4BB2DEB1F8D859C6AD34DFCE5E7747E6CFAC55ECFCC9F02002DC152F1A914CFFDA81978447807F062D0331C19E72EBE7F33F1D6079555DD929F8D3519376AC93F1F0FB333FA67D037E225E3E74331B450EBFEFD3C1951EEFD14AFCF0D0C154F5DEDAD4E939DBFE34BBF3656EC4E28323AB3543C2B7FEF4F8D9D9BB9D2E2BE4331244D12E60F1CA91333076F4AEA71F15DCED0C583F4CCB662CC6ADC9496EDF36E57C3FA33572D7B5DF55CDB9135B5A619A7C36446AD9C11F0AEFDD0AF4FD82B8471655DFA983B8837F316A4602D3816F8A9811DDCF31E0CB519B31BECB20EBD18E0181E7AE6ABC6B0E67E9AA677C4FD24D43F236DFF8F32FD5A8FC9AC8B360B5DBD7722462A43C7D098BD663871C45FD356AEBA38C3F161C03C7DD198962768C5A67B37E33ACCD21D825D659B4C5ACDF531CAA82A5B793369E5AB8C3A0916A1EBFD3E9D3B2F7044442BC56AEC5840EF1E1613AC4578D140EF3E706FFEE7D66E889CEB3F55366F42569AF4247E4D8E69F2DDC77F3E55FDF9F9959D7BC39B10D1C1A8F1B3B2FC1CDE1323671DF39575630D9EC1F3F6EDFB9A54B7AEFBC95F44567AF8C4F7BDD6AE9F4981DDA910B0E981037689C2B267B1E55D02A4C8D36E8508F81CFB90BD5EE0D5E1F45631DD5BF3E1FF96B6B64F317F473F79EC802611627C7EEC3421DDCA98A79475CA30FBFCC0F6FF60C7F004ADDDE8BDE8785F40A6E58A470F0A62585713C267A7CF2E58F693FDFFEE34581CE3AEAC153CAB2CCA47909A31CF8EC441B2C7AB7398A7D2EB2397DAAFA14B4FAA86207F59957345C37AA79DE0FE205E39EF3CC3FBE03539A1D6F63872C0427EC51A61894105ACE92CE59422DBEE58A79E346C1E2E3AC986873C1AA38977EE7B6ACD47F0C83F6C5581B3BD4E1B5291618276C7DD2713AADF5E30DED301BDC2FE3F6B16523D73DC9239BCF863F0473FAD5C618B64D5C8E37B8F1EE2CF8E99B0D63CFB04F4FCD3DFD6BE1A5A90F1DF4F02D59CFDCA878B57BDCA00F5DD376FC910FEEEFBB27DA10CDFF78D0DD9CC78A670FEDB71E9D9D3164232C008FBD8A79541068CE3E4BAD07B769333F471E4396DFA7BC60E6CC308EE7F2F841D772E5356D0EEEDCB419CDF3C377AD8CDFBEA071AE0C5C8D3FFFDD30FA5758BFFBDE15136B1747EAAC7F12D66BB3EDB927B676BA3FF8F6188461F58C4151AE584FCBA2A33D429B25BB46EDEF783828F904CC5EF6CC7D5845E4F63FC18FDDA6658569DD67543F0595BED33F3C1AEDB6966518756FC3A5A7A7039F7BEA3E93C3ECB9BD9FF5793F46A6338AB03FC8FA3CA104F6239F99F3C3988C1983759CE651FBE37B6D6C7CD4711BAC62CF057C2F6ABF9A9775745C701793D7FCF96158CF7E611F1FBFF7E456DFEA630AD09B3B7FB0D623D2A917CF9BFBB940E870C99FFBB9F62B4C000B51B9F45336EABBC3F60CC6CE25A772D0B8FE546C71677AB82179E4CA9645B03ED9ED34235BB09A45BAE456D8305CD01F624FAE661EF270D6B22BE745F51708A85A810D60CEDAFC41DD35F5780A1602B5F763AAA18691CDFC21C3766058E5901F367AFC38FB88BFA564CC5FD513FB75E4D8D38ABEB73E86F9147C30F40EC6F7166EBB39B820CD8177E49CBE53A9617D9EA6987AF8C43D9B1A0289FFB8E8CB5879FC14CBBB5B8B86D47B6F6879F9AA357A797D1B65ECBCE4A7F558512F3270C6EC8E68C6AC0CCB71F2DB4E0FDBFCF0D6A9BB9FCF1BD25C33E8D1B3A720A3E70E810EF5FF50F8227D91FC689A60F5C325B0B3BBAF287988F8DDC3E15525D97CF7AFBE875A0A74FDB38E6DDEF7E30FCF03792327446355DF5FBAB3F4FC19AFBCF1839EFABED8DC6A2EBBA3713F91360422C8FB2977D8B468BAF5C6D92FCAC89016CCC843F4D16587F7AA469DA88CD04FABDD3F2D927ED2F8C1E507F967D2749FD32B4974FCB2D31F978D1F54E8FAC1963670140F8DF228461BF7CE0F4B34237D7F6DF69E53328F9338ADF7FDCFE5A3BE79E178AE9EF89CF499BADC1685548AF4454953975B2596D42DA73EA062E2B48A412E9883FBDE0A1B5839F5D228EBC24B8BCF40A462BF1F548D3C8B8690DEEF4BAA6FC334B41CFC2366D3BE290F37DC861539373C0022BE5BF9883B883FE7B32A76416B8FBC6133FBE47906D75F53143149C4E7A70EFD8B24FCE713D366F3DC11A221F231A44644671680EB24EB66112DF3DB89BBC56D6226C19FCFA31351F30999A64E5231CB3661E52C22613E313583385C44C833884BB3784F643AB5A34017B2721617B5D4DA9275823E955CC72C8C89FC6DDBBD757FB4CC22724A887735C4A20572128437AC9FC5EE293AC29131378F06260753DC2F50EAC6E5B4068AB194BC225E0F2E467655BFB57A7E9B19B4721658D5707856A09C23A5C95B4BB2787FCAD6CEAAE5BF9433246B6719045F66D48AE882DA8CA0D51906E2FBA5C602C19A5961884F0B238D2A7E1FC2B394783A5B7E86A0D7102F664B5FF5B8B87E160088B319BC6B8A404298EF204503036FD566644B56CF9254CE32C856CFDA33648FD5B1E77503AAF1078F8BE8EA470E0A944D15C49CF98249892DDC65E9C43BAB2CF999FA9E598EEFA48F0D4F6D33E5236DF1729E8424E50D92BF48C1D38CA0769298B4E395A1FD42CB0D738BBD85B85F62B7982D572DF55437448CD1D08BB65706399BD0660A12A2B853135A6E10BEABAE5A66E55362EBA5AD004DC9D587A489AD069C191713CB62C532636271FA1806038F8F6130E3C6C6C732F198B8F8B81856ECD8F8B1B1AC985868E0B171906BE0281E21C041096DD0D1F0C9524559619902470269A68B46622DAABBEED008670AA7D8520E6672EF17096DDBA8AF4280DE5B28CC73CC90BE3020241BB3DB18CFBD9629A2737FCC145CB888D3FDF7ABBC854221E7998143E3B1A3780EB694DDC472784B694DACB2B2ACFE6800B7F995DF43C357D3DF8B99129D0286BD3B352E3975A864D8F011E291D2F0B0498A7193A7D5254E189FB06DFBC4A431C74F9C3C751AF225B299244907244A54E1423A1E3F7B657790A41D5A1CB2D94176B771C6ED406BA023504CE374D45831C9D505C4C905B2AB0B9AB09B82F2D9E0113B67079D5F1A44CCAE931867CB09C9F74B0DB703E33D038D5C96911B08B7AE7FD9433A9A0DB70B14AC3DD6677B8C5C23778FF5F11E0009F8B598C36153773447F03D854624FD2BC24094CF8EE0D3461B466305A41163044A5FE637F1D3CACA8AB5F17506B5DE9675397343A6C6401C9F2D7A4595E13AB507720434BAD7363A821BDDEB0C5CFFD9302E7E06A2C71C0FA4C149F03D1F4678A0F4554B7BB6F6423CF16036F1CD9CFA360BCFCA6521BF6C3D53E11824FD99226F019F05930248CC0511372B4038FF95DA11201266EF3AA312B5767186A09A16F941CAD39FCEB604A11AB96E83A3A7F8BA0918E524EE7246C867715E9AE401BC8B168C85E42E5C7E2DDB5FE5EDC21ECD7FD6F07476BBBC0878DB1AE835E8C68516D9777308FD1C4BFD5583E4BB39ED82F5766C3D229A2AEA24E92B474B682BDA6A1BB9EF38DA09FB9CB6265C84B713ED7378ED824FED5830E279088AED18E4DAB8609D1DE320DB71035B69B3F92192A49E6FBED3DFB7179311361CD265C4662724B03909516C5E8294CD4F1073D851093CB63481CF162770385151361B1BE9EC8268A540171574B55C40A2A0EBE5B69821D0D6052D54062D560A206E893F95C99492914AEE3CA560A1126320DB819079CAFCD3522CCF16ABD7499628430629DB89139FB5B5130D738871F3E4C85712A16C2346AAFE91C4624471956DC210A53A62B7D57377BC2C569939D8297D891248ED82714A0B5032447C39ED35A59EB3DBDA0AA4314A98D837A496A048655D437155105B592771555E20D2E7E174E2788544A62C2BD34FCCBAACDC9089D3CC02B632C9AC41B522B735698181E0CD6615CA2DB4AB90D02CB40B39778144E3282B2B2B05901D6042CEE32E31A3955D77B992489EDB551DA524BE5841747C2A7E55DFD09C6D9C2AA2753C2F35B009E6FC105CD9AE26F67C1A2FCC8652216C6B62950A8370E502E142A14A16AA0C19A06C6F21C2E7050D503AF9813E343414082C6D0092842A7136287090E18D0E9D78BFBDC52EF051126E4BEC169C0670A382CF90633CD7761C83563D8B754022521235F388EBF3642265A0D84D36501951DB48C4CEE53D80A2D600DC98178230585F65B7189CC697656506070D529A0543A9F933D935A49E415C9A2B5844D51D50D7CD152CA6EAF62627FC33AADED9C468D075755E10A96CA2497D8D3EC270A34F13CB164BC537FD46495F65B84965709091469F5A215C06496FA5A08F52E6A26CB83157D24729E8AD94B16146CADAF5C1AA1662ED5C31351D127FA559281BA4940428097CDE1BC0600A6069D30F54413764FE4A8555DC6CE574608095F5553A748DED7A1C34CA27517CB173DBA06EB0B49961DA0C722D8CA200CD60FBA099C2338D7EBC1794EF648FB6B62A8839F36E7A7B7BFB77B4453486C3B632CF947D546532F820C19519260196E7819966F6E91BDE28549F11B9FA998C9818139A787F0AFB6AACAD27F88F4261869CD27146C3F10A6AC003A54CE74C5831167CAC1C85AC97720FD8689BD05369CC14B9191522E623CAE81E3DB225FD9506701036CC38B7B7524DD8E7796543E1EDC56E2FCD2A2B8121F4F66A1BB27D5BC773C940A5A1540802F5EE5D53D6FE5669A94F34103F67346CD85827D1A925CCCD124BAE206A056CDCC4F53CE2EAFC67155074E6367C9CE36C3470724D50195F0505A35280BEC2A2A8C062223E57124BE6135E9944FC3AD96825919349ECC96D506B42A295B228653B18CEE8079FC07C31BD8991B55EAF95B82D57C83BD76F88B7C5A6154A029767DB628B25BECB89F3CBDB02DB7FD2CF6F0BBC29907FA5A9E533424379CF859A8E97113A55A8CA002A01F85828E43DB7C0AE276C7998842361EA072E0F6D070C0CAEDC153649F965088566414296390C028CD74262773E969B2EF725FA6411CF16485BC12D1CD8AD9FB3F8FD89B959BC4B708412F8658DD00947E8C268C211C6B117DA2F1DCE6CAB3FF74C433CD3341CCE74D0454C626216AF963895C5FB0A3198CBCBE5E79C2A32B328F120F3959C66DE8824AB6619109DC55E235FEF441FA5D038EB827A34D1B4A09EBAF59A53CF6925FE04069D7C2345A341E6520654202A395B404895B173E41B00C0FB09B150E917F2F34E71D7DE68039286F119188DE9724166C9756037E54627C5B3375DEEA60A34209A8BCB25380FC239AE6B707EA4F698ED79B9C4AD1AF915AAFE5D1E71B1466E82AA8C74426F51D03FF21E0298902F205241940143E20B50AB77531FE4774085F8B294FFDC10E29725C7BEE7B34E0BE62EB8A4CDC7D457608C1B5ECC465C8E170736294ADF2F200DDBF2BB3C1006134B3D2E0FA5EE5B8ECBBF74B67F97EF853B18D7009A5E9B789362512F930753E32F5FD0053CE4EC219C14BA7B67C0E80CD72365E652BAB520DEC3ED02B1B96B10EB1B3653A7C59BD90E8CCFAA3538ABB58D301611E6339814AB83386D6E21AA4ACC16F358BAF1B83989668BB93B1FB8CD633173127297D7F4B8C0F7311BE91ABE8BDC3935D53C969CEEAC38E708ABBFB0BA6BD22C2DB60977E7E7D7F2594E728CC1705A41D13A01CC2E8318DD0AEA395F871BC8A249C97129297C9289914C1AC9A493FCD484383E59C44F55F0C931D1A9E484B869644A5C625C4C2A49C769BDB47525CBF88A49A9E3144938E6CBD7169F2D2B99A89812C78F999C9CA248A69163C7258D4B4920AFF54045A513A3938007158FA78869C9E3520180FBA13171C949E3E2701E2D3679F2C4898AA458725262F4B4A53A72D9D2B214323A76FCE494D4A5ABC91845526AB222B1814C514C069AA4E894D469E4E494B8B19313C9C4E8D4387E742A3F695C7C422A79CD1D159696A56C2097E34CBAB6F040C90A1A09351A8EF582CB575B5C9652C44F8E7B77F2B8E4B858FE584532BF984C8C1B9B4A263BD963155393C8C993C8F193274E2263A29393A79193A24111592C08FA9EA4170A83BF278B5326C540013D2B4E49184B16A7468F218B63E312C9E2C4980964714C6A3254631493A691C5712940199D980AB5E4E8E920655C520A70A52A2691C5098AC458A04B4C0664526A5C329992300EECA0CCAEA3ACBE86A3E2C3FC6530BAD749FE78C5B494D47120BE2C6548D96198898993404AD261124620312EF930590814E4B1B1E4B1C9E4B158F25832792C91E4F3F924A308A7D3B5C5300E7C1DCEC09D9304D33C79621C199D348D4FC647438D5E88A35E82A0629CE9D39F5FC47F875FC8EF478D6451E9EAE5243F252E29655CEAB829E360CCC1A8A2CAE564020C560399A898DA009EE0EA5B443270E4530C75866F21942CDF62F29A0B2A5F4E421FF93A32296E2A942B97932B8B19B81B43C7E7839B24835677F6D584E8297138DDB5283A25256EE298C4B858927F7B5274726A0ACE728F7B6F52A202E6899CA698CC271103875965D0AF2A9212A7F1E3E352F98A2470B684E8A49838DC954901C6A5F2ABC86BAEA8382526392E2E897FE03A8E50E1CF786FD444AE20ABC82F00E95218AB884FC1B92E89E3C6C691FC648562620AEEE2113B0EFC01862C75DCC4B814DCCD87013240B7D3F36392A3C7A6F2C9958C429CC5BC1DA3983829312E358E6CCFEF8F246B371253BE78C815396E609330DB014B5B999EED180939A534BE4C9BE683FC1E0A76233F351C1947C67B74F2BCFDB77BC1D69C3DE4A80AD29C5A2317FE711ED649C655413A446601C34703FCB8899FFB69EC619EC8AE623BB45237384CD8559E2DC4DC2516A1C6AE72156A1C5AE359BB8AB487396876A3CBC69B5034196C29EC2537EC96D1657A9FACCB9F43D220CCC8AA93080BEC1A3789EB127B981BF9C09EE4996D7DEE60475EF1F46CA2E977645D5EB221333BC2CA8A2F4D1356AC9BEA0F2103479AD0F999A087ADDE6365ED01CDE186CB4BAE2FB9B9C4BCE4B725F797FCB9A46DC9D3252F97742E71C017FB9CFE3913BEAEF0F586EF0948C210CF8FE78F7AF7E9DD17F1F902010A0A120A517070BF7EA87FFF77DE412234003E2121280005A2B17A148A0622996CD428147EECB874E489E35234CE80DA0A7615EC2DD85F70A880ADEDA1F5D2F6D7F62BF0D5F6D10AB462EDE282506DB9F6E78295056B0A36179C2DA0693B0B961554149C2E08C3A222B0A8D158941C8B8AC4A2203D1D8345C560510958549C2B7FBC2B7A1FC3462314ED89CA5DF851883FDD0F8BF341EF6258328D9B4CE72633B06426964AC352E9582A034B656229084B45D814844D4382E9089B81B0F7113613616988361909A622C17B48F00112A4A3AF66FA7F95EA83A5F860537CB0F77DB0F56EFCD56EFCB5EEFC225CB402172DED210A45A2656C510012052251294B94EA87A5F6C2A6F0B029BED8945ED8077E82F89EDB3EF016547044E51E28A2379F4A5388F7D4D94DB8421B28E9A3021F2A0C94F455A925012A83245045CC50C922955606AC6B131CD7EEAB80984B4370D0B56FB4F37A5338B60E679BEABA508306711D249C7CED1B3B03A9BCC0B3C56C3129E010B4CD81B1657265BC5E9A7579F786CC207F95BA2C1E328A82ACCB6A68769F05E50BB4CE36E554413C959C6467B73731704CE48E7B468858B85F84888607B649F1EC326D7C369B98A4E6BC8A36F2D9A34512760732AB3053B69E6D5E8814663F1385B49ACC2D967C47D4152A57D1C9EEAB3A984094DDC4816DD0609205AA6AB345743D47E104506806A0CD7E4E1A3680F43C05452462000BC8047B4C4CDE9E0BCEF4A1DE00FD9C6A9F49AED36BE3A1ABF2ACFE5FC959EBD62A0C937673F65EF986BF6FC17E5D1DE760EBC1870FDBEDAC9F1FB6DEBB773769F8A57B97701EA788C141189BCF19C346904AF29934764F34293A9A13CD88EEE91A854D4EC52647A7228498932723268A1A476331C5489C8AE8B4A158542D8B864B68517B70066B187DD23C8433125DF93B188835D14DFC0183CE32BA8B0B5934D6841EDAA9188B16EB215E0E27EA584FB1176231933851B3E90C349C295E4C63E0708B467468A57FC060B0A035DED91207C25E06B789389DBA0D83603B9C1935968E51B8CF1800648B576288359CADCD71B6A2965138B6F85D26933E1C17AF64E0CCE1387F07CE620DC7B54A381402700A03D4E251D3301C1FCE120F411806B7C33806AD49EF233A055C42A7B186BB6857B0C01617F1081A6870894A603018231860041D6E51BB990CD60846BA060604802B300C1FC110D4ABB938920F68D7084FF0199AE3A2417E6DA3F96D02D452671BA393F09554A2A35387FB0AE273205B7066D9658DED2DBFC4CEB5B4F16C2D372E08C70A938433851A4880EA24FD94B944D33C39068CF274608594A8FEAA85F74DCFA02349BE838FC472A92BF4E404DF7E278DBEA1272772FB9D4CA44C60217C80B1D48FF30A4EDC72DCD817C2B38B6469F6234FC977D906F67F3012771A6968614388169E11312C6C9E4DA831469F93E65A428D7A4B1343ECA6670AEC154429954B3461D2100743E4772D3797B8924B9CC96D277EC96B6BCFD6FFE07CF271ABA64E822A258E0A0959D1B02797989FBBD09629B357D8B2840B645825A4CB3AB55025B0E40E0F374039020834564F89BD02B2318570AC2D66E52CE83E106A201132D6CB47342CCD090DD58426858EE5BEC8650B3A7209F33C391352248B05BA427C908BB340248F8D33400BF4DD181068F4F1E33C37C0911CD6F56F59977337641A9A18029D9AEAC0604DBC5CCBE2D88FAA0C9B1C151856C9212B36A14AAA2BFADC460D713BA78334C8EBA97326A37D348029100CD05343E93BAA2BF24D2A83A6B6B1097B4705649023EB2B9DF235307119B30D365B6FEA778F3B1017211E1B860CF2C89379A019C7A089E5E1DB0091146EE4E65E46EFA4E54031D528E03F11721E1A008B6D430D4D150294C7A30BC85C8D1E9418202D90AD9B552B4048441720178C83885EF92DC4AE3C0BB61A83AA6D06CAF341D8278887724BDEC9CA5BF14E26951B3C35583DF583B32EE7530FD3E02C41C2568ED3303A8DAA435EAA4F72E292C06C0ADF83245D10E98691AE18F2005746188BC4982D843C9FEB862C7EFBAD9EFB55DC97A49FA65025D4685586E19A92B4726AFFD48561204033BCCCD9F6F6AF15311FA609A718000C69A121C4943F79804D9918F2737EAC91F3BED1DBE8E512F4733E806DD38DA7834CF92FAFE70B7ECE1F2E14750289617CD67C414B8B1DFE5988039BEC160B41E6437E6064386415B3CC49AE7BACDA3D6695ABC1DE22141219150FD3E710EFACB25B0CAF79FABDCD73C60C470073983B6920641A2A257EBAAE61CE7C48C19CF9102439828F35B6193AB50F8B28D408504F8EA3C5129AF71DFF19E4548DBC9789EA0313D5AB8DCBB64D98BD2DF63D6DECEC054955C7053B81C55EE1C3D008A9A16B31F6BE21E60E460307F9D0456EC405CD554B2FFE3D830F461CD4F09E8A8F5C197AA455B2BE75D88E663838A99B12E26F5C203CBF10B8F3EADB1AFE2CA60E53560DE15F00300C6D33E13CE24669C31F455D40A87C98A777CF0ABA5AAE86E86F8BB95E6EE8E250EBF992EBE54022A7496E97BF66E677310BD0360C61E0468894B92E89E0E3768D7B84C885E85F448C2D68D015DA5B88B602BB853A1E1980C0BECBDDF9FCBE3184BD84606FBE5559D24ED415B641ABA5A59DC8C86FB300D472B321231FE474E8221A89CD2582E282861585E630576490AFC6E4E9985C8CC9397615D71EE6CA35D88DEEF375C4C022D02577F05CE5761E2E7FC6A3C95FD9556E76278F0E93FF683FEA0EB2FC4BED1A57ABB6C30B4E79700064DBC3185A504FDC2EB46B3CAD2C111D8480290DB7F3C17E3949FC5E0800C1D0C286115A41A0B31C5AC81B0C55DE0041FF425EB0C0AB9017481549820E2D6F9C805EC88B15480B79A1824985BCFE2DC4CD429E1B553AA549E9C4A2221069910517445CD41512D3B520FD410B202D50A7C89C7800B64020CDB77AF2CFFF2738040DBB861B6F4C13C960F38D507816520F4CED6758621F6A50EB36D88D6EBBC4582374CC3E82457560A55653CBA785D146E8D48FD8306E56B6C1CA2A8360028C6781516AA61873D6773319DDF6DB87538C4E2B70FB198EA89D17D2D5E8C0A8E6535E6F6793D585F3B06B384D341E136E7A1A00551C035565F09E12930B734EE14FA5F45CBCB356CDA73DF23C08D3CF33039CD711D2B7D283CCB36FC4A78A7A8819B6D8A9E1ED466E5BA4916BD73037A4893C2958DA6B58B6C18819B16C43D0964281AA8A3A261D11B9B6C0218B40C8C27B4CFC0A83C278045EC100C365C20263BCAE0383D339359DBF94DB615902B096EA1FD5D7DD9B2878F02AA2B4088EFD5700D541036203B8A783940417343A9D94AAB443D1E5ABF591D7028ADA8F43764F21BABD165C369CF2EB88C686CA1270C50C91B87B2C7D22F92C0AA0E30550B7703E939A1743FBDF23DC76138A70C35B93468BEC9EB570E7006AB22E1751F1D4FEE2D54B47C7B3767B12C738CE6E64ECE233A0B482CFD6361ADF558858C6693A399BC7304E6BACDB63F5A4720A038208F6482BA99815A2AAE2F56DA106ECEE43812BF203F87EC87A5C348FB42A6BC1F9714B2C10837E6D985289507C6CDCD890ABE5794D51658AFCF5E05CACD165903209FC8BFD20B8DE08B95E9EBF9E9D0761853016B3E33D4858FB86E0E231C51F152F2DDE5D6CDB66B33107F6EE99432D244EAB2157CF4F8BACB13E2F9ACAB96BA05E4E0D844FEFBEDDF8476FE32D86AED7574E82D7147FBE4DF16B3705450324AF69FE789BC66CB8F19A08C8AE76933C7C9BE48E415D1B181E581BB8DBFA7CF7D46C168BB5DBFAC36E162BCD20405118E2411C6BBF70A34ED2A378927A699A2DE57A79767409C4C2ABE5F99E1020B2AEB628F2A0D7EC687FD5406FCE4B39BEA6248B3D9AFF98F8A3C8529F4D8D1B0C0D317D699EF3D540669BDEAAB85CB426DEF561CCC4FDD6F8FDAA819CE773303E72E9C57F244F002D861C8A90DEF1DE54836DC2BD22A70475D3686A809520E6614BBE351016293F5E76285341EC5E6AC91F640D8C971DCC541853448C85CCC6410BF39BF85962ACDFC24130E4DDC0816F800301D8605CCA62B189F2D9384AE3B9E30E3929F09FCDF670D8DEF360690E773453CFDABD843DF84FD95F1991D4DAA1F5F4A4926532000D9DF3EE1A12D248F1EC49AB4938AE1766CF99362EDA0999347B3549F644CA15CABD6BF75E27493FB47685B218854848B20F92484242BCBC42425EDFA74F4F4E1E3F3E39F9F5FD357C1D73FD172C9214742C95392AA817C28EA56601A7C42CC04BCCC4DAD2C6869F4A0483A1C9834B5802CBEE54098079BF07F860013DB180602CC0170B900028E444494B2E11566A093A5102B63F594A67B2DC3C7D038760089D0BAAE6770448FBAEED4DF3AFE00DF4BDD36B47CF1CEF74AF8721752575B6E446AFA7B694BA12C9BE925706BB605F8919C0B27D25B5E78A4A218382734756392C4107C9F781A32A4E3D66E5DD173C595AA7026382EA4A0C0A2B8B5A22074BFC342003B27F4F4F4FC9FE9246732989A3744693BBF8156CAA03B8A74BA8356494197B735EDA524E94E0EEB619274A72AD7498DE5689A694C250571D9C89AF3B1E8915377AE71C3EB7A4F46A364C216F957D046A94ED2FA96D949D8282572F5B35CB815DB118E0DE0533985C773D3CFA9026F4CED6E30AA1B7D0DB042BA81BE82EF4FE1BCB5450B896FF80FB0711436182C5F21F64529C7FFC975229ECDDFF4E2E45F4CB7F4DF416B5BBBBBB89D3F49F1941C9F8FDFFC30C0A6FF9EF0DA1C86EFD4F4DA1887FFA1F10FF83CBC4B96CA0226A60A0C22A37419E6CEA8AAB4D342EDA66F413F7B20B542BCC02D14AC19315C48665702E6AC2785CBBA01480B295820B14B04F134D6C8BD075510E5C29205704BDBBDCC4F382F246BBA985A85D661938D0D476B58FC136E37A79EEDA344DAD283167E354F178A187D4384544F3185F28762B233A969B726CB10D7F2CB3C59E1287C6DB628BD3D4C492151A13215F61923B29E5E34F893D280C5B4D2C5EC1F6819C22D7FC20D7FE2057181F9A0FC90DC381A4EE01884F0B603631F480D6C31EAD47016C28DD14B99225CB3545C235629EDE4DEC9BD6E4A695D2D5BC41EDAB6DB1C4A7CBDB1AED0FD4F6075A2943DD8090133809804D6E104E187A371EB35DEEC6FBF986C9D21F0DC08A96F3D858D5721E1DDBBFDCC5647E108516A0CF900A8547B116D09D15C4828C9D863C901C39689D1EAD729D0375A256A44351B4051E9FC9558EF04E562B5D473DE709D9B3C21673AF0873452E1E1C599432B0454C73B9EB1228A6D7DAC670AB96137F2EB708B9C5CBE50CDB36A1F768FE0B43BB7358DA4AB2AE04C3564A5B512B586F6F6CB970A3EB85FAD57A4B9D84B6C2608CE7DFCDA2B0978ECE91A5AFDCE70B5457A0021B6FFA4A7C7CC3C495C6A9FC5BEDC4A415EC36E2C395EC2B0D13562A42FC55567A3C438E7972ECF1BBF86C23F78AFAA82ADC60E4465E510FD90535F303FB0353FCC300B4385F8F67715E3C3419BA9A0301C0CCE23C0300F5BAB4FB171BE92FFD82F6AC30E85EB69BA8F76526917BB66DC29E15858A656BE2DB0CD881576D86F81CA3C6E481C01738C4372BAC9E65FD5196C9D4E2A2F112F6D178E5EA9969967C38BA056699380FBA893191A70797E7F65F73E6EAF1BFB96C0693908799E241A09042703A289BBBC40B29F99CA726032EBDE1B3BD4538D33F74A64AE8AF1272FEB25C35202BBD0CCEA265656B9CBDB14DE0A95C0CA3CB4C0A1CC9D66C8C90ACD9E8600A4EACE4D3056757BA381F8FED581954B7D2C46E973595DFE0F26B710447C087961BD0C449A80AF8B557DB22D8860B2B7DCB1FAD9495EF2D5F547E83FD1E95414D111ADD028D7E467F63EFEEDB5D9570A1709170B1F02E6CE3B72C86BF09E9462F23D797CA209DB7BB8B855DA4DD8409F1D9173CC8EE03879737A703F67F5BA6F0CD3FCE13C30D8F005BCC98727600D2381FB37469E7BDD6CF7B63C182B76CB86AE9E2CBF9079FD31823A7DB1C67C569D08237265DFD17939C46FD65A97FDB26CAACC706DDE9655AEA4F2521A59D5A618BF9B93CC8546EE86ACC3095E79D1463A9B9DF8BB10F427E2E579F1663E9F927AECC31E4EBE9D6CEAC3C6B6726E48706C26515CF4B9E70EA8A4F028F4B3C288776AEA3ED4ACEA92B8E04E97DEAD8448C5E463D217517C5A559D922A16DC2D57241804A7D46CC93FD54AE0D9C2AEBA33A2975176455DD20B6AEBA0AE796BE14892C407542EC0D146B2281A42F90E0828555402158EC2CE739CB255409A9A73309680CDABB8AD8BF4A00FBF26322A2E28AA4A93CAF6C6999C918618C589AE6B3ED460BE4FEB1F1E04A56869ACF28D3F2686565ED90C4D627E0C8E5A18BEC46B9957E7EC94A98BD583D9D3AE4299CF07A13B034D19DE7DF800A6AEF668F0EB47A503F05A2F482B3C53F08AE08A99054EC283D517AA3F479A967D9A0B2E4B2FCB28D6547CBCC65AECB888C0AB5E446798B6DC6D572A2A8C2547F854D0568A8C2686B207D7323E654E43571329DCD4C39AC31B9962D246A2BA00D8976287B7FC3AE8D396BAEA8D75DB1C566A9D74ADD32B3574F1C8C4EDCCC0E376465AF55E4AE3DD11F510DCD54E1CC757AAD42A8295BB7565F106FE0862AFD430628157546AE08F78508B2D0200C1AA0A49E04355CA8804822A41EDABC308869626DE9CC92CD259F96649554C1776DC906F832117CD854C1A0D39888FAABB9AEC213EE5440658BDC741CACFBC741749BCDA5EBCD2FEAD9D3DB1BA113D45B86E3E1E1C78E85872301BE19B2CF89025AE5083E2B8C2EA7139B73E128E75D29636EAE1579CBBC2A6B45AE324E65B8AFA472168F2E616E2604AB6581958EA562CF3A896BA52C42590B39170B10C0612D686CA0678CE0870E27BE2C95B3CFE56412963C0156A9A19E90FDE2BD5AD0AB92DBB712A323DB0159CF4AE06918945127E95329195C2948A8B40B789584365F22A96C17845412BF945365F0AA3688D7FC4A0A07101E0591E19BADAC869CCC30E4CC73E9E7D6CF6AF86A01C55E27E15682CD44715537BD6B25ECB7C9CE6E30C2102F610405AFDB207585340E3A3B701D8FCB96E390DE65C065BD34701D8C1D95ECC1F5084864F68A40290EFD6FA0AD9155CEA27EDD1871CEB19A67A3A821717C4489F35A7FAD6A8DC81F68ADB473AA359036CAF8954DBDAC0E390B0436FCB51A46C657CCA0B25C39249D6EF329E180A1124FB8AC7C5E975162173E4B8E5336B1403565459DC4B392D8BE96787FAD53B9750D716D0D5BE65619C1E7D449222A25632AD9726FA9B79CC3931097D6B005119562BA600C3588940A18359977A524D83976BB37117FAEABEB1E98E0550DC3D6099A2B46F07F0EC30416B833C368C4E14CC16F1523E4BEFC73727158BAA4B942EECB3B16C2591FDC4FE4D2E27C88369FCF1578C288869122F72EBB780CA78D97D6C81904D523B7FDCE61E0D36114A88180F113B3FE365EDEEB326A90AC918B41BA018615C633904A9903A5CE9C39D0D0D10A89BD5BA5A827BB0E6E720C84B2059CCA332A587E64FBEBE753226FAA17ECCDE25E326165476B849C797EE0BA36AAEE2911561A2864467E3D95B6340AE895232E806BD3E4085CBBADEBF11610B4504FB2AE65E4CB990D03D75136331A292FD151B6DEF44021FD2AF3BE1351AF89CC1AB6E35D11C311C6C7DC2FC86920A45E84B9673B8F5BEE7C9AC31556819CDD2D84DD28F0A894AD9955CBA7872183867A202A77813EC87A54D6F2FD9DFEBDE10A486C0972AFC4A2AEB41317346D9686DBF94ED5B6098195381D882E8033D44BC3282718C1E23C0A71AF6CA17EBDC80DA85CF8B0B76DB76DB785F0D4404CED124298355D5E0825F5306521CB20E0569EB9A932C022D4C9B89565FABB59972BBADE5E3DA89304554A12C0625876E097929E95EDEDA31D0C31EF114605D3794ABF2481FB7A3FD81E76F119D992C0CAB6260CD6AC74808321E23B98624F41B432504CF316064AFB0A853C3F6FEF40F952294D7ED2AB8DE72F7891CBA30B18EBBBB6B8363D2BEBF27AD02BE154CAB5B0DA057D2BB9BDBA963F657DBFCAD02021E59CCE85FFB28A725009BEB9A1B84A965125F1AA3440C783FB3572D910D4A19F0D173403E3963EB3BF723C633368903B12BDD7DB35AC35BC4F3C74D4F8359AC17A731292C52A9BE8F633F84D73124D3646A9A741FD8A390993C538E14C80D30D0E32DCAEEA615779E8EC4697B1CEA9E7F7948D523A7091AB83C57791E360AF8168DE5C473DEC6135E9409F2D86B35ED418216A20AC9B12DC4D768D47AD283AD33EBF47D7E2D0F0879B8112371D37F14308F946713FB3D12549E46236BEDC6FD6BCE0B1CC4677A8B875342BEC1AF7ED76957B5D78C3B6CD6F9E97495F8B69ED16C3E740FE20DF6811FF6A5FD2C3FE9907AFEE84897F5DC65D5FCB27BA10FA20CE7AC836A9E836028272933B30799ACCD47082FE20B8F3CE038F9F93C7FB35DCD51ED603D9C33C10EF1D58DDAF1B79B58D4E03C064DC6C7C91C16398212A52CFB2DC77D5356106E8B45A8FC747284CAF2DEEA2677C2E6A03834DC74518A8B2765B4C9147334D7512CEFA371D8C7DBB83A613FC3EDDDDB3D8A941B13E56986158CCDDC30283080102CC6EE8223A0DBB1274F63B676743A0B320C0FD4D57FD78A780C1DBC9D0E33590212779740A44FD0EF0DD8DB9A693B9A62B27AFE49B4EE79BAE9C3698350CA382EF1328A75F460A732973EA9A3569D9E6523C73CD9A2C43A09463D630F58CA94DEC34F37C7C56F020A0C7F58CCC267696792633A5675F0303214C80B64F9463B581462EFF956A20FF29F54CDE5AE0E048877371BCBF97639294C965B3FBF77488C59EB2DBE5569A0FA3BFBB88E183FA73D445596BD76766172BD6AD8BCFAD0D8493B42164EF2AA1D0389FAD69E238F8831962DA60B6BA24AB499AC9CEC6D97C1ACED02A9ADCE3E5748A56E65434E9DACD2F40B6C6C1E98FC413B26C33F6AEA27EFAD819C1EF0F040A5FD948A594E1C07934075DD45336AE6A8F2F57E4105C715CC9968CABC217F032F2A91F5B97650D183020776926F7CA213FEE6E04F0B14D9CACB2922C9B0D1FC0155FF0E3A6233CEAA19F89F0AF32FD74FA0B674F7498983A893D343489B3203F28C9BA8C366452BF6DE0B6DEF2E326205CDCCD70B3E5C6439FED4941C417905BA8E09220348DCA2FFE845371D3A4A92C16242DEF03E3435B3237FD4F3FEE02844BFF85D7B34A3853E83F53150A7C6F49B08204AA9F5656447C57C696ED7CBB4F45B2A8DD7EEA5D22C8DF6E52691B95BFDD8444CE807AA3A8AFE655A9AA6CB65E6F6A3E4892510511BD2AEB72D5864CEE9C2AE7BB580385CCAACAAE5A58955BB5B82ABF6A49554195C00BF9B53CC49880D734E15EDE42DB368BA1E5029CD0232AEA2D576C3332AB6ED80ED85232AB2C2D760B6C6A3345FE980B6AB11D78E8DF415309C3109CD0844180862037DA41130B85422755CF162260D355E2DBAA16E2E92693BDC502D1F55D679D17FF3749F4BF920CA6EA723A1BA2DB49A91FC4BED3701E60B065D1CAD1A7C42E10FF467F2FA6D5B14D6CD8FA43E6540515762FC61E141F91F9A545FC672DFFCF90C2AAAB1ADB3685C6ABF7A2D0C573320FF299219F560985A1B0DD68BC160B17195A88039B2C0DFD36390D716921CE6EBA4A0D05F56BCF1B3987F9B86DC69CAADEBDBDBDBBA464CE7923E12A0834106D9B606FA47ECD61A05E2B6B840A763624DF636001FA5B313D3DBE4CA1D14E5D930618EDD8CC35596AA064C322E46ABA9620C0C76666050FE259A74CEFD9175A7AC6586A29F29A34463F299E06543C206438092948162C551EAC560688F20251CE452FA69F96863BC380987E52FA49B6E97836D48E4B7DF38B0B9DEE6B828A29ED325A37D5962C270DF9C55900317D1F09F5376CFDDFB0F532159B9C6CD9C5DD3C5D84A74C7264C8369DE8BA7513F734957449CEEE5A295D0A4CDF5344D4D9BD1D02A6A94DC2DA4CF036CB589B0DDCF0CD3720EF2ED473B32E6FA1F650C666EA1DAA909ABD1B90BD53C1D7F82EBF17645D5D132A6C2116AFB048C5FC561EEF4DC875E902F6E5B7527B015DE05F496D775DDB2560AE0020341424C9189B9D919F6DDEF5D2AC7AC9C3CDBBDCA948DC84B53BFFC066FF66EA0F6CDA0C14B7A81775126CA4223F7F58AD280018A7E878BE666A1FB55318283ED7D58A98760A2143D4A10ADF5CAB93BB539B7B518939CC936D0E6368CD5D2FFBCC2A57EA6FA0E050442CCD69D094D8DFDB1AB0951CB905A157755B23B692D3A1E620B79EDB426AA0F62CBE9ABE95DC0E3593E56A1DC1DD2CF530F5EA6B82731977B31CBB526770D66ED6CA69062080432950704C3DFB7453D0AFC819B5FF350D4ED130BB68A8FA4D396EF8A71E27058BD28377C9C0A9E4FC5AB5668DE9A4493A940FBEB9DAE96AFD579F1107094DD9A633E2DE9A75702610F70C37389126A9ABD00991D2400C59FBB7007030F39A33E2875D64A27A9E0510A65CD39A33D29F85A25DA67CD3EA335242A829A6C45DA833BCC60AC5F742297E505B275C7DE6A2790BAF9630548B861195D5F260E910B3911C0BE17F819268A896061087ABA57C880F4D0C1E9C4D1C6345EED038A5936370E2093738EBB05F9EAA96FE45ACDEAACB77F4933F83F3DD2BC809E12C448915139B28B103416C1288CD728AED4D7C5D2DED0BF1A65B2C1C7CA0F1BD4E4EE3D53A2BC0FB0D25F3DE565D2EC87448F7CBEDBCBD94BCA1949903A58340DE149037DF29AF0F65660044357D97BC2990864288D3C9E90D2BB73A6BAF8D1C51DD50B3B54BCEA6D7722056CAE675CBF99A9213FB5ACE4C9003415227675072A8DA6BC3F2AB1B9E3A2137F3CD673003A5E366AEF90C32C80742C5116C908BA93B1FDA40E26C5377BE61F54D073DD2B934CC7038A69E17080370886C6CE7D1225E01718C8131300386310C1F7D94913177AE1A3E73E766647CF4113669196AC06B1C5AB1A0892F1D4CDCC81440F0A6D5D49E3F5A639B806AB2F50C09AA9191D50D7F165B0B883D351A485F60A9D36B2CBCBFF4D4817C68EDC5BBC54D34694F1173B484566390A11A87EE8A9C4FFD50FD6908F082B03C114DCFD6B333074705A11A83A0A046441794D504316A0C12B25A80D7F0FE12ACAB81FD2F0A74F17E87DD5C82D5F0EEDB6276D50876D634886B7006978C87E394A06CA1C27690F3CA80B3058FAB61075609BD39CF050C0EF771B5E1460E71ABE66A6E7BD70FEC786EDD153E4DDE4A3CAC69B37AEAC5D41F42B9506FAF7AB219A8F0C4760B8910D4B4C75133897AB291F31D16A2DE61419D7A8B85C89E18EB350387BAA9118F2403D438FA8A24E7B299884BCE0D60E3489C013816CA70BEF1FA0828D8AC8F64D365391FE57C433A31633E1A53A42C82861F34DEBC0DA330398B923F455EFE5D8DBFDF9341E3DF7C5346F1C3E61E0C57E2FBEF2F7D7F31F33315CB690A5AB1A2A82827A7A8E8F5FDD021A48DD2F1B7A53773564FBA223EB0A095BD2CA151B47BF6EFBCAAF76E4A8FAB9F3396C69E0FDEF1C9BD9EEB537F1A7EE4B3BFDCCB132F0DFC76EE9F7DB6BCFF4BC4E9BC4E5AD19873415F7DF49BD7DAE46B92438B9EB8AE187F3164AFF20FFF2FA7DF929DCC7989978ED5F7DF9561F5D938A529ECE8E71D1E15499707EF9FFF28A07AE61DF9198D032B8CAE176CFFD0C25DF3EED5A10717B6B92C1F6718B067CE03BF4DD34C234F64BF6096C45DE8B773564BAF0D936F8CF86E497B8F55138941FBE6D9FA6EFDC03CFAFB7C3BBD38A641F8F5C777BDD7A55C1F7678F153B795138CA1DF7CFAB0F7E619B7479DCA7DC52A8BFFE19DDACCFBBE5F4CFD39FC98EA9967A5E2C72175598F036BD27E8D3C5B4076D02ED176D034B4E934298D477B89DDC11AB0BDD85A2C17CBC092B1486C10D60773C7ECE831B2A01BB0459E4187D11E548336A20A548A0A900A2D444AF4094A43D3502A9A8426A078148322915970B1FE61ADC86DB45970B55EC4300B6ED69BE733CD1978D7DB44F362A679116E5661AF0C02BA2EE8C7FAA0A6FA2073BDC10E6C38DD3E9F69CFC0613FBC409C3A570F39B7DD8FF310F23FACF6DC9C867FBE701CFCD60B47BA2E0CD99730ED9FE1760DBDB6D13E822EA243619F49B76B909E3DB541DDD0FD22F2F77A3F8D5D8575BD88B4AB18A2CBE652BBF335416B3D9CA53280BE6C2AA16EE8F93E14F6301AB28F450CB3C6E1E9B19465C438AF04BFD6EFDFBE5F95E6C3A2F01A9A837D05B8B9CD20D65C4ADA5574DE0AFB08CCAE61D45EB49EB30FA7F16E6376D2F62E7ED636CDF0FAA56448533D97AEABB5251B04A7EBCD82150D664115DCA9FA1EB876C27504AEE370AD824B0757365CF970A5C3150FD720B8D69EC3EC0572EE535BB6A4B2F415B1BA946A72BA9B06CE0327D6964DD45074B2CA525BB6C163E1F0D2BA4A69E9D605734B150BA4A53335D2D2DC82F74A7F2878BF745A417A6970517A69EBE64F4A3DB7CC2E4540F3355C8F66CD2D8DD1CC2D55662C28EDCC58533A7C9DB434B534A2F4BDD284D2D8D2E1A551A589A593E02B087CC95D67C7DE9F6C3B0EFA04483793D2AE39D52868ADE1221DB69E6E3BF0AF7F44ECB4D8962D58FA35777829B6807A2CF1D7D718E9459DB3A807189C0EEEDD0AAC27056F5B3A7090080B1E8CF2C2C881FC57C161A42DDE60B3F545187CE9ACBB7D7C873DCAEAF8C5FFC49F074AD33F4F1F1325B9ECFAA3E4978BEB42CAC71CFAA3E28F63CA937B4F5F5B736BDFADEA935B5C775C3CF8DBF63FF67D5BD1A7FAD2AA8FB60F2CBF5CDDA7E28F92DFB6FDB67AFC49D7C3CAA3E74AC376377D9DB84A7C44B70E5DA2DE9B51CF75FFA1EB4EB7AECC311365D7BFBAE4DFF4DBD693DB9F54D38E2DAAFE45A7DE423B76BC7A3E3F226BCCE93FB5397B69270F6DFCEACB431B0E6DF86AC3475F5CDB90BC6FD177C91B9E1C53EECBD9F7E7BE5DFB7F3BAAFEC2FD944EAD9BA6BD89C49436FC5F7B76DCFDB0FE93FEB3BD26785D71BDE67AC575B5EB32AF655E4B838ACF6969FFFA2D3B57F3A4E6C959197C5F1E7CB9ED8F5DAEBB42568F5FED55FE9ADA5D2BD6EA8A51393AF09FF4ECAD51945D0EFAD1F5E69335EE8782BFF2F91ADFFECBA1455F97EF5C548AAF7C7F597239BEF6F4EABDBB193B23B6E7BCC788CB8B4E3EE0BAE2E59843075C8B5E977B0FF817758CD9768053D43A3BFDACD6D9AFBEA800FB8D551E9091BDC5BA68D3F94CAF2D890725472E1D961C693C1C72E4F8E1A02355701D3FEC7AE4005CC70F7B3971E70FFB1F997D70EFD1DD87F61EA2AE1D87D61EEDE2EB7F64CBA14507CF1FF33E9DB87CD8F9CB87A5979A0F6B2F23296AFE576D399BEE65AED5248E942C058997CE1FF6BA14BBC64B1A3BD96B60EC442F51D71520FA6C62D3A0D48953A86B406AF1949DA987A77CF7FEE145DF5156FCCFB46D09F8387B9575C9A60D99373437A43F9DBFB2F6DCA54B87AE5D5A7AC8FF52FAE1159745DB0E5D6CFC26A4F1C0DE8B46D1EEBD1777EC2DBAE87E20D949E3BCD61CCA4CCC93882F15F7BF04DA969FCFF4CE4BE40E5BFAAFDAFA208D53DB47D0B78F36FD95794833FCF821FAF0C443C3DEBA0E0E3F7F68CFF0F5FFE9F5F5F0F24387875F3AF4FF16D2FF5B48FF6F21FDFFB090DEBA3E5A73E9BFD086211CF9A1746C0B9EE3A7F9E4CC963B390E8DE38CE38EC3D1E178E9E8749CE8D8F6BC4F67CE098DF64C9FD7B83798974ECCB6FF88D9FE12EFF43F3167FB2EBCCA3F7D8E7617AA42E988FAFF21FF87FAF69E78F275848FFBDCB1D3DDC4C26DCC74ECC37E3A4CC7D4094E300F60CBFA1DC02A9967A0BE0BDBD4525B5FD3EF74FDE1D1E5F6C36D95FAB3BCD3E907B5A5FFAEBE5D275E7E3DD0BDF4BD15E295B397CF5EDE487D572E5BFEFABB65F9A1E55F2DDFF237A47859F932C9324371FFF2AA43E9066DFFB7F5B15000CAC6EEB36A0286657F73FF9B9A6F869DFAA6F69BEA6F5E9CBA5F5B5DAD7E61BDBFA55A9D7DEFFE962DEA8F17F8EA549C9E0B04CD235A4737F75DDD4F2C3A30F8C0906D9EAB831600E4DE07FEE94F465D1E2B9F7326F7C5A7F74F6DB9B8B8EDD27DF116DD62885E104FFE67FAEEDDAFAE5E947DF1BEFF96BD8B953F5E6CF87299FFBABDDF286B2E96BDA915BF0D93957C5E96F8E5A8D3F70F6FA958FC02F4F5D13DFD77F43543FFE4EAB196975FBCCC72FFE5B3934717CAD26F357FA9BBA5FB527B4BFB8FAB78FAAA90234FD6592BABCF649FB85FBBA5FA9FFA6C3626C274B4281A1FE3637DDCBC460C1DB366CCD5A51F6A31087658D5B8F503624F4590EEF7465F2F20C8E1F7AE5F8F23B8C36F5FE7296C02FBC5BCC80196532BA491F9963D2B46451EFF30FFA2E8ECA90F4F5DCC3BBB27F2556B6B4BFC8F3DEEA86EDE7C67C12AAD0ADD440B90F6DF5477EDFA18021FCEB832376699C702F3F34F3BC33BE367666D9CAFC99A3FBF3AEBDBF0CEF0E7BD9FB85FA68BD10FA3D879AAF75685ABD837550B7AFCAFD5251192E145D77F533C897C096EFEEDC97B277C0EB91E0D81CBF584CFC97BA7BF3DCB3BFBF2EC93B3F7CF2E3BADD2AE2A532DBBF9ECEFDE754D1E1DF9A329D814E63C5F65F2A7736F877ACDF8EE76C6D11353074D9E7064D7A72F77AD38C248D8F16572F2949D7B661D8D136C58F15372F2DE357B37CC23A6AC0AFA697C9C72DFBC3DF3764AF69D5AB5F6DB0DA9B79BBE1C7BEDD6846F66CC9917B7EFE851E5EEE9E9DF68E7A2F7FE5E0CFFBD3EE6B8C99BBD52A67CFDE9C7CC9851C57F3534287A9D753DEC5BCC281ED5D01EA357F48AEC71B857031E33B2B83DE6E28FFE6921D747DC4DFD3AF4F09C693E7FAA3FDD76507B0712BE37FADCE89B19D35937983798B7E3F47117775E2C393FEBFCCE6BB39A769A66E9675DDD79B1E55CDCAD9DB74A880BFA9DD72EDC8A83DA4EA2E45A8971E7B99D3766DDBE7071D6B916638971967996B9A4692731EB468979A731EE4649434BFD4E5D8B6E96CE1A15A34DA75CD3158D464FE984A73CE2C9E28B8F237E71981D873413AB6767A4FA4FC7E3D863974D4B88D99DF8DEBBBF8F95BE773E463EF7B7615F7AE48C7C79FFCBEAE9276EFD726BFEF463D3677C39F1D69497EB72369CDC71AB9F72CFF071D394B16BDFF7AFFA6473E9693F713A6CE5EE5DCB800DBAEED3BFF4983D72EEC747CC47AA9B32A76FDA5B3A697BE9EEF97B07EF1DB83B7DBBB6545435FBEEEC9547461FB9F3D3FD7F07FBF1F6F2527195EE2E1C1BBA963807F1900CF58664FA2FDE5FC3770FE749FBF4944A7BF6928EECC91B7E77C4A511E2F7CEDFFD3FA57D0D6013C5B6FFD96C9B0D25CD862F9BD2D01441401009146D0AA1593E2E70917FA94A11914BC3870115A450842235995804DE1505B97A05AC367A45B1A21445A802666B90F2A4B65C05AC14C9962241A134A5D0A634DDF9CF6C5A04D477F5BDF4ECECECD7EC9933E7E3776637E9F0F2E166CBC1EEC32DC3BB93284257916A345D91B3BBB76FDD43FEA6DF73E35506D29FD8DFBE496A77BA540DB7DFE35E76A82ADE3EFFA5570FAD886F9EDFF46AC38A40736193ABC1157016AE74CD77C53957AC24FBE37E6F7F7085D48C9A08C29314C55805F1DB20F949B87D32F47F10EE9D09F119A07B12966D83864F990B56760D6667D6F08F2075726EAF21AB62021B46F8553DCB61E53EE8F17CD553AB42F714E897E4C1E0CDF0C40AFBA057A545CB84A19B6151360CFA507C62B13868375A940B433DB0689638A8507C62011A540C8BEC30F475B4280B0D7A0F9E2067D2A330B4102D7A100D7A4BD973099ECA82B46A947A0678457BF139165745E3621DDEAEC59E6EB8D888ABF4F8451D8E8A968109038480F48874492D41AE08AB447ADD52046DC0F6476C35B0AD08E280A9475008DC62C4D543541662BDC0D890CE0FBC1F4579817521C606897E64F283C68B3817A85CA897174C5ED4C9056A8C180C892E64F242372F8A710183910E83C98512BC48E5127BE1A00B53D8C002445B609E16A646415C14182F027407E62B806D081E15A047360CF7408F303C6A86A2D3B0EE3C245F82B29930281116EE8023CB61D015E87C09EAB4ECF93DEC7DCB60501368D7B30B74EC8565F07C130CD6B2135FA4F5F79BA093965DA8637FDACD90736277334FEAD84B57D8D81330783234FD93F97E1933FE223055C00875753C608CC3188726E08D23317C8DE12A463DB027164334664497ECB1C9765ED673B29995F58C6C67648F28A31A9995646E34EE03D8DE5BF66563B601B352B8866995CCAD639784F38361E46EB5436BAD5267985641A9FF4BA993FD35BBDAFA0465F7AE3652971A5A99A3E1DEA3E5A0BEEDE89236A146FED487DB2660D95B57A7C5008F01F30EA8B632E71EE3566ED33D33A997735BE2E78FDBB27A586DB78F72655A0BFB99661D494C34F2A3B6C78532EEACB10F538BC6E3C27C8D27759E277D50D2D2E349C66D498EAD9ED4C73DE99B3C4B3FF0183FF1388E7B2C1F78D25FF12C7DCF633CEE71BCE7B11CF7A47FEF59FABEA757B5E0D821585E41E96761E95B607C191C9F41EA41483F064B8B94CD22B04C85F47EB0B40A8C76504754517E0CB7BD23F7DC1A523F1664B649CCA452D826A2C791D003C1ED6EC844A89F281C11C12831EF1F8587B6338B3F52FB0B8E67CDD76CF874DE86F441FCD2E37CC136DEB195FFF4713E7D13BF74075FB09B771CE34B76F0E92FF34BB7F305C778C776BEE4189F5E45375FAF323976984A5EB6A59F752D7D0B17BC821D9FE14FBFC4E9C7F1D22265B3089764E2F47E78E9F7B8603E3E57885B5CCA8B6E2CB1836C48CC85517990B61F5CB3120AD2560E76AE39F646F44333554546A68745F5F6156652942AB3276C9BC3CC980A6F15C15377C18B1FC183D3E1E81AF866197C3B09BE9D08DF4E532ADDE1DB854AE55EA57C1CBE9DDA5E393A95962716C2633360C51C489B0113E741C65698F536CC3AA99487C1510C061138EAE570D886833C96382CB2D84D6CC97D1684D710ACEC0D6B8EA2A732465FDBCEB47467AFBD1DDD3229FA5A66CFF0B6396D3332E5B78AE4A706CB2F7E24B30FCBB046563D25339364D55F65669AAC9A24333D64D52265CFBD4AF9B8CC642AFB1F97215306522EC23003C31C8C6660E1519CB1154FDA86A79E54CA2378CE5EBCB912076C3844621811602D30AF429FC970EF66489D0E69C59096A1941E98590C356626B18A0D9C625A3E54A71DE12B3398E60589ABECA6D73DBDEB50DA7234760F9A580DD39F80BB3E8041D360C034983E03EEDA0183A6C280A9307DFAADF5FBA6C244B2391D667E48CF9FB81C264E87719B60E83898DC95FE3780C9C320A702AC569872996E6ACD911FAF270A09F814E0ED808B019700FEFC0632820C10718F1D1E324AA2D7718A873421B001D834E032806B3D723D0F781D6003E0F56EFC3C83D731D8C0DE5AEFCC608DB26944989CAF01BA19058A7B544A4185B37578FF28CC07717E291D5E32CE64B4292ED00089DB248D032BA4E5015B0040BCE33D000902BC20406C067C9901D11910750CA27743D40E885D009DA7C3A7BBE1CC0EC8D80E774E8719BB61E20E98F83FD43743F5327869A142D3C13D15464F847FF485799B61F33C0814406E2E149E85F99BC160078E404D2DD05FFC6BC6F802C67518FF804B0F607806432F0CC42B45D9889824C487800B895C08D810301DC4862931611513D6B3781D8B7B2AB2D1FC7E5DC3CA0686FA574A2C095D183A4A142D4BBD70EE2AD95483B97C8C382C9970C8457F885081C3001C2359B9D6A3FC45BDA9496FBAACB73576B33526DAB0C186ED26199964E0C3844B60481834D07ADC35883F07B7F584B8CBD07D2BDC76F2FF4489DF80F614C47D46DB4C4C84216D90DC08461DBD1123298A886512606493D822417348557F51ED6F3AE4BF7CD0DB2850C28C17737ED9E4975DF56DB8B915B7047090C112E0A32A5CA5C6277AE2EF2EE3635BF18993FF273AFD0DBEF8032E2BC1A51216017B185731EB3AA5C3E4A60DB558365DF78C41305581ED22F43F0B4F9C83B873B058864219BC614A8521581B84D744386BA6F52157A8CDDD351C869C853B87C3E0DDFF7B1AF536C497C09065B44162CD59D760FE39B018C144144AA4EA488DA5B112D737637F35F6D6E1777FC473CF61EE1CE6656C92B1AD8D92A915F76FC66C25068E680F4E22E02816EFB807EFFC11BF770FFEE093FF3D1DD886BFDF87372CA1C61B3167BB1A97F4C2FE565C5B4678EBD048358009E01C302DA07600FF1A749D07A9ABA11F079B358CFD36383544F556966A5356D47AAF7ABD376653A5F625A47B01BA3E2B199F0B253E1FECF7BC64795E4C7B1E1257836335E4AE06E7F390F6AA98BE53CADE293A77A2B45721FD9F90BD0E9CAB216D35A4AF86ECE725E7AB62DAAB287D27CADE09CE9D90F621A4BFDC71CEDF217D1364BF0569E5A02B260924D1C8164C7FD453F191210607D5583260D18EDD08AB413640D8AE0E13DB462642C1F53642C4D425942D21938802A2BB55CC6F46F9F528DF8FF26D0861C8C7404B1B5AEB870DF5B081945EB4D6056B30B8E951444F30417E3DACF5A3B55E721436B808A117313CA75C1E392752D980452F6EA0EF9F77010E201E6036301BE05C37D87C07D8EF60D09D20C5C3C67828EC019E6D70FA51F03EC6D886425A2718F5288CB80A43AFC21D5721E12AC4FD04862EC0BF09DDBA80F127E875153A939DCA21B2C977816E6F82B10B24FE04B157A19B7228FE2A681F836EF160BC034CFF02D39BC0FD0B981D00D9119FD89D0AAF069BDC4135830C0CD81986FE87937885184A890CD8144A63C03A1B2C0D86A10DA1DE0DF2D8065C56834562DB0C2DC51A5CDA806BC9CE06EC6BA09BEDFB954335CA4E72889C23CDEED8AF90C4E2108F651B858754E3E2681453AD076E36A89E83D858302F85FB8B60CDBF99F8A7C071A72ABE48F5B71970C702F5831E36CFA34D10548F0AB1BD84AE0ED46B1A527783D4FB40371C6E1F0FFFCF024B27837619E47407E30278622618A68223032C33217D0074BB0BE63D008699D06F20C4DF06BA07A06B26CC5B0809BD61F934D03C0A8FF742C3E6C0B8A750FC6D68F963A8673F889E0E8C3DE203CF53750B1375031C5488A821A2DF3B8844E2EBC198F8E9207041E02530114F444A116C0AB910B8DA2F6228A148C976D4D91B4A650F526E22D14B5C705369EB286D913A117C88C372A1A271C4807B023880791BC6BF0C5B3F842706C2A7D3E0ADE130E99FF0C96EF8A4085E9906C953C1B303FEFE3874EB0ADA1DD0E536D07E03DD88DC7E866EA47E189287D33DFDB560F80692A7C1E41D90DC0F26CF8064071CDC0A430742F93F9961DF30E51FC2B0EDF0F534F8642033B188F9E46578EC01E695C9F0B8197A8A104DD1415D9DAEDD601135D8121A65C38AE01462142132D73723752C80A24F8A0044A5222A15A4D4DB4B4596CA304446E2C6F1B8DEA6B2C9C8ED251130C1A7367C8DC203AA7E267A19AB385CC28A2E0FF87F40723DE47D0785294CE0112654CDB63DCEB62DE05A3D84F8669152BDD8AD1E19FD8833416A19E82C90BC06F24AC0350E5CB9E0CAFB0D32E5C1FC6C889F0CFD8641FC8BA0CB826E7EC8AB47A62168FE77686500394DC8E642535C28C78BF26CF47C2E9B247911F5936E553F2A15A52BC0C9C02988850D31AA10C304D9B5417683C4554A9C5FE2FD22EF154D845C24F545D7D56F3486950A1CFA4D5A82D1688C5458D411B442726317F05E4A9C422473767981908D900BE561290787A61083C6F4175FD82460CA011A015A044049F034829662B85A0257F3A0310F24195ECC832E9F81AE2F74D90ABA71B44C5483E934255B843EA7C4EF879CFD34419B6F849576EAD6712EC85798B4CBCCD732D320336D618548450642A342104B40703BF433286971372A33196C3250188573793994220747CAC1672849B24CB8172C584CEAD02FD26735161329A108A529340AC3288C66E376689720C32A19AE86E1729891158A3043EB322363A60597067063210E2B480F1062B204A6B7C080C074119818A5122F302601B600AB435182D079178AC362DC53E2DD927477ABFD6E2C4C7699C7A65926807ECC6810027A61AE424F4CFC8BE3ED496555131BA4BEF47FBC29FAE172C94936A59FB7120657185C21B005C126B5FB233E4288E064222F5AF23710DDB91AB835C0FB547C20BF1007FE20FF1E85FFA30AFF1977638B800DE94E980C7A41D00B17F582592F4CD70B0F4FFCCBF4B7270D334CB4425F2318747F9C7F93C27F847992E8B0BFC5BCC23F33F6391458EBC6BE521C2086D3F0C7F9F7C43DE5E9673FDA7FDFD13E7EFDE89D0B84E50B04BB46E8B24E98BB4EA8393CE6D8E1BFFCD7EABFD4964C0CC0C41CB12F231A40FA93FCDF22FF5F13EDD41AB0AD05936FBD2920F3189B1806549F23D568A402A44237105022DD51AD4E8A02BD063466D0D841234014213B442581EA37498083C9432D5AE2132D54FEB24CECC4F57B447A11A63096206B22F6EB4C5212291CFB0D520E953532189761F2F9E3FCEB1532B7334F4A95FD26CE893F248D93526D6642DA39D934D7FC33FC4B0A75280F21DADA0D9C471E5228FBB820B3213C97B24F6F2108B0D3031B3DD4A5ADF3C073492C4AD2AE2FD66FD89E3479FD900953333CB7CFAEFA622C3E33F6B33313B2974E78E6A309AEA2DB6D05BD0B8DDDD0C44EF662F5C70886224806988FA8779C8B60090273C4BD63ECF56230DD48618A1FF808B36207A7B750846BE2F4823441B4E1D5368C5C98EA9D0B6B6C38CA86D7B87025E55FA582E867202A1FA218886E2791EF6AD66B35498AA405AA14B752E4905EA7896D08AA2603B35E210DCDF0D9FDC059404DA545B86F6BA391E966B2FD01F6E92149814B04C6877B2B3497427A8AEA591C2CA3C0815AAF4B60462B467BBBC074572AC9026313E06360131108C0ED1249544F7C2ADB2815DFDD9A3DC49534DE258CFE5C1A4BBCCF68FD7FF69EBF65BABFB2DE88DFE16E9866E17FC3FBFCDA7B1250DD88B856916F934CA6A3DC868DFC2B19BC9864AA175817527B4578462000913925B0E73D5C91875F91C1171EE6169F82BA2AEA2E48CC5EA24C7E8F24258266600222B44AF00C82E18AF66B5D2D8DDEE6567F7D5BBDDFF45D60C3ABF5CFC5D58B43FCF559B52E6F93D7DFF24C966CF3878D5921CD86A0668362039D83F65E212941810FB676A543264577A8B5D06849F7B8F0913FC73FFBB387DD6B67FD121308C2F75530B20ABE44D02A428BC40425569438B7C8D6049960088EE681A2FF7F8A7F4A445B943911D990802D2414F78F84F7B09A0FE9F8A0910F69B9B09A9539060FC9C7B8F2CFC9FF6722FF6C1DAEE24C27547527C0BF1E460215F501604E0194D0392E18A1E4C864B495B9E3FF95FC4996A00E49EAB03818434EC46429546189B3A438198B2E0A528336DCE2A2FC5722B651E25A82FCA5105F43406831F75A71E7B2DC58AFC879EDD159C0AC226850620B3DACD7C3793D712ECFBD588827D9452B6203C0D6035B09CC0950D503A7101300FA360407B2D9D55659D8DA58DF1C6AAEBFB4AA5EEA5F1F4C69DE9C72415C5587CA9AD1E2ABD4759A22320F518BE68F025FACCCB148600B51EBA0A46053575021529135246CB5FBCEFFC0FC2CCABCCA2BB17E0F53EF51D5234A85C02C46DC62C4BF0A7C3DE81221C508693A30F1C0A500A401C4FE51E65B3A980FD392D4159EEDB6A09DF0EF9222391941BB121605BA198A08FFF21F633E0B2022797F31E72FE1BD2571AE92E178DD485CCCB615B3ADD4393355748A96CD53D826F52680E17F56F2C443123FC91E05B618D81248112125045388CCC32C25EA3C89F23034BDA2FA73A4236A11B7298B6C9BC8B61EE55AABB8B62A4EB6F0B567F9D7CBF9331B7951C35F3AD92D38C616BE3424F46C4AF3325B206C3A748D5FB75C6D5AAF4341BE3486AF3969FAF7B1C48BDAC4E66B569BDECA07CDACF2160D465E19B2C2E00F319521B62CC8FA828C4FE1925188543A493A038DA8ED14F1F8142F0523E7301A89A912997F4702AF1BA2DD22971FE42BC3A608F74619BA910CA74532C9C40E42845C044FE32B36AFD1F673CC5059FDE431F52A57BFA76C8756B8742B9C896972DE4A79610E36AEC2A1141C8AC357E2F0095EBE9BAF17F8D3D49112874DCC564B63562D834F81EB6887578FA081C8FC87C229C5015D28D3ED7322BFA01DDA0109BA48E0A559A94D31548C1B23F24E03A6545483D900EBFA41D4688D46404684F66F1C7DB0E43ED16314DECE83FDE3D0E652E416339EE5CC6B5237BEE83CB6119F7AD956B51EE9D71E2E18DD16124C87D0984EA2B99B59B750CB14B320828F7A1D3AA6A534990975C45585EB4E00BDF4F09C85A94ED264F535DAAC515E833004C438803815B06A8826C612059DA310CB1C7E01F53A423A450750A4A881180571FE18FB307D78930BEC5AD082A887A424D08F07CD68D04C447D0B84A88DE3B49B9272DF608BD78FDAE8BEB86EED1DD35F7870C1FAA282FC1FAE20DB418120CEA4DB906136193F3368B560BECE346916AFA5CA19493FAEA3DE75C01A81D503DB153A13E3D632AFC25DCF337D3BD3F727D6BD00BD7CD00EEE7F9B570E9CC0BA4572278216FB78A2266B541951042A32F683CCFD49CCD024265562061C64B451CC5DC00C8B620602F37014336535C58F4951A966F862722715D233A29EA51CEB6FE498C36EC2F12FF025A20524111744189D046F26C12E093C221C06D80E50AC949B3BF45CA4C4FC1EDF31E4068C0FA9C1AE013D61BD9F1835DD4C51AE7BB5EA5941354660FA1C6486AE660600657D18309984E928662CFA8F4CC790F665EA7A4DC19BD483CEEEA904E65901F2457813810728DF1B0156FF518E3931DB604E08ADBB2D7E9C56B75AB3E150FCAC7B176C4E9C6E9E91979C674C3E9896A876857B3A731F772D79CBE6D8943267C4C85D2757555F5BB2F04AF6F2DCDC556B0664C7403650322B6506B5142AE6906D83C447D151CE1799D112B825046E41B13D75871D02108CB600180F522BF90235DE2860D4C0B2C0E447C1779C84B9AB98C3EDB413D31FFC5073A2D660EE1C5AA7FE434C3F9B3267E9C85D9713AA2FA72E9C6769320CAD3E3B4A841E11C988CA9376FADD16356E09D98212AF04F0FCE01F6559113139F46C040647258826FCB309871592BDD4AEA9F591213305D9FA2047674743A44C206EAF65A30D13FFA7E7C21A2EA46609B209F5E4C23D7578462C6E32E2B0657138DBF473F6A84319E6189ACB45C808116448D582F84D29F200A93D88441E14463267B11D8A44A62D234F1229913EE703A39CA4E79E4DDA997F151324954F1D10310E125FFE18C3516CE82C171AC6856FE35C3338D7379C2BAC5E1CD699CE6B471DD36583365BB999273249F8475825CAC95C67B583181A4F105B83184935A886C397794CB3E62CAA623482372BD8AF30296D7C46EC4B62AFDA601F9BBE677989CE51D5F5F9EE715777F3BECD6C4906BBAE383A60D784C44EA6019D92666A1E9D1E552C46FB11F391082B23D89B246D02B35D625ED7C36C0F2C57B0B7A63D3BA09E4D9850FA5265696D73BE2DEE64F9BE4B8EEA6F9EEFF1DDD54FEA7DAF35963CD4BA6E6F5B607128F45D8B69500BF40A45278411D726DADAE8133E057B8FB1C963B3DAB6D7B7BD1E27CFDE899767E1FFBA118164F397C21D08A424A16C9CC1A42509B316F4EAA824559AC89C46AA4582BA77926176922127498D9348E8072C30245F20F0AF8282C0E89FA0733FD01E07D5FBC02A13DB048474E4C66C47DCA672AE82E82A883D0F9D2F82A929CA762D0D87133101BAE7C05625503A87888BF02B10C0A6A44814FE5DD1B82EA8F1C5E3AECBEFBB5AE7E170E19FE09F3D8DA2EA84A8D90AE5081A278AC2A06B86E826607E02F6844888F27F27680F89AA77C43FCB7F281187B5AEB0D04E21015F41AE4B846725570DA9FD84AE74B25DE864BB78C27FF91D7FEB6336CA3F69EE0D303C8692BA0B499DA5B1B2791CC0942B9AC9519AC131C6FBEECB5BF5DA87A39A2B66743AE76ABE941ABA324CBD2C75D76EEB1A8D6968882B2B8EC7EB129DB97DDC0733023119D698C9FA617DF407F5CD1AE29CD8974412C408480ED187A504859A6E9812A2BEDBAD61D8890CBB19DC41EA7EA8035133EE5D6EB48615CDECF5CCFAC6E4FA7A364D1DB81BD35465ACC484AA54EABE1CD35D0B9B34F0805E21B3427D606A7FFD5BF1BAB746C2032335D3D2D0F451C295848FB5A6F210DF2875C19B6F625E33AC8FE6A0BE5E61FEBF14E67D2455312906CB5E877E1D13401162D16F6D46F8FCCFFC83926DB9805F239A6A932C578E0E1D64C87E79D96377EE5EF7FECCFB074DDDF8FEB18C07A76E7C702A29931E9C0A9466C28363E0FED3306280E2DBA83FA67CEEC74197AB7E0DF65F30955CE1F60C4858A1BFC7D1FB13AECFDF5EEC93C9F739BEC197C9FB3249E9F765624A7FC33E01978AF45936F570C453BBE830E880FE9C795231983DBA01D3BBECCE481A7797D9D2DD1CA5B92BAAFB3DABCF0EFC78EAE0CCEE83775806172F1BFCFEC21E7BC5985D103B8D448348B2AB04BE068CA54A2CA660D4BF012548D04D845804D1443EEB21FA39F4E3BA8F335FE8D1E3851DC92F143FF5C2FB8BBEDCFBEDF95DB63A3D6E780FCB293832A343830AF19FA7403B1F38338A2D47EA1588D7007B04D44F03B716B826E0EAC4CE4DC1CE6742B1A742D1F5D99DEAD7A9FDC58C8D5CAB3C3A2292B161B912E31C7CF914BE38DFD56CF6D6957B9B56782F685C0D875DC15CAC2474B62053791E9ACF43EB4563EB157E85C4E7074D6B43363E32438245851F326C16E8F6034A3D23DCFB8A3060E0D1B8E313CDCEB7EF60174EDABD29F381C727BD727BE6037F9FF4CA03990F1445CADB5F196798B199EB6B07024AAD0A3F3C0E36E3FA11AE6F7FF07E2A65ED4153B6C343DFA1FB4AF2EEF0B08F0AE64D827E8EA0BF5DD0AB6E248F3EBACA9010E83B3F74A4105B5D64B8695B6E609C880185BA2AE530C4A4219556887AD3138D3D9D766574DA97A49965D7887A4D6FBD2659A13D133BCD2D8E2A115943C7CC9C93E2AA76EAAA94C35C729A2BACB529D919C55BC1DE4382331607459ED6DB4999D40253D8678B4C01117B61DC48952444415227A41F04DDE7805A4FA76BD513A16B1AE43DE13E31A77ABC39A0B5388C8F384E2E0E3475AB3E1C654D62B62070289802DAC1A99C449C9EED7B94F03C745141244B0102283F87676823BEF1C581D81247AF0447151F08E6FB4A256AA1263A294862778499241AF259E2371D906812D35C2470874C35A1FEAF5DB1B8CA13C396BEA32E265619FAFE7831D162E8FB352DD55F07C1224039405E3B33D88F717F1C6EC58D2DB8DE613B6DAAFCDCD5EC6D69F5D7B4AE7DAD01B94AC530EBB1469F3474F3303F9E842EE8CB1AEAB80E1244C0CB8C9726AAF9949FBA3A3D0C004804D84F2747D5DF03730E11F718DB168C392EB217EC305304879E223FE595479A537C87F17B18CFC2F27E57CB7C6FD3F7AE9673DEC6972AEBDA9A7F3E5ED978617178662576C4E12D3B090EC0D81B79D41C4BB1D13141FD0C447B813D6767F6D999F9DBD9D7AB78AF87DD375D5D769E4D130C2B9240451FDBABE8CFC751585286F1486FE85856D333B6AB5E53EBB9C56DFBE6B7CD7FBFF1F5EA7AEFBB8DFB1E692ABB509BF650D58A21D2DFFDCDCFE06B18B7D5D57556B0B3115433B363F76DEC24DBD56DC56434F81F823D6429E1F3503471297EC9569B7D6FF8623C3E155D374095A340193A2DD34919E85ADCF6FA86CB3357D4ED7BF527797153DBDEFA4073FD0FCDC7E540F5E7AD3FE256BF3FE0ADCDD913AEFB1EFFF063DDA06B39CD6D2F3463B91E6313C5AAF43918F1DFB1EEE2186746B4DB130D1EB5C14EB2261DCE3641C8882D44FB5420C41832A20F78544E817909813382C53AE11AF7DAD3CE5575EEBD3FC3435760C815C790A6198B1BDD9597F00A3FB49E829147A1B314E0CECF88BB621D72CD99D5F692577612058B3C55E56FBEB3D5731B2CE8E63EDC7EE780456FD0DC74CF58A02374CB3DCF5AFB9F8027BE751FF9E59E86CE64E74D77A32FF4016704FE5FD04944313552DC0386D99F9E13562CB5EFBEF711DF4713E08BF1EEDBC73BE68D37CCE90773C61BE68DD7CC190F73EE352CD44136AB6F4FA0C8278471F35C5C8F5C3F89DE9F6BFC810738F7A73568C512B47B68BE6FD75A285D03BDD7C0DC3530FB10CC8E5494FADC26587C0DB2DAC04BE30C56B2534C1448322C32F4AB9E3778CFB13E8BDE36541BFAC35933D6A6C0C594664A71CDE7FB379F1DDABC9E987E1AA6948873D5D8DEFE8386740A840013138D937F659FFD6BEF17F6FC9B94A4FEEB49F45FEF89583CEEF8714492276AF798BB2D5A775BF502C24FF2A21D33AA672CBCF75E975BB6E17016BEE6C2B2F38033D959BE28B06756F5D359D66B2667887706C908B53B66E84889FB72A57DF30F6E1ABB7AD368C28FEAAF007DE9094AFED889AE48529E68C835594385CE967A67F365E794B603DE769F6C505E4CD882D47DED86E18679C3FB91D231DC11FFD2E67E8E7943B7BC3CDC317CB861F8F0BE4486646DA059CC758AF89C00C65BB0EC70B5B80BCF25CDDFB26BCBEC5D6BE2776D569BEDEE97DC1E07536CE8520C4377B977ED7A9334B2AB7A5775605700EFC2ED54DDE10049AF7C740A41EDB36BFB9ABB5B07F4EB3B2F754C41862F86D05FFB6E22FA71BB615C4FC774CE2791DEC740464C75068725E6008A4CDFD1C156847273CACDFC22881B010DD1E89FAB1F22A1ADE540A13CDCF5CB0C1D890A5EB17365B067307704DE3FD2B57F9477BF112C43F095645C6E755AB3DCD7A6E0CB39B882D4A7C0E51C5F85155B796B90F58974742383E3A6D34257115F2B725F04D967B13BDFE5767BDD37AA46E4814E36E8F6C3281EE8E50833A2F5966C5F431B5C0E863370A01F7BE48BE86FDF1919D8F137EB8234DF46DE9AC18DB5F3AF49BC374828CE1BEAE23A7F1B5EA0A9D613B7C2F8DA2338FD7FCB3E9A2406287B6137B4FA8E7EE9F3E407DE64AC7391EF55D1FA903476B194502FD99A091DB5B51E755D38819F385F1DD76458DCE22B94AF07702B3001C4554BA603A121DBAE0CA9BE921220AE72F3DDD6A5F7F8BEBAD7396224D3F4CC868B4F060A5C96A559955F3D141CD80FCFD3576B74866C2A1D2744A01F69B0255018F005FCEED69DEEAB3B7D57F70688CBDCF296357B97EF70B1D352C204F3F89A2739B70B5459620C69E71DFCE8D1EACE970C2B1A7D9561670714B52B808B8410AB006904AF0B94FA23C8A5AFD3513C461FEA4A946225E8A4A4B7BA623AFA5CC4B1D3840517628271E84445BE17BBB330F263318B92C726E7D2F7FF682E2811E27180C77595F8A7090498E173EFE2C6320587724A6E5B781D50D0A924935EBFE4B05E3A9F5431AFF7A165A3CF2D1D1DBE3CBAE5B2D07246C06784955F2499A2FA4214F1F6DD40D349D4934BC885EDF2C158D11E65E2C8C44B4BCA24292056CC2D3D94E33EB7C41D6E70B734A0961A846BD0CA52D1D4FEBC4EEA4037ED980277F819624F0BEDBAAED9C45CE2DCE7E3F0F90107BA13BF9784BB4F809E0FF13DB7F08F96047F9C1E3C630F9ECB0D26BA80FA1F13ED95D4E1AB7018DB5ADD7EE2542FC10A623665EEDA325CEB3910ED01423D6E6CC710948052BBFFB9D1EFDDE884EFAD5E18717A11273C0077BF1B76DFDDFC1BA46B2E56377BA059B93AE281B1290081AABE091FFD75F0DB9BFEB2ABEF0B557F4D78177EDC8E7B7C089F7CD8FC1B54D1FC7153F3CE50B3096B3A2463A04EB2D3271B13B7E41240D775CBC4C1DB7677B31EBEC7B9E3EE59CBD2F1D2A9AE815371D10C7C721AFE79887C85088458181B1023E198FA3C1F2602F9C9FDEA69F7AAB3D0FF1BF77D1FB83FF9168E7C021F7C084FA5C3D2A93090D074E899013144503727529198CCB51B9453EAEC3B7ADB960571BEF3839C07EFAC7EDBE05C6040E7B5C1609F868349CEEE0F41CF14BEFB48BEAF3E4877B20D0A1B1181745853B3B3FE82EFBB13EE27BEF35D78DFF9E57BD5DBAA9C4F54A10BE5C1C6FC8652E464006EF5809194EE17AF17515DA4EF0A9ADB40D3F7771E42B73F8156DE0A2008F726D5BDAEB74E5EF2AEFDC2557B08D73E871B9EC70D269AAFDD441B7003A132FAAA6B6D0D5E4B2EB9AEBDED41C98D58B07360D080FA36502582CA063A2B0C1B89BE7AC83762CA89AF161FF839F9C026EBCA8F4C23E6F42ADBA46D2EE75ACD6C58F1C2CA4B14C4B4E5F9B8CD8D5BC1D50CA6F3C09D00D5695079A9CF35EF4387E37C16FE8486DFAFC9DF0F2817C41120721B25AE34C8B2A1EB5EB8EC86E8047482DB0CDA88282C605C0197161F685AEC6C22D17982F34C2EA616B412BF310AEFE7E94B611120C55D0F4D41EA92A8CD9640AFEBD792B04C7420622291010AD287BD144A5DB71A72AFC84DC9DD27C3B007E1ABE9BE9E63AD5F4CA9BEFC60F5578F184E2E9C71EFECEA3529D51713AAABB4D566D6204235744480980874212D93168A21F67A0BF404038D3263E82CF85A5F8DCFE7937CDCAD73FB24C7EE0C1085C020649F4D9AC2E905AE58E00698A12A9DB32E09859D9C4C000BC52CDEB0D51436B9A8FFA0EF015A23F3B431B815E32B18B7BAB0E4ADD4671D0DA65406FBEC0A1DD1719D9850ACF26D2E09D4C5CC6A3D5396CDD64A1DE9513B7E8B56BE824172383AB545B80216D337EDE81B16ADC886F3D114BC0F258746A2C9AD644D843B795F09248F44A0DD475278AA0C257575039517BEE99724E88B7AF40D45D2968DB6292A2F6DB25E509691DE24B268D87DDEAE6C892B6AE43EDC7BE45A7C78A4175FB6B8707824E188ABABEB1799719580BE520E65B5C0A659457518DB63CB561527BC31BB6AA4F7855323E5D4538343B5BBFB85F979836CE1637DCB6AFB0EB2188F0D2DAB5D6F6E29D41A46ED3718A33D161D83B239B75B621A2B11CD6B4957233947276A2BD7D9E5245B28CD6A0A86315F53B66AADEF8DD9BE7CEF0BA5F9726AA93B54EB46619E41B630833889C907287D4E64DF5C939B38DBB77EA8AF34C8E74B79695C506B268646854BA44BC224110705081D22A613C0B6028AEA88885B4412DBB20D186FE66DF8E2D04ADC343907378D35E2CF32CAD29E9E34F4876BE9EBEBAFDDFFAFC5D73216ECBD36B1E7DE6BD3B47BAFDDB17AEF953BE7EDBDD273E65E49BD71AFC8BCBD17E0B18500BD48B855295FA856C6A1B112E3F21C8C6D0524C0046CADB8A53280E5155518BF5669C3756E723B20B703723B3D97F634303F5C03A8270BC1F690720D5429D7F4648D20E52A5D4448A99520C51F8A4AB1C9B090E8C75C8C259210B7D9AEF74E477A376226C0B9F9C06E7D58D4CD199F9DFAECE8825C959098AE1296E63C3BBA62E6B9F92326A4169CB9BF22E7EF19391531D30A2C8F3F7C68EED68754C2CF9355C230874A70D06BE8B5B40D383321D2266D9BBDB97715A4772366E2F0B9F9B6C6AD0F5756CC199FF3E9D6875FCF7D7A5662FAD3B396E66C7DF8F76F3762E6CF93AF650D733C3DCB41AFA1D7D236C26726D8689B4ADBF41E61DBEF988748D43C481809BB3096A7608A587105B970C4045BF8CCFD958DFFE7DE553692B10BD3973A6DA45649F6347A1569E330BD356581B2A2B04459232CAA813E66033D35196DC86456E726DADD9BE3DDA25DCD060D069EDA23557445E1A99D2ABDEBA4F4CE48AC78EE21600A5B906AF9E742ECB5BDC5DDAAEB0E0F5A38F0D8FD473B6F9D6A570FCCB45A8B06AE3D736CF082D8A999D33E9991F9C9FB45998F9F2CCA7C62C69EC73F985174EF07993363671C2F668FBF2FC2F1F749CF76909E51D604DA336A07B47312C182C432645674854D215B70F9E77CCDB5BD6B7DD575BEFC85034B99A39D11D84957AC56A0968680E617DDE95325FA309AF86EF89D8EFC8FC344173A4CC9C42A8C185B385B58622A1B11FD2E9ABA20D56E0C042C4B5B0AD3D365D7D2F92EF95C6A614B816EEEA16CB6205584400080FE42E52DC3F46B57C78BCA635C6516963E4025C100624F119F471A08B4886C61285B673A674C9D5F30E1C7D4ECFB5FD109533355F6CCA9EA921E19BD2A1821A71131956189B3618BF11625FC659808C74C7932622D46517799CF36598CA1E48A9CF2798D95FDC659ADB74FDC10EC7A67BED8DDC220633A839626BBDDE5936BD60E1B9B5AF0C5BC8A9C7E2392CB67F25A7390CD2F15A1662DC0A8FD84C9E28E9E750C13010EB82015CB3915AEB6F2646FA3C5587929C8AFF05B8CAD1F57E47C6D6FAC546758AD31021F54795831BA8441BD6EBCDB83A9055FD92B72D425C9E5BD2AB4E69CC6FCD2CA70CD5A1B1EB51FE3AF3FBEA96324EE2AC3462DE1A757817DF7475157D8923DC225CF5C82F18B7918A7D96CE1F090CAC62BDD1A2B0F770FDB06744ACBDB1833E57246CC3FFE3BA3E7DB774C4FCE2C2AEF77FCFD79F19F7CB059BD688F9D79ED7B040E0740FC6600B5BDA3636DC4842E4F891817751D3FC5D91ADFDA5659F1CAFD399F0D2CFADB92CC4C5D5E51519AB7C7D4B69D5FFDEBEAB70D538E1C0DDB3A9F4FCB8B3BCF07E3CEB3625C1540C2C70CFAFA9DD2FC47BFDFF5C26BE716ED99DFF2DAF785B2C3E1C25BB6607C6E3EC62D8537E9234BD44343D424C6A6EC3045F4F1DA9420A8E7868BDE998E7B4C5B6EFB72DAA20D97DF7964EE7F4F5B5E953A6DD19EA7DF79E4C995D3969F5CA9D4473EB972AAEE642EB07B72012E9165446E441F55C24D6EA39EF4AC364CDF9FB761C95649B2B346E2A4C3A4DFD7082751841315413C512428AB082751C01E56118F11053080AC33AEAF110C20D69641AC6D10D1ED07898E0F22BAFED04D6EA32338FB7CC0A45C44AAB98784E8D73FF544EF1FE5E97CE0C0D14E8F9CDCD8BDB66CC0DD0D1B96CD7A72F9D38FBDB1F29FC95509E586EF2E18747C303B2E6C3B9FDA5859308B0F3EDD77E8FABE9A3BDED64342554462B46D06750CDB0D419A06566A6C34C80623E792FC53399FEB303E0AB83ADC05DD7F94C0AB1256EC45EFB46DD70BDB8EBCF9DCB7CDD5D5F5F4AB69B8B95E192E0AAF6E8C63A9A46367DE05F6EFEF89BACCA9D9A99999C6DCA2A237D207162DCD79E5FE0AE38F132C9CA540622A7250CF9C8AE92905A91787040257165725343D9950B53C5B6DD7D1F4EDFA42DBED58221DBB298E1173A7664FCDBF8258780909E7647C13D30196E620A6A240E252031663A0A622676D554E4542B1D112EBE1A4683B556EB22C91B81737346C68A0A05F595AFDBF2C54E96FE81D35F5619301BE4C0076A043D4DEBFA578D83B0E6D66FC9619731C73D6FC6DCB2B23A638065C4EFEFEC1F2C997370C9B9B96F7D5C4AF3FEE3A397972D1427EC903E9C95F15CDDFDD63DAD086A2F5DAD9AF985966BB085FFE032099B4C9FF3A8E95E6FFCA4152A79841AC81724E9DA4A0CC3D6B4143DCA69640682D6787F4645135BF18D4EE2019477BBBDB27F00BB302C919E6FE2A3A5305187E17D0C8C1AE61444E0FD2080BCCCCB3435A9E0069AB004EAF40CCA594207F7164ABFF9465C525636ACAC582544E2A7826BFF4F3BC7C77DAAA3E074FA7E4975EE41A2B25B6D52FC28A4B04095D8CB47D43AFA84CCB6A31DE3D1887ED6A5B2B62FC6500B59F01FC8DBEF346978EDBED25F06F5FABFF879215977A95A45CEC55C249BDF258312D8F4569AB58F1F4DEFCD2BAB2C6CADAD656BF3FBCE2920DEFAD8BB44DEFA1F44E47A33AC413755E4114A70001978320BE926C92E4B6A011D89C2310559902D1D63DE4D07260EF7B92303D0F983D6781692292BD4496B3105904BAD4D5755552861602B425825E884C692A40C1BE4496084026E3C59254B3B32B082964D94300C7721CEAFC240EA73C8ADBF6FC88DB9A1EC1F2A52C2CFFE8250B69EA11AC3C79A08F1E740ADFC480E897B6E8F79658A201469239BA9245065712D86B1299B01FA9734E0BDC86EF45CEFF25595E1799D3CF88EA87DB10F75C18B81F42642199F40F48790F15A677F04DA443DF17A58FE2C274EE48E1D92F03EB2749A53F0826B2F67B9BD8D359CD1BBEF737FBBF24CBEBFE96D3CFF89B1E6EF3363F177635FFD08A9B7F0890A510B79C226915E5FD5DCAB704B99048BF50D15E517E0929979138445620C1ADC78DAC1564E01113245DB58A16D142323E1713E4914C2A46F6D6E36A9238326B83D93ABE145944AD5D6B378835887A43269F35AACDB71ED7F713F490241EEC6736ACEFAD1AC79855EB8CAAB90C52E9B5421F58570AFDC890F62EA5C7B50C1C64CACDC962399BAC35978BC96CB936594B4A31D95C9EAC257BC572F3ADC701FEA2A2292CC344ADA61533D511FD1810E8FFBFD093B6C76A7B5357DA9B1C8BD1F48E9A803E16D7838F114BA564544E2A6798AFD9A1C897CF9673C98C0FC871B45EFCE5785D9D056E4F76B95CF8BFD1B8725996F13F18967C788E6544F2094A2212B3AD06AB8E05353BD2316A0C9157D1B3CF2EB4E841AB3518CC66BBDDEA78D2B9DCE1B01A2C06F2B15AAD8EF15A83D9E974AAB546B5DA61D51ABB0FEF3BCF19E5B4DBF3E8B6D16CCF7390F3C971A5052BAD9385AC1D69E438DD7092859C944717B26DB73B9CD63C92263BF2482BB976BBDDD9BE2677B7D3A323C8C5E41AD20C39CB604D24CE40BBD032C7B1303777A1630EC9C2EDCE4397E413E4E0A1734DA72B0E1DA2E739ACB47DDA4A6E39F99C2A7F9A6ED31F8226AD5A29AF749EC94016875569DB6A301C229F13F2A543B4C3066BFB1DA30D4E9DD668B0989DC0020F36A8641B7905D2E2465C89D3C22D8D672B5F4EEBB972C4A331BDB6A635BDAA8D0B7FDDD2E7CCC1785EFBC6955E5B0F8C181573A0637FA88F741492E86F0ED139903CA856FD3FB8F010C0DEB4C6D88ACE67322A3AD76624C69D8AA9E87C36A317597F67B89D9C43FFF60E9E326BD22C10060D7E94684E9D3E163AC17346BDF18184E5096C374803EB9831CE316300F2C6E48D1943FCA0758C20901185DC7163C68C23F1CC29E40982B37D2D28C7D3E971E532725D9A867CD2E897375463E8FE7113B3278E1BA3CCB1D3CBC6386628A78D99F3C0A4F1646DBDBCFAF26AD971E33262E6BFB319E8F7AEECDD810F2F082FB8965D91FDE482FF7AD4D7E8509A1963359015FC7FE43EFB40]]>
      </FileEmbedded>
    </File>
    <Group Comment="shader render" DesignDisable="255">
      <Children>
        <ZExpression Expression="MemSampler.ValueArrayRef=mem;"/>
        <UseMaterial Material="SpeccyMaterial"/>
        <RenderTransformGroup Scale="8 8 1">
          <Children>
            <RenderSprite/>
          </Children>
        </RenderTransformGroup>
        <ZExpression Expression="MemSampler.ValueArrayRef=null;"/>
        <Material Name="SpeccyMaterial" Shader="SpeccyShader"/>
        <Shader Name="SpeccyShader" UpdateVarsOnEachUse="255">
          <VertexShaderSource>
<![CDATA[void main()
{
  gl_Position = ftransform();
  gl_TexCoord[0] = gl_MultiTexCoord0;
}]]>
          </VertexShaderSource>
          <FragmentShaderSource>
<![CDATA[uniform sampler2D mem;

void main()
{
  vec4 color;

  float specX=gl_TexCoord[0].s * 256.0;
  float specY=gl_TexCoord[0].t * 192.0;

  float index=0 + specY*32 + specX/8;
  float u=index / 65536.0;

  vec2 uv = vec2(u ,0.0);

  color.r=texture2D(mem, uv).r*8388607.0;

/*  int pixelbyte=int(texture2D(mem, uv).r);
  if(pixelbyte) & (1<<int(specX)&7) )
    color.r=1;
  else
    color.r=0;*/

//  if(color.r!=0)
//    color.g=1.0;
  color.b=0.3;
  color.a=1.0;

  gl_FragColor = color;
}]]>
          </FragmentShaderSource>
          <UniformVariables>
            <ShaderVariable Name="MemSampler" VariableName="mem"/>
          </UniformVariables>
        </Shader>
      </Children>
    </Group>
    <Group Comment="gl raster render" DesignDisable="1">
      <Children>
        <ZExpression>
          <Expression>
<![CDATA[byte[6144] video;
//for(int i=0; i<video.SizeDim1; i++)
//  video[i]=mem[16384+i];//rnd()*255;

for(int addr=16384; addr<(16384+192*32); ) {
  int y = ((addr&0x00e0)>>2) +
       ((addr&0x0700)>>8) +
       ((addr&0x1800)>>5);
  int offset=(191-y)*32;
  for(int x=0; x<32; x++)
    video[offset+x]=mem[addr++];
}

/*glMatrixMode(GL_PROJECTION_MATRIX);
glLoadIdentity();
glMatrixMode(GL_MODELVIEW_MATRIX);
glLoadIdentity();*/
glRasterPos2f(-1,-2);
glBitmap(256,192,0,0,0,0,video[0]);]]>
          </Expression>
        </ZExpression>
      </Children>
    </Group>
    <KeyPress Name="KeyTester" CharCode="17">
      <OnPressed>
        <ZExpression Expression="KeyTesterResult=1;"/>
      </OnPressed>
    </KeyPress>
    <Variable Name="KeyTesterResult" Type="1"/>
  </Content>
</ZApplication>
