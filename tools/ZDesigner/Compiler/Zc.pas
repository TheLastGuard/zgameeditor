
{ This unit was generated by DCocoR.  
  Any code in this file that you edit manually will be over-written when the file is regenerated.
}

unit Zc;

interface

uses Classes,CocoAncestor,
          Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication ;

type


  TZcScanner = class(TCocoRScanner)
  public
    procedure SkipIgnoreSet; override;
    procedure ScanSym(state: Integer; var sym: Integer); override;
    function SkipComments(ind: Integer): Boolean; override;
  end;


  TZc = class(TCocoRGrammar)
  private             
    IsInIdent,IsInInvokeArg : boolean;
    CurrentFunction : TZcOpFunctionUserDefined;
    procedure CleanUp;
    procedure ZError(const S : string);
    procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
    procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
    function IsConst : boolean;
    function IdentAndLPar : boolean;
    function GetInitializer : TZcOpFunctionUserDefined;
    function IsLocalVarDecl : boolean;
    function IsPointerOrDims(var PeekIndex : integer) : boolean;
    function IsFieldDecl : boolean;
    function NotFinalComma : boolean;
    procedure AddBaseClassToSymTab(TheClass : TZcOpClass);
    
  protected

    procedure _ZcFuncRest(Typ : TZcDataType; const Name : string; M : TModifiers; Cls : TZcOpClass);
    procedure _FormalParams;
    procedure _ZcFuncBody;
    procedure _Zc;
    procedure _ConstantDeclarationList(IsPrivate : boolean);
    procedure _TypeDecl(IsPrivate : boolean);
    procedure _GlobalModifier(var M : TModifiers);
    procedure _Type(var Typ : TZcDataType);
    procedure _GlobalVarDecl(Typ : TZcDataType; const Name : string; IsPrivate : boolean);
    procedure _Block(var OutOp : TZcOp);
    procedure _Field(Typ : TZcDataType; Cls : TZcOpClass; IsPrivate : boolean);
    procedure _Init(var OutOp : TZcOp);
    procedure _StructMember(Cls : TZcOpClass; M : TModifiers);
    procedure _MemberModifier(var M : TModifiers);
    procedure _ClassMember(Cls : TZcOpClass; M : TModifiers);
    procedure _ClassBody(Cls : TZcOpClass);
    procedure _ClassType(var Typ : TZcDataType);
    procedure _Statement(var OutOp : TZcOp);
    procedure _Par;
    procedure _LocalVarDecl(var OutOp : TZcOp);
    procedure _LocalVar(Typ : TZcDataType; var OutOp : TZcOp);
    procedure _GlobalVarRest(Typ : TZcDataType; const Name : string; IsPrivate : boolean);
    procedure _GlobalVar(Typ : TZcDataType; IsPrivate : boolean);
    procedure _Expr(var OutOp : TZcOp);
    procedure _ArrayInit(var OutOp : TZcOp);
    procedure _Argument(var OutOp : TZcOp);
    procedure _SimpleType(var Typ : TZcDataType);
    procedure _ConstantDeclaration(var Typ : TZcDataType; IsPrivate : boolean);
    procedure _EmbeddedStatement(var OutOp : TZcOp);
    procedure _StatementExpr(var OutOp : TZcOp);
    procedure _SwitchSection(SwitchOp : TZcOpSwitch);
    procedure _ForInit(var OutOp : TZcOp);
    procedure _ForInc(var OutOp : TZcOp);
    procedure _Unary(var OutOp : TZcOp);
    procedure _AssignOp(var Kind : TZcAssignType);
    procedure _SwitchLabel(var OutOp : TZcOp);
    procedure _OrExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _AndExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitOrExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitXorExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _BitAndExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _EqlExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _RelExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _ShiftExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _AddExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _MulExpr(InOp : TZcOp; var OutOp : TZcOp);
    procedure _Primary(var OutOp : TZcOp);
    procedure _InvokeArgument(var OutOp : TZcOp; Ci : TZComponentInfo);
    procedure _ReinterpretCast(var OutOp : TZcOp);
    procedure _InlineComponent(var OutOp : TZcOp);
    procedure _Literal(var Typ : TZcDataType);

  public
           
    ZFunctions : TObjectList;
    SymTab : TSymbolTable;
    AllowInitializer : boolean;
    GlobalNames : TObjectList;
    ZApp : TZApplication;
    InitializerFunction : TZcOpFunctionUserDefined;
    destructor Destroy; override;
    procedure CheckHomograph(var sym: Integer); override;
    procedure ParseEvalExpression;

    (* procedure ProcessPragmas; override; *)
    function  ErrorMessage(ErrorType,ErrorCode: Integer; const data: string): String; override;
    function  TokenToString(n: Integer): String; override;
    function  CreateScanner: TBaseScanner; override;
    function Execute: Boolean; override;

    constructor Create(AOwner: TComponent); override;

  end;

implementation

const

	intConSym = 1;	realConSym = 2;	stringConSym = 3;	identSym = 4;	andSym = 5;
	assgnSym = 6;	colonSym = 7;	commaSym = 8;	decSym = 9;	divSym = 10;
	dotSym = 11;	eqSym = 12;	gtSym = 13;	gteSym = 14;	incSym = 15;
	lbraceSym = 16;	lbrackSym = 17;	lparSym = 18;	lshiftSym = 19;	ltSym = 20;
	lteSym = 21;	minusSym = 22;	modSym = 23;	neqSym = 24;	notSym = 25;
	orSym = 26;	plusSym = 27;	rbraceSym = 28;	rbrackSym = 29;	rparSym = 30;
	rshiftSym = 31;	scolonSym = 32;	tildeSym = 33;	timesSym = 34;	xorSym = 35;
	MaterialSym = 36;	SoundSym = 37;	ShaderSym = 38;	BitmapSym = 39;	MeshSym = 40;
	CameraSym = 41;	FontSym = 42;	SampleSym = 43;	FileSym = 44;	ComponentSym = 45;
	privateSym = 46;	voidSym = 47;	inlineSym = 48;	virtualSym = 49;	overrideSym = 50;
	classSym = 51;	refSym = 52;	floatSym = 53;	intSym = 54;	byteSym = 55;
	stringSym = 56;	modelSym = 57;	xptrSym = 58;	mat_fourSym = 59;	vec_twoSym = 60;
	vec_threeSym = 61;	vec_fourSym = 62;	constSym = 63;	ifSym = 64;	elseSym = 65;
	switchSym = 66;	whileSym = 67;	doSym = 68;	forSym = 69;	breakSym = 70;
	continueSym = 71;	returnSym = 72;	_plus_equalSym = 73;	_minus_equalSym = 74;	_star_equalSym = 75;
	_slash_equalSym = 76;	_bar_equalSym = 77;	_less_less_equalSym = 78;	_greater_greater_equalSym = 79;	_and_equalSym = 80;
	caseSym = 81;	defaultSym = 82;	_querySym = 83;	_bar_barSym = 84;	_and_andSym = 85;
	reinterpret_underscorecastSym = 86;	_atSym = 87;	newSym = 88;	nullSym = 89;	_NOSYMB = 90;
	_slash_starSym = 91;	_slash_slashSym = 92;

var ZcSymSets: TSetArray;


var
  ZcST: TStartTable = nil;
  ZcLiterals: TStringList = nil;

{ TZcScanner }

procedure TZcScanner.ScanSym(state: Integer; var sym: Integer);
begin
 while True do
 begin
  NextCh;
  case state of
	 1:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F'))or((CurrInputCh>='a')and(CurrInputCh<='f')) then
		  state := 2
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 2:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='F'))or((CurrInputCh>='a')and(CurrInputCh<='f')) then
		else begin
		  sym := intConSym;
		  Exit;
		end;
	 3:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 4
		else begin
		  sym := realConSym;
		  Exit;
		end;
	 4:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 6
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 5
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 5:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 6
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 6:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := realConSym;
		  Exit;
		end;
	 7:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 8
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 8:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 9
		else begin
		  sym := realConSym;
		  Exit;
		end;
	 9:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 11
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 10
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	10:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 11
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	11:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := realConSym;
		  Exit;
		end;
	12:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 14
		else if (CurrInputCh='+')or(CurrInputCh='-') then
		  state := 13
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	13:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 14
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	14:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := realConSym;
		  Exit;
		end;
	15:
		begin
		  sym := realConSym;
		  Exit;
		end;
	16:
		if not((CurrInputCh=#10)or(CurrInputCh=#13)or(CurrInputCh='"')or(CurrInputCh='\')) then
		else if (CurrInputCh = '"') then
		  state := 17
		else if (CurrInputCh = '\') then
		  state := 44
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	17:
		begin
		  sym := stringConSym;
		  Exit;
		end;
	18:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='Z'))or(CurrInputCh='_')or((CurrInputCh>='a')and(CurrInputCh<='z')) then
		else begin
		  sym := identSym;
		  CheckLiteral(sym);
		  Exit;
		end;
	19:
		begin
		  sym := colonSym;
		  Exit;
		end;
	20:
		begin
		  sym := commaSym;
		  Exit;
		end;
	21:
		begin
		  sym := decSym;
		  Exit;
		end;
	22:
		begin
		  sym := eqSym;
		  Exit;
		end;
	23:
		begin
		  sym := gteSym;
		  Exit;
		end;
	24:
		begin
		  sym := incSym;
		  Exit;
		end;
	25:
		begin
		  sym := lbraceSym;
		  Exit;
		end;
	26:
		begin
		  sym := lbrackSym;
		  Exit;
		end;
	27:
		begin
		  sym := lparSym;
		  Exit;
		end;
	28:
		begin
		  sym := lteSym;
		  Exit;
		end;
	29:
		begin
		  sym := modSym;
		  Exit;
		end;
	30:
		begin
		  sym := neqSym;
		  Exit;
		end;
	31:
		begin
		  sym := rbraceSym;
		  Exit;
		end;
	32:
		begin
		  sym := rbrackSym;
		  Exit;
		end;
	33:
		begin
		  sym := rparSym;
		  Exit;
		end;
	34:
		begin
		  sym := scolonSym;
		  Exit;
		end;
	35:
		begin
		  sym := tildeSym;
		  Exit;
		end;
	36:
		begin
		  sym := xorSym;
		  Exit;
		end;
	37:
		begin
		  sym := _slash_starSym;
		  Exit;
		end;
	38:
		begin
		  sym := _slash_slashSym;
		  Exit;
		end;
	39:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '.') then
		  state := 7
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 12
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := intConSym;
		  Exit;
		end;
	40:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 39
		else if (CurrInputCh='X')or(CurrInputCh='x') then
		  state := 1
		else if (CurrInputCh = '.') then
		  state := 7
		else if (CurrInputCh='E')or(CurrInputCh='e') then
		  state := 12
		else if (CurrInputCh='D')or(CurrInputCh='F')or(CurrInputCh='M')or(CurrInputCh='d')or(CurrInputCh='f')or(CurrInputCh='m') then
		  state := 15
		else begin
		  sym := intConSym;
		  Exit;
		end;
	41:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 3
		else begin
		  sym := dotSym;
		  Exit;
		end;
	42:
		if (CurrInputCh = '=') then
		  state := 22
		else begin
		  sym := assgnSym;
		  Exit;
		end;
	43:
		if (CurrInputCh = '=') then
		  state := 30
		else begin
		  sym := notSym;
		  Exit;
		end;
	44:
		if (CurrInputCh='"')or(CurrInputCh='''')or(CurrInputCh='\')or(CurrInputCh='n') then
		  state := 16
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	45:
		begin
		  sym := _plus_equalSym;
		  Exit;
		end;
	46:
		begin
		  sym := _minus_equalSym;
		  Exit;
		end;
	47:
		begin
		  sym := _star_equalSym;
		  Exit;
		end;
	48:
		begin
		  sym := _slash_equalSym;
		  Exit;
		end;
	49:
		begin
		  sym := _bar_equalSym;
		  Exit;
		end;
	50:
		begin
		  sym := _less_less_equalSym;
		  Exit;
		end;
	51:
		begin
		  sym := _greater_greater_equalSym;
		  Exit;
		end;
	52:
		begin
		  sym := _and_equalSym;
		  Exit;
		end;
	53:
		begin
		  sym := _querySym;
		  Exit;
		end;
	54:
		begin
		  sym := _bar_barSym;
		  Exit;
		end;
	55:
		begin
		  sym := _and_andSym;
		  Exit;
		end;
	56:
		begin
		  sym := _atSym;
		  Exit;
		end;
	57:
		if (CurrInputCh = '=') then
		  state := 52
		else if (CurrInputCh = '&') then
		  state := 55
		else begin
		  sym := andSym;
		  Exit;
		end;
	58:
		if (CurrInputCh = '-') then
		  state := 21
		else if (CurrInputCh = '=') then
		  state := 46
		else begin
		  sym := minusSym;
		  Exit;
		end;
	59:
		if (CurrInputCh = '*') then
		  state := 37
		else if (CurrInputCh = '/') then
		  state := 38
		else if (CurrInputCh = '=') then
		  state := 48
		else begin
		  sym := divSym;
		  Exit;
		end;
	60:
		if (CurrInputCh = '=') then
		  state := 23
		else if (CurrInputCh = '>') then
		  state := 65
		else begin
		  sym := gtSym;
		  Exit;
		end;
	61:
		if (CurrInputCh = '+') then
		  state := 24
		else if (CurrInputCh = '=') then
		  state := 45
		else begin
		  sym := plusSym;
		  Exit;
		end;
	62:
		if (CurrInputCh = '<') then
		  state := 66
		else if (CurrInputCh = '=') then
		  state := 28
		else begin
		  sym := ltSym;
		  Exit;
		end;
	63:
		if (CurrInputCh = '=') then
		  state := 49
		else if (CurrInputCh = '|') then
		  state := 54
		else begin
		  sym := orSym;
		  Exit;
		end;
	64:
		if (CurrInputCh = '=') then
		  state := 47
		else begin
		  sym := timesSym;
		  Exit;
		end;
	65:
		if (CurrInputCh = '=') then
		  state := 51
		else begin
		  sym := rshiftSym;
		  Exit;
		end;
	66:
		if (CurrInputCh = '=') then
		  state := 50
		else begin
		  sym := lshiftSym;
		  Exit;
		end;
  
    else begin
      if CurrInputCh=#0 then
           sym := _EOFSYMB
      else sym := _NOSYMB;
      Exit;
    end;
  end;
 end;
end;


procedure TZcScanner.SkipIgnoreSet;
begin
  while (CurrInputCh = ' ') or 
    ( (CurrInputCh=#9)or(CurrInputCh=#10)or(CurrInputCh=#13) )
  do NextCh;
end;


function TZcScanner.SkipComments(ind: Integer): Boolean;
begin
  Result := True;
  case ind of
    _slash_starSym: SkipCommentTo('*/');
    _slash_slashSym: SkipCommentTo(#10);

    else Result := False;
  end;
end;



{ TZc }

                   

procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
begin
  ZError(Msg + ' ' + Data);
end;

procedure TZc.CheckHomograph(var sym: Integer);
begin
  //Only Homographs are name of component datatypes
  //If inside identifier "x.y.z" then let it refer to identifier instead
  if IsInIdent or IsInInvokeArg then
    sym := identSym;
end;

destructor TZc.Destroy;
begin
  inherited;
  CleanUp;
end;

procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
begin
  if Op=nil then
  begin
    if SwitchOp.HasDefault then
      ZError('Only one default statement is allowed.');
    SwitchOp.HasDefault := True;
  end else
    Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
  SwitchOp.CaseOps.Last.Children.Add( Op );
  Op := nil;
end;

procedure TZc.CleanUp;
begin
  ZFunctions.Free;
end;

procedure TZc.ZError(const S : string);
var
  E : EParseError;
  P : TSymbolRec;
begin
  E := EParseError.Create(S);
  E.Message := S;
  Scanner.GetPosition(P);
  E.Line := P.Line;
  E.Col := P.Col;
  if (E.Line<>0) or (E.Col<>0) then
    E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
  raise E;
end;

function TZc.IsConst : boolean;
begin
  Result := (CurrentInputSymbol=constSym) or
    ((CurrentInputSymbol=privateSym) and (Symbols[2].Id=constSym));
end;

function TZc.IdentAndLPar : boolean;
begin
  Result := (CurrentInputSymbol=identSym) and (Symbols[2].Id=lparSym);
end;

// skip: { "[" { "," } "]" | "*" }
// !!! Proceeds from current peek position !!!
function TZc.IsPointerOrDims(var PeekIndex : integer) : boolean;
begin
  if Symbols[PeekIndex].Id=lbracksym then
  begin
    repeat
      Inc(PeekIndex);
      if PeekIndex>=Self.LookAheadCount then
        Exit(True);
    until Symbols[PeekIndex].Id=rbrackSym;
    Inc(PeekIndex);
  end;
  Result := True;

(*
  for (;;) {
    if (pt.kind == _lbrack) {
      do pt = scanner.Peek();
      while (pt.kind == _comma);
      if (pt.kind != _rbrack) return false;
    } else if (pt.kind != _times) break;
    pt = scanner.Peek();
  }
  return true;
*)
end;

function TZc.IsLocalVarDecl : boolean;
var
  PeekIndex : integer;
begin
  PeekIndex := 1;

	if (CurrentInputSymbol in [floatSym,intSym,byteSym,stringSym,modelSym,xptrSym,
    mat_fourSym,vec_twoSym,vec_threeSym,vec_fourSym,
  	MaterialSym,SoundSym,ShaderSym,BitmapSym,MeshSym,
  	CameraSym,FontSym,SampleSym,FileSym,ComponentSym
    ]) then
    Inc(PeekIndex)
  else if (CurrentInputSymbol=identSym) then
    Inc(PeekIndex)
  else
    Exit(False);

  Result := IsPointerOrDims(PeekIndex) and (Symbols[PeekIndex].Id=identSym);

(*  string ignore;
  Token pt = la;
  scanner.ResetPeek();

  if (typeKW[la.kind] || la.kind == _void) {
    pt = scanner.Peek();
    if (la.kind == _void && pt.kind != _times) { return false; }
  } else if (la.kind == _ident && !IsQualident(ref pt, out ignore)) {
    return false;
  }

  return IsPointerOrDims(ref pt) && pt.kind == _ident;*)

end;

function TZc.IsFieldDecl : boolean;
// ident ("," | "=" | ";")
begin
  Result := (CurrentInputSymbol=identSym) and
    (Symbols[2].Id in [commaSym,assgnSym,scolonSym]);

(*
bool IsFieldDecl () {
  int peek = Peek(1).kind;
  return la.kind == _ident &&
         (peek == _comma || peek == _assgn || peek == _scolon);
}
*)
end;

function TZc.NotFinalComma : boolean;
begin
  Result := (CurrentInputSymbol=commaSym) and
    (not (Symbols[2].Id in [rbraceSym,rbrackSym]));

(*
/* True, if the comma is not a trailing one, *
 * like the last one in: a, b, c,            */
bool NotFinalComma () {
  int peek = Peek(1).kind;
  return la.kind == _comma && peek != _rbrace && peek != _rbrack;
*)
end;

function TZc.GetInitializer : TZcOpFunctionUserDefined;
begin
  if not Self.AllowInitializer then
    ZError('Initializers only allowed in ZLibrary components located in App.OnLoaded');
  if not Assigned(InitializerFunction) then
  begin
    Self.InitializerFunction := TZcOpFunctionUserDefined.Create(nil);
    Self.ZFunctions.Insert(0,Self.InitializerFunction);
  end;
  Result := Self.InitializerFunction;
end;

procedure TZc.ParseEvalExpression;
var
  OutOp : TZcOp;
  Typ : TZcDataType;
  Func : TZcOpFunctionUserDefined;
begin
  Reinit;
  OutOp := nil;
  _Expr(OutOp);
  Typ := OutOp.GetDataType;

  Func := TZcOpFunctionUserDefined.Create(nil);
  Func.ReturnType := Typ;
  Self.CurrentFunction := Func;

  if Typ.Kind<>zctVoid then
  begin
    OutOp := MakeOp(zcReturn,[OutOp]);
  end;
  Func.Statements.Add(OutOp);
  Self.ZFunctions.Add(Func);
end;

procedure TZc.AddBaseClassToSymTab(TheClass : TZcOpClass);
var
  F: TZcOpField;
begin
  for F in TheClass.Fields do
    SymTab.Add(F.Id,F);
  if Assigned(TheClass.BaseClass) then
    AddBaseClassToSymTab(TheClass.BaseClass);
end;


procedure TZc._ZcFuncRest(Typ : TZcDataType; const Name : string; M : TModifiers; Cls : TZcOpClass);

var
  Func,OtherFunc : TZcOpFunctionUserDefined;
  Arg : TZcOpArgumentVar;

begin
       
        if (not Assigned(Cls)) or (not SameText(Name,Cls.Id)) then
        begin //Check for dup except if name of class constructor
          if SymTab.Contains(Name) then
            ZError('Name already defined: ' + Name);
        end;

        if mdPrivate in M then
          Func := TZcOpFunctionUserDefined.Create(nil)
        else
          Func := TZcOpFunctionUserDefined.Create(GlobalNames);
        Func.Id := Name;
        Func.ReturnType := Typ;
        Func.Modifiers := M;
        Self.CurrentFunction := Func;
        SymTab.PushScope;
        try

          if Assigned(Cls) then
          begin
            //Add implicit "this" argument to method definition
            Arg := TZcOpArgumentVar.Create(nil);
            Arg.Id := 'this';
            Arg.Typ.Kind := zctClass;
            Arg.Typ.TheClass := Cls;
            Func.MemberOf := Cls;
            Func.AddArgument(Arg);
            SymTab.Add(Arg.Id,Arg);

            if [mdVirtual,mdOverride]<=M then
              ZError('A function cannot be both virtual and override ' + Name);

            if mdVirtual in M then
            begin
              Func.VmtIndex := Cls.RuntimeClass.Vmt.Size div 4;
              Inc(Cls.RuntimeClass.Vmt.Size,4);
              ReallocMem(Cls.RuntimeClass.Vmt.Data,Cls.RuntimeClass.Vmt.Size);
            end;
          end else
          begin
            if (M-[mdPrivate,mdInline])<>[] then
              ZError('Invalid modifiers for function ' + Name);
          end;

     
  if InSet(CurrentInputSymbol,0) then
  begin
    _FormalParams;
  end;
  Expect(rparSym);
        
        Func.MangledName := MangleFunc(Name,CurrentFunction.Arguments.Count);
        if Assigned(Cls) then
        begin
          OtherFunc := Cls.FindMethod(Func.MangledName);

          Cls.Methods.Add(Func);
          //TODO: cannot add to symtab here because that could bind other method calls wrong (m.update in ClassesDemo)
          //SymTab.AddPrevious(Func.MangledName,Func);

          if mdOverride in M then
          begin
            if not Assigned(Cls.BaseClass) then
              ZError('Cannot override without baseclass ' + Name);
            if not Assigned(OtherFunc) then
              ZError('No method with this name in base class ' + Name);
            if not (mdVirtual in OtherFunc.Modifiers) then
              ZError('Method is not marked as virtual in base class ' + Name);
            Func.VmtIndex := OtherFunc.VmtIndex;
          end else if Assigned(OtherFunc) then
            ZError('Name already defined: ' + Name);
        end
        else
        begin
          if SymTab.Contains(Func.MangledName) then
            ZError('Name already defined: ' + Name);
          if mdPrivate in M then
            SymTab.AddPrevious(Func.MangledName,Func)
          else
            SymTab.AddPrevious(Func.MangledName,Func,2);
          ZFunctions.Add(Func);
        end;
      
  Expect(lbraceSym);
  _ZcFuncBody;
  Expect(rbraceSym);
          
          finally
            SymTab.PopScope;
          end;
        
end;

procedure TZc._FormalParams;
begin
  _Par;
  if (CurrentInputSymbol=commaSym) then
  begin
    Get;
    _FormalParams;
  end;
end;

procedure TZc._ZcFuncBody;
              var Op : TZcOp; 
begin
  while InSet(CurrentInputSymbol,1) do
  begin
         Op:=nil; 
    _Statement(Op);
         if Op<>nil then
           CurrentFunction.Statements.Add(Op);
         Op := nil;
      
  end;
end;

procedure TZc._Zc;
      var
        Typ : TZcDataType;
        Name : string;
        M : TModifiers;
        Op : TZcOp;
        IsPrivate : boolean;
    
begin
  while InSet(CurrentInputSymbol,2) do
  begin
    if (CurrentInputSymbol in [privateSym, constSym]) and ( IsConst ) then
    begin
         IsPrivate := False; 
         if (CurrentInputSymbol=privateSym) then
         begin
           Get;
                     IsPrivate:= True; 
         end;
         _ConstantDeclarationList(IsPrivate);
    end
    else if (CurrentInputSymbol=classSym) then
    begin
         IsPrivate := False; 
         _TypeDecl(IsPrivate);
    end
    else if InSet(CurrentInputSymbol,3) then
    begin
         M := [];  
         while (CurrentInputSymbol in [privateSym, inlineSym]) do
         begin
           _GlobalModifier(m);
         end;
         if (CurrentInputSymbol=voidSym) then
         begin
              Get;
                 Typ.Kind := zctVoid; 
         end
         else if InSet(CurrentInputSymbol,4) then
         begin
              _Type(Typ);
         end
         else SynError(1);
         Expect(identSym);
                                                                Name := LexString; 
         if (CurrentInputSymbol=lparSym) then
         begin
              Get;
              _ZcFuncRest(Typ,Name,M,nil);
         end
         else if (CurrentInputSymbol in [assgnSym, commaSym, scolonSym]) then
         begin
              _GlobalVarDecl(Typ,Name, mdPrivate in M );
              Expect(scolonSym);
         end
         else SynError(1);
    end
    else if (CurrentInputSymbol=lbraceSym) then
    begin
         CurrentFunction := GetInitializer; 
         _Block(Op);
         GetInitializer.Statements.Add(Op); CurrentFunction := nil; 
    end
    ;
  end;
end;

procedure TZc._ConstantDeclarationList(IsPrivate : boolean);

var
  Typ : TZcDataType;

begin
  Expect(constSym);
  _Type(Typ);
  _ConstantDeclaration(Typ,IsPrivate);
  while (CurrentInputSymbol=commaSym) do
  begin
    Get;
    _ConstantDeclaration(Typ,IsPrivate);
  end;
  Expect(scolonSym);
end;

procedure TZc._TypeDecl(IsPrivate : boolean);

var
  Cls : TZcOpClass;
  BaseTyp : TZcDataType;
  Name : string;
  Op : TZcOp;
  Size : integer;

begin
  Expect(classSym);
  Expect(identSym);
                   Name := LexString; 
       BaseTyp.Kind := zctVoid; 
  if (CurrentInputSymbol=colonSym) then
  begin
    Get;
    _ClassType(BaseTyp);
  end;
      
      if SymTab.Contains(Name) then
        ZError('Name already defined: ' + Name);
      Cls := TZcOpClass.Create(GlobalNames);
      Cls.Id := Name;

      Cls.RuntimeClass := TUserClass.Create(Self.ZApp.UserClasses);
      if BaseTyp.Kind<>zctVoid then
      begin //base class specified
        Cls.BaseClass := BaseTyp.TheClass as TZcOpClass;
        Cls.RuntimeClass.SizeInBytes := Cls.BaseClass.RuntimeClass.SizeInBytes;
        Cls.RuntimeClass.BaseClass := Cls.BaseClass.RuntimeClass;

        //Copy VMT from base
        Cls.RuntimeClass.Vmt.Size := Cls.BaseClass.RuntimeClass.Vmt.Size;
        if Cls.RuntimeClass.Vmt.Size>0 then
        begin
          GetMem(Cls.RuntimeClass.Vmt.Data,Cls.RuntimeClass.Vmt.Size);
          //fill with -1 to indicate method is not overridden
          FillChar(Cls.RuntimeClass.Vmt.Data^,Cls.RuntimeClass.Vmt.Size,$ff);
        end;

        //Copy managed list from base
        Size := Cls.BaseClass.RuntimeClass.ManagedFields.Size;
        if Size<>0 then
        begin
          Cls.RuntimeClass.ManagedFields.Size := Size;
          GetMem(Cls.RuntimeClass.ManagedFields.Data,Size);
          Move(Cls.BaseClass.RuntimeClass.ManagedFields.Data^,Cls.RuntimeClass.ManagedFields.Data^,Size);
        end;

        //if baseclass has initializer, then inject call to "$baseclass.init" in childclass initializer.
        if Cls.BaseClass.Initializer.Statements.Count>0 then
        begin
          Op := MakeOp(zcMethodCall,'$init');
          Op.Ref := Cls.BaseClass;
          Op.Children.Add( MakeOp(zcIdentifier,'this') );
          Op.Children.Last.Ref := Cls.Initializer.Arguments.First;
          Cls.Initializer.Statements.Add(Op);
        end;
      end;
      CompilerContext.CurrentClass := Cls;

      SymTab.AddPrevious(Cls.Id,Cls);
    
  _ClassBody(Cls);
  if (CurrentInputSymbol=scolonSym) then
  begin
    Get;
  end;
      
      ZFunctions.Add(Cls);
      CompilerContext.CurrentClass := nil;
    
end;

procedure TZc._GlobalModifier(var M : TModifiers);
begin
  if (CurrentInputSymbol=privateSym) then
  begin
       Get;
                    if mdPrivate in m then ZError('private already specified'); Include(m,mdPrivate); 
  end
  else if (CurrentInputSymbol=inlineSym) then
  begin
       Get;
                    if mdInline in m then ZError('inline already specified'); Include(m,mdInline); 
  end
  else SynError(2);
end;

procedure TZc._Type(var Typ : TZcDataType);

  var
    A : TDefineArray;
    SizeOp : TZcOp;
    I : integer;

begin
      FillChar(Typ,SizeOf(Typ),0); 
  if InSet(CurrentInputSymbol,5) then
  begin
       _SimpleType(Typ);
  end
  else if (CurrentInputSymbol=identSym) then
  begin
       _ClassType(Typ);
  end
  else SynError(3);
  while (CurrentInputSymbol=lbrackSym) do
  begin
    Get;
                  
                   A := TDefineArray.Create(nil);
                   GlobalNames.Add(A);
                   A._Type := Typ;
                   Typ.Kind := zctArray;
                   Typ.TheArray := A;
                
    if InSet(CurrentInputSymbol,6) then
    begin
      _Expr(SizeOp);
                          
            SizeOp := SizeOp.Optimize;
            if SizeOp.Kind<>zcConstLiteral then
              ZError('Array size must be a constant expression');
            A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
                         
    end;
    while (CurrentInputSymbol=commaSym) do
    begin
      Get;
                   if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); 
      if InSet(CurrentInputSymbol,6) then
      begin
        _Expr(SizeOp);
                            
                SizeOp := SizeOp.Optimize;
                if SizeOp.Kind<>zcConstLiteral then
                  ZError('Array size must be a constant expression');
               I := Trunc( (SizeOp as TZcOpLiteral).Value );
               if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
           
      end;
    end;
    Expect(rbrackSym);
  end;
end;

procedure TZc._GlobalVarDecl(Typ : TZcDataType; const Name : string; IsPrivate : boolean);
begin
  _GlobalVarRest(Typ,Name,IsPrivate);
  while (CurrentInputSymbol=commaSym) do
  begin
    Get;
    _GlobalVar(Typ,IsPrivate);
  end;
end;

procedure TZc._Block(var OutOp : TZcOp);
     var
       Op : TZcOp;
  
begin
     Op := nil;
     OutOp := MakeOp(zcBlock);
  
  Expect(lbraceSym);
         SymTab.PushScope;
         CurrentFunction.PushScope;
         try 
  while InSet(CurrentInputSymbol,1) do
  begin
    _Statement(Op);
                       if Assigned(Op) then OutOp.Children.Add(Op); 
  end;
  Expect(rbraceSym);
        
         finally
           SymTab.PopScope;
           CurrentFunction.PopScope;
         end;
      
end;

procedure TZc._Field(Typ : TZcDataType; Cls : TZcOpClass; IsPrivate : boolean);

var
  Fld : TZcOpField;
  Op,InitOp : TZcOp;
  FldSize : integer;

begin
  Expect(identSym);
    
     Fld := TZcOpField.Create(nil);
     Fld.Id := LexString;
     Fld.Typ := Typ;
     Fld.IsPrivate := IsPrivate;
     Fld.MemberOf := Cls;

     if Assigned(Cls.FindField(Fld.Id)) then
       ZError('Field already defined ' + Fld.Id);

     //field align
     FldSize := GetZcTypeSize(Fld.Typ.Kind);
     Cls.RuntimeClass.SizeInBytes := AlignX(Cls.RuntimeClass.SizeInBytes, FldSize);
     Fld.ByteOffset := Cls.RuntimeClass.SizeInBytes;
     Inc(Cls.RuntimeClass.SizeInBytes, FldSize );

     if Fld.Typ.Kind in ManagedTypes then
     begin //Managed field
       Inc(Cls.RuntimeClass.ManagedFields.Size,4);
       ReallocMem(Cls.RuntimeClass.ManagedFields.Data,Cls.RuntimeClass.ManagedFields.Size);
       PInteger( pointer(IntPtr(Cls.RuntimeClass.ManagedFields.Data)+Cls.RuntimeClass.ManagedFields.Size-4) )^ := Fld.ByteOffset;
     end;

     Cls.Fields.Add(Fld);

     SymTab.AddPrevious(Fld.Id,Fld);

     InitOp := nil;
     CurrentFunction := Cls.Initializer; //Needed so that any temporary locals in init are added to the correct function
  
  if (CurrentInputSymbol=assgnSym) then
  begin
    Get;
    _Init(InitOp);
  end;
    
     Op := nil;
     MakeVarInitializer(Fld,InitOp,Op);
     if Assigned(Op) then
       Cls.Initializer.Statements.Add(Op);
     CurrentFunction := nil;
  
end;

procedure TZc._Init(var OutOp : TZcOp);
begin
  if InSet(CurrentInputSymbol,6) then
  begin
       _Expr(OutOp);
  end
  else if (CurrentInputSymbol=lbraceSym) then
  begin
       _ArrayInit(OutOp);
  end
  else SynError(4);
end;

procedure TZc._StructMember(Cls : TZcOpClass; M : TModifiers);
                                                 
var
  Typ : TZcDataType;
  Name : string;

begin
  if (CurrentInputSymbol=voidSym) then
  begin
 Typ.Kind := zctVoid; 
       Get;
       Expect(identSym);
                  Name := LexString; 
       Expect(lparSym);
       _ZcFuncRest(Typ,Name,M,Cls);
  end
  else if (CurrentInputSymbol=identSym) and ( IdentAndLPar ) then
  begin
       Expect(identSym);
          
     Name := LexString;
     if not SameText(Name,Cls.Id) then
       ZError('Constructor must have same name as class: ' + Name);
     
       Expect(lparSym);
       _ZcFuncRest(Typ,Name,M,Cls);
  end
  else if InSet(CurrentInputSymbol,4) then
  begin
       _Type(Typ);
       if (CurrentInputSymbol=identSym) and ( IsFieldDecl ) then
       begin
            
            if (M-[mdPrivate])<>[] then
              ZError('Field cannot have these modifiers ' + LexString);
            SymTab.PushScope;
            try
              //Add "this" to scope
              SymTab.Add(Cls.Initializer.Arguments.First.Id, Cls.Initializer.Arguments.First);
          
            _Field(Typ,Cls,mdPrivate in M);
            while (CurrentInputSymbol=commaSym) do
            begin
              Get;
              _Field(Typ,Cls,mdPrivate in M);
            end;
            Expect(scolonSym);
            
            finally
              SymTab.PopScope;
            end;
          
       end
       else if (CurrentInputSymbol=identSym) then
       begin
            Get;
                    Name := LexString; 
            Expect(lparSym);
            _ZcFuncRest(Typ,Name,M,Cls);
       end
       else SynError(5);
  end
  else SynError(5);
end;

procedure TZc._MemberModifier(var M : TModifiers);
begin
  if (CurrentInputSymbol=privateSym) then
  begin
       Get;
                    if mdPrivate in m then ZError('private already specified'); Include(m,mdPrivate); 
  end
  else if (CurrentInputSymbol=inlineSym) then
  begin
       Get;
                    if mdInline in m then ZError('inline already specified'); Include(m,mdInline); 
  end
  else if (CurrentInputSymbol=virtualSym) then
  begin
       Get;
                     if mdVirtual in m then ZError('virtual already specified'); Include(m,mdVirtual); 
  end
  else if (CurrentInputSymbol=overrideSym) then
  begin
       Get;
                      if mdOverride in m then ZError('override already specified'); Include(m,mdOverride); 
  end
  else SynError(6);
end;

procedure TZc._ClassMember(Cls : TZcOpClass; M : TModifiers);
begin
  _StructMember(Cls,M);
end;

procedure TZc._ClassBody(Cls : TZcOpClass);

var
  M : TModifiers;

begin
  Expect(lbraceSym);
         try
           SymTab.PushScope;

           if Assigned(Cls.BaseClass) then
             //Make sure any inherited fields also can be accessed without the "this" prefix
             AddBaseClassToSymTab(Cls.BaseClass);
      
  while InSet(CurrentInputSymbol,7) do
  begin
           M := []; 
    while InSet(CurrentInputSymbol,8) do
    begin
      _MemberModifier(m);
    end;
    _ClassMember(Cls,M);
  end;
  Expect(rbraceSym);
        
         finally
           SymTab.PopScope;
         end;
      
end;

procedure TZc._ClassType(var Typ : TZcDataType);

var
  O : TObject;

begin
  Expect(identSym);
      
       O := SymTab.Lookup(LexString);
       if (O=nil) or (not (O is TZcOpClass)) then
         ZError('Unknown type: ' + LexString);
       Typ.Kind := zctClass;
       Typ.TheClass := O;
    
end;

procedure TZc._Statement(var OutOp : TZcOp);
begin
  if (CurrentInputSymbol=constSym) then
  begin
     OutOp := nil; 
       _ConstantDeclarationList(false);
  end
  else if InSet(CurrentInputSymbol,4) and ( IsLocalVarDecl ) then
  begin
       _LocalVarDecl(OutOp);
       Expect(scolonSym);
  end
  else if InSet(CurrentInputSymbol,9) then
  begin
       _EmbeddedStatement(OutOp);
  end
  else SynError(7);
end;

procedure TZc._Par;
      
var
  Typ : TZcDataType;
  Arg : TZcOpArgumentVar;
  IsPtr : boolean;

begin
      IsPtr := False; 
  if (CurrentInputSymbol=refSym) then
  begin
    Get;
            IsPtr := True; 
  end;
  _Type(Typ);
  Expect(identSym);
       
        Typ.IsPointer := IsPtr;
        if SymTab.ScopeContains(LexString) then
          SynError(201)
        else
        begin
          Arg := TZcOpArgumentVar.Create(nil);
          Arg.Id := LexString;
          Arg.Typ := Typ;
          CurrentFunction.AddArgument(Arg);
          SymTab.Add(Arg.Id,Arg);
        end;
     
end;

procedure TZc._LocalVarDecl(var OutOp : TZcOp);
                                   var Typ : TZcDataType; 
begin
     OutOp := nil; 
  _Type(Typ);
  _LocalVar(Typ,OutOp);
  while (CurrentInputSymbol=commaSym) do
  begin
    Get;
    _LocalVar(Typ,OutOp);
  end;
end;

procedure TZc._LocalVar(Typ : TZcDataType; var OutOp : TZcOp);

var
  Loc : TZcOpLocalVar;
  InitOp : TZcOp;

begin
  Expect(identSym);
       
        if SymTab.ScopeContains(LexString) then
          ZError('Name already defined: ' + LexString);

        Loc := TZcOpLocalVar.Create(nil);
        Loc.Id := LexString;
        Loc.Typ := Typ;
     
  if (CurrentInputSymbol=assgnSym) then
  begin
    Get;
    _Init(InitOp);
                           Loc.InitExpression:=InitOp; 
  end;
       
        SymTab.Add(Loc.Id,Loc);
        CurrentFunction.AddLocal(Loc);

        MakeVarInitializer(Loc,Loc.InitExpression,OutOp);
     
end;

procedure TZc._GlobalVarRest(Typ : TZcDataType; const Name : string; IsPrivate : boolean);

var
  V : TDefineVariableBase;
  Glob : TZcOpGlobalVar;
  InitOp : TZcOp;

begin
       
        if SymTab.ScopeContains(Name) then
          ZError('Name already defined: ' + Name);

        V := nil;
        if not (Typ.Kind in [zctArray,zctMat4,zctVec2,zctVec3,zctVec4]) then
        begin  //Stored in global area
          if IsPrivate then
            Glob := TZcOpGlobalVar.Create(nil)
          else
            Glob := TZcOpGlobalVar.Create(GlobalNames);
          Glob.Lib := CompilerContext.ThisC as TZLibrary;
          Glob.Offset := Glob.Lib.GlobalAreaSize;
          Glob.Id := Name;
          Glob.Typ := Typ;

          Glob.Lib.AddGlobalVar(Typ);

          if IsPrivate then
            SymTab.Add(Name,Glob)
          else
            SymTab.AddPrevious(Name,Glob);
        end
        else if Typ.Kind=zctArray then
        begin
          //todo: store arrays in global area too, need to generate initialization code
          TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
          V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
          V._Type := TDefineArray(Typ.TheArray)._Type;
          Self.ZApp.GlobalVariables.AddComponent(V);
        end
        else
        begin //zctMat4,zctVec2,zctVec3,zctVec4
          V := TDefineVariable.Create(Self.ZApp.GlobalVariables);
          V._Type := Typ;
        end;

        if Assigned(V) then
        begin
          V.SetString('Name', AnsiString(Name));
          V.DesignerReset; //Needed to init managed variables
          if IsPrivate then
            SymTab.Add(Name,V)
          else
            SymTab.AddPrevious(Name,V);
        end;
     
  if (CurrentInputSymbol=assgnSym) then
  begin
    Get;
    _Init(InitOp);
                          
       //todo: array initializer of global arrays
       GetInitializer.Statements.Add( MakeAssign(atAssign, CheckPrimary( MakeIdentifier(Name) ),InitOp) );
       
  end;
end;

procedure TZc._GlobalVar(Typ : TZcDataType; IsPrivate : boolean);
begin
  Expect(identSym);
  _GlobalVarRest(Typ,LexString,IsPrivate);
end;

procedure TZc._Expr(var OutOp : TZcOp);
                             var Op1,Op2 : TZcOp; Kind : TZcAssignType; 
begin
     Op1 :=nil; Op2 := nil; 
  _Unary(Op1);
  if InSet(CurrentInputSymbol,10) then
  begin
       _OrExpr(Op1,OutOp);
       if (CurrentInputSymbol=_querySym) then
       begin
         Get;
         _Expr(Op1);
         Expect(colonSym);
         _Expr(Op2);
            if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
              SynError(205)
            else
              OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
         
       end;
  end
  else if InSet(CurrentInputSymbol,11) then
  begin
       _AssignOp(Kind);
       _Expr(Op2);
                                   OutOp := MakeAssign(Kind,Op1, Op2); 
  end
  else SynError(8);
end;

procedure TZc._ArrayInit(var OutOp : TZcOp);

var
  Op : TZcOp;

begin
  Expect(lbraceSym);
         OutOp := MakeOp(zcBlock); 
  if InSet(CurrentInputSymbol,12) then
  begin
    _Init(Op);
               OutOp.Children.Add(Op); 
    while (CurrentInputSymbol=commaSym) and ( NotFinalComma ) do
    begin
      Expect(commaSym);
      _Init(Op);
                                            OutOp.Children.Add(Op); 
    end;
    if (CurrentInputSymbol=commaSym) then
    begin
      Get;
    end;
  end;
  Expect(rbraceSym);
end;

procedure TZc._Argument(var OutOp : TZcOp);
begin
     OutOp := nil; 
  _Expr(OutOp);
     if OutOp=nil then ZError('Missing argument'); 
end;

procedure TZc._SimpleType(var Typ : TZcDataType);

  var
    A : TDefineArray;

begin
  if (CurrentInputSymbol=floatSym) then
  begin
       Get;
             Typ.Kind := zctFloat; 
  end
  else if (CurrentInputSymbol=intSym) then
  begin
       Get;
             Typ.Kind := zctInt; 
  end
  else if (CurrentInputSymbol=byteSym) then
  begin
       Get;
              Typ.Kind := zctByte; 
  end
  else if (CurrentInputSymbol=stringSym) then
  begin
       Get;
                Typ.Kind := zctString; 
  end
  else if (CurrentInputSymbol=modelSym) then
  begin
       Get;
               Typ.Kind := zctModel; 
  end
  else if (CurrentInputSymbol=xptrSym) then
  begin
       Get;
              Typ.Kind := zctXptr; 
  end
  else if (CurrentInputSymbol=mat_fourSym) then
  begin
       Get;
             
     A := Prototypes.Mat4Array;
     Typ.Kind := zctMat4;
     Typ.TheArray := A;
    
  end
  else if (CurrentInputSymbol=vec_twoSym) then
  begin
       Get;
             
     A := Prototypes.Vec2Array;
     Typ.Kind := zctVec2;
     Typ.TheArray := A;
  
  end
  else if (CurrentInputSymbol=vec_threeSym) then
  begin
       Get;
             
     A := Prototypes.Vec3Array;
     Typ.Kind := zctVec3;
     Typ.TheArray := A;
  
  end
  else if (CurrentInputSymbol=vec_fourSym) then
  begin
       Get;
             
     A := Prototypes.Vec4Array;
     Typ.Kind := zctVec4;
     Typ.TheArray := A;
  
  end
  else if (CurrentInputSymbol=MaterialSym) then
  begin
       Get;
                  Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; 
  end
  else if (CurrentInputSymbol=SoundSym) then
  begin
       Get;
               Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; 
  end
  else if (CurrentInputSymbol=ShaderSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; 
  end
  else if (CurrentInputSymbol=BitmapSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; 
  end
  else if (CurrentInputSymbol=MeshSym) then
  begin
       Get;
              Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; 
  end
  else if (CurrentInputSymbol=CameraSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; 
  end
  else if (CurrentInputSymbol=FontSym) then
  begin
       Get;
              Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; 
  end
  else if (CurrentInputSymbol=SampleSym) then
  begin
       Get;
                Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; 
  end
  else if (CurrentInputSymbol=FileSym) then
  begin
       Get;
              Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; 
  end
  else if (CurrentInputSymbol=ComponentSym) then
  begin
       Get;
                   Typ.Kind := zctReference; Typ.ReferenceClassId := AnyComponentClassId; 
  end
  else SynError(9);
end;

procedure TZc._ConstantDeclaration(var Typ : TZcDataType; IsPrivate : boolean);

var
  Cns : TDefineConstant;
  Op : TZcOp;
  Lit : TZcOpLiteral;
  CnsName : string;

begin
  Expect(identSym);
         CnsName := LexString; 
  Expect(assgnSym);
  _Expr(Op);
    
   if not (Typ.Kind in [zctByte,zctInt,zctFloat,zctString]) then
     ZError('Only byte, int, float and string constants are allowed');

   Op := Op.Optimize;
   if not (Op is TZcOpLiteral) then
     ZError('Constant expression expected: ' + Op.ToString);

   Lit := Op as TZcOpLiteral;

   if (Lit.Typ.Kind<>Typ.Kind)
     and not ((Typ.Kind=zctByte) and (Lit.Typ.Kind=zctInt))
     and not ((Typ.Kind=zctInt) and (Lit.Typ.Kind=zctFloat))
     then
     ZError('Constant expression is not of the expected type: ' + Op.ToString);

   Cns := TDefineConstant.Create(nil);
   Cns.SetString('Name',AnsiString(CnsName));
   GlobalNames.Add(Cns);

   case Typ.Kind of
     zctByte:
       begin
         Cns._Type.Kind := zctByte;
         Cns.ByteValue := Round(Lit.Value);
       end;
     zctInt:
       begin
         Cns._Type.Kind := zctInt;
         Cns.IntValue := Round(Lit.Value);
       end;
     zctFloat:
       begin
         Cns._Type.Kind := zctFloat;
         Cns.Value := Lit.Value;
       end;
     zctString:
       begin
         Cns._Type.Kind := zctString;
         Cns.SetString('StringValue',AnsiString(Lit.StringValue));
       end;
     else
       ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
   end;
   if IsPrivate then
     SymTab.Add(CnsName,Cns)
   else
     SymTab.AddPrevious(CnsName,Cns)
  
end;

procedure TZc._EmbeddedStatement(var OutOp : TZcOp);
     var
       SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
       ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
       WhileCondOp,WhileBodyOp : TZcOp;
       SwitchOp : TZcOpSwitch;
       Loc : TZcOpLocalVar;
  
begin
  if (CurrentInputSymbol=lbraceSym) then
  begin
       _Block(OutOp);
  end
  else if (CurrentInputSymbol=scolonSym) then
  begin
       Get;
           OutOp := MakeOp(zcNop); 
  end
  else if InSet(CurrentInputSymbol,6) then
  begin
       _StatementExpr(OutOp);
       Expect(scolonSym);
  end
  else if (CurrentInputSymbol=ifSym) then
  begin
       Get;
          ElseOp := nil; 
       Expect(lparSym);
       _Expr(IfOp);
       Expect(rparSym);
       _EmbeddedStatement(IfBody);
       if (CurrentInputSymbol=elseSym) then
       begin
         Get;
         _EmbeddedStatement(ElseOp);
       end;
           OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); 
  end
  else if (CurrentInputSymbol=switchSym) then
  begin
       Get;
       Expect(lparSym);
       _Expr(SwitchValueOp);
       Expect(rparSym);
        
         OutOp := MakeOp(zcBlock);

         SwitchOp := TZcOpSwitch.Create(nil);

         if (SwitchValueOp.Ref is TZcOpVariableBase) or (SwitchValueOp.Kind=zcConstLiteral) then
           SwitchOp.ValueOp := SwitchValueOp
         else
         begin
           Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
           SymTab.Add(Loc.Id,Loc);
           CurrentFunction.AddLocal(Loc);
           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
           SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
         end;

         OutOp.Children.Add(SwitchOp);
      
       Expect(lbraceSym);
       while (CurrentInputSymbol in [caseSym, defaultSym]) do
       begin
        SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); 
         _SwitchSection(SwitchOp);
       end;
       Expect(rbraceSym);
  end
  else if (CurrentInputSymbol=whileSym) then
  begin
       Get;
        try
         SymTab.PushScope;
         CurrentFunction.PushScope;
         WhileCondOp := nil; WhileBodyOp := nil; 
       Expect(lparSym);
       _Expr(WhileCondOp);
       Expect(rparSym);
       _EmbeddedStatement(WhileBodyOp);
     
         OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
       finally
         SymTab.PopScope;
         CurrentFunction.PopScope;
       end;
   
  end
  else if (CurrentInputSymbol=doSym) then
  begin
       Get;
        try
         SymTab.PushScope;
         CurrentFunction.PushScope;
         WhileCondOp := nil; WhileBodyOp := nil; 
       _EmbeddedStatement(WhileBodyOp);
       Expect(whileSym);
       Expect(lparSym);
       _Expr(WhileCondOp);
       Expect(rparSym);
       Expect(scolonSym);
     
         OutOp := MakeOp(zcDoWhile,[WhileCondOp,WhileBodyOp]);
       finally
         SymTab.PopScope;
         CurrentFunction.PopScope;
       end;
   
  end
  else if (CurrentInputSymbol=forSym) then
  begin
       Get;
       try
         SymTab.PushScope;
         CurrentFunction.PushScope;
         ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; 
       Expect(lparSym);
       if InSet(CurrentInputSymbol,13) then
       begin
         _ForInit(ForInitOp);
       end;
       Expect(scolonSym);
       if InSet(CurrentInputSymbol,6) then
       begin
         _Expr(ForCondOp);
       end;
       Expect(scolonSym);
       if InSet(CurrentInputSymbol,6) then
       begin
         _ForInc(ForIncOp);
       end;
       Expect(rparSym);
       _EmbeddedStatement(ForBodyOp);
     
         OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
       finally
         SymTab.PopScope;
         CurrentFunction.PopScope;
       end;
   
  end
  else if (CurrentInputSymbol=breakSym) then
  begin
       Get;
       Expect(scolonSym);
                     OutOp := MakeOp(zcBreak); 
  end
  else if (CurrentInputSymbol=continueSym) then
  begin
       Get;
       Expect(scolonSym);
                     OutOp := MakeOp(zcContinue); 
  end
  else if (CurrentInputSymbol=returnSym) then
  begin
      Op := nil; 
       Get;
       if InSet(CurrentInputSymbol,6) then
       begin
         _Expr(Op);
       end;
       Expect(scolonSym);
      
        if (Op=nil) then
        begin
          if CurrentFunction.ReturnType.Kind<>zctVoid then
            SynError(202)
          else
            OutOp := MakeOp(zcReturn);
        end else
        begin
          if CurrentFunction.ReturnType.Kind=zctVoid then
            SynError(203)
          else
            OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
        end;
        Inc(CurrentFunction.ReturnCount);
    
  end
  else SynError(10);
end;

procedure TZc._StatementExpr(var OutOp : TZcOp);
                                              var Op1,Op2 : TZcOp; Kind : TZcAssignType; 
begin
     Op1 :=nil; Op2 := nil; 
  _Unary(Op1);
  if InSet(CurrentInputSymbol,11) then
  begin
       _AssignOp(Kind);
       _Expr(Op2);
      
      if Op2<>nil then
        OutOp := MakeAssign(Kind,Op1,Op2);
    
  end
  else if (CurrentInputSymbol in [commaSym, rparSym, scolonSym]) then
  begin
                                   OutOp := Op1; 
  end
  else SynError(11);
end;

procedure TZc._SwitchSection(SwitchOp : TZcOpSwitch);
                                         var Op : TZcOp; 
begin
     Op := nil; 
  _SwitchLabel(Op);
                       AddSwitchLabel(SwitchOp,Op); 
  while (CurrentInputSymbol in [caseSym, defaultSym]) do
  begin
    _SwitchLabel(Op);
                       AddSwitchLabel(SwitchOp,Op); 
  end;
  _Statement(Op);
                      if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); 
  while InSet(CurrentInputSymbol,1) do
  begin
    _Statement(Op);
                      if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); 
  end;
end;

procedure TZc._ForInit(var OutOp : TZcOp);
                                  var Op : TZcOp; 
begin
     Op:=nil; OutOp := MakeOp(zcBlock); 
  if InSet(CurrentInputSymbol,4) and ( IsLocalVarDecl ) then
  begin
       _LocalVarDecl(Op);
                                            if Assigned(Op) then OutOp.Children.Add(Op); 
  end
  else if InSet(CurrentInputSymbol,6) then
  begin
     Op:=nil; 
       _StatementExpr(Op);
                                      if Assigned(Op) then OutOp.Children.Add(Op); 
       while (CurrentInputSymbol=commaSym) do
       begin
       Op:=nil; 
         Get;
         _StatementExpr(Op);
                                            if Assigned(Op) then OutOp.Children.Add(Op); 
       end;
  end
  else SynError(12);
end;

procedure TZc._ForInc(var OutOp : TZcOp);
                                  var Op : TZcOp; 
begin
     Op:=nil;
     OutOp := MakeOp(zcBlock);
  
  _StatementExpr(Op);
                     if Assigned(Op) then OutOp.Children.Add(Op); 
  while (CurrentInputSymbol=commaSym) do
  begin
     Op:=nil; 
    Get;
    _StatementExpr(Op);
                                          if Assigned(Op) then OutOp.Children.Add(Op); 
  end;
end;

procedure TZc._Unary(var OutOp : TZcOp);
                                    var LastOp,Tmp : TZcOp; Kind : TZcOpKind; 
begin
           LastOp := nil; Kind := zcNop; 
  while InSet(CurrentInputSymbol,14) do
  begin
    if (CurrentInputSymbol=minusSym) then
    begin
         Get;
               Kind := zcNegate; 
    end
    else if (CurrentInputSymbol=incSym) then
    begin
         Get;
               Kind := zcPreInc; 
    end
    else if (CurrentInputSymbol=decSym) then
    begin
         Get;
               Kind := zcPreDec; 
    end
    else if (CurrentInputSymbol=notSym) then
    begin
         Get;
               Kind := zcNot; 
    end
    else if (CurrentInputSymbol=tildeSym) then
    begin
         Get;
               Kind := zcBinaryNot; 
    end
    ;
      
       if Kind in [zcNot,zcBinaryNot] then
       begin
         Tmp := MakeOp(Kind);
         if LastOp<>nil then
           LastOp.Children.Add(Tmp);
         LastOp := Tmp;
       end else if Assigned(LastOp) then
         ZError('- ,-- and ++ cannot be combined with other unary ops');
    
  end;
  _Primary(Tmp);
      
       if Kind=zcNegate then
         OutOp := MakeBinary(zcMinus, TZcOpLiteral.Create(Tmp.GetDataType.Kind,0), Tmp)
       else if Kind in [zcNop,zcNot,zcBinaryNot] then
       begin
         if LastOp<>nil then
         begin
           LastOp.Children.Add(Tmp);
           OutOp := LastOp;
         end else
           OutOp := Tmp;
       end else
       begin
         OutOp := MakePrePostIncDec(Kind,Tmp);
       end;
    
end;

procedure TZc._AssignOp(var Kind : TZcAssignType);
begin
  if (CurrentInputSymbol=assgnSym) then
  begin
       Get;
             Kind := atAssign; 
  end
  else if (CurrentInputSymbol=_plus_equalSym) then
  begin
       Get;
             Kind := atPlusAssign; 
  end
  else if (CurrentInputSymbol=_minus_equalSym) then
  begin
       Get;
             Kind := atMinusAssign; 
  end
  else if (CurrentInputSymbol=_star_equalSym) then
  begin
       Get;
             Kind := atMulAssign; 
  end
  else if (CurrentInputSymbol=_slash_equalSym) then
  begin
       Get;
             Kind := atDivAssign; 
  end
  else if (CurrentInputSymbol=_bar_equalSym) then
  begin
       Get;
             Kind := atOrAssign; 
  end
  else if (CurrentInputSymbol=_less_less_equalSym) then
  begin
       Get;
              Kind := atShiftLeftAssign; 
  end
  else if (CurrentInputSymbol=_greater_greater_equalSym) then
  begin
       Get;
              Kind := atShiftRightAssign; 
  end
  else if (CurrentInputSymbol=_and_equalSym) then
  begin
       Get;
             Kind := atAndAssign; 
  end
  else SynError(13);
end;

procedure TZc._SwitchLabel(var OutOp : TZcOp);
begin
  if (CurrentInputSymbol=caseSym) then
  begin
       Get;
       _Expr(OutOp);
       Expect(colonSym);
  end
  else if (CurrentInputSymbol=defaultSym) then
  begin
       Get;
       Expect(colonSym);
  end
  else SynError(14);
end;

procedure TZc._OrExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                   var Op,L,R : TZcOp; 
begin
  _AndExpr(InOp,OutOp);
                           L := OutOp; 
  while (CurrentInputSymbol=_bar_barSym) do
  begin
    Get;
    _Unary(Op);
    _AndExpr(Op,R);
         OutOp := MakeOp(zcOr,[L,R]);
         L := OutOp; 
  end;
end;

procedure TZc._AndExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp; 
begin
  _BitOrExpr(InOp,OutOp);
                            L := OutOp; 
  while (CurrentInputSymbol=_and_andSym) do
  begin
    Get;
    _Unary(Op);
    _BitOrExpr(Op,R);
         OutOp := MakeOp(zcAnd,[L,R]);
         L := OutOp; 
  end;
end;

procedure TZc._BitOrExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                      var Op,L,R : TZcOp; 
begin
  _BitXorExpr(InOp,OutOp);
                            L := OutOp; 
  while (CurrentInputSymbol=orSym) do
  begin
    Get;
    _Unary(Op);
    _BitXorExpr(Op,R);
       OutOp := MakeOp(zcBinaryOr,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._BitXorExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                       var Op,L,R : TZcOp; 
begin
  _BitAndExpr(InOp,OutOp);
                            L := OutOp; 
  while (CurrentInputSymbol=xorSym) do
  begin
    Get;
    _Unary(Op);
    _BitAndExpr(Op,R);
       OutOp := MakeOp(zcBinaryXor,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._BitAndExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                       var Op,L,R : TZcOp; 
begin
  _EqlExpr(InOp,OutOp);
                         L := OutOp; 
  while (CurrentInputSymbol=andSym) do
  begin
    Get;
    _Unary(Op);
    _EqlExpr(Op,R);
       OutOp := MakeOp(zcBinaryAnd,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._EqlExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp; Kind : TZcOpKind; 
begin
  _RelExpr(InOp,OutOp);
                         L := OutOp; Kind := zcNop; 
  while (CurrentInputSymbol in [eqSym, neqSym]) do
  begin
    if (CurrentInputSymbol=neqSym) then
    begin
         Get;
               Kind := zcCompNE; 
    end
    else if (CurrentInputSymbol=eqSym) then
    begin
         Get;
               Kind := zcCompEQ; 
    end
    ;
    _Unary(Op);
    _RelExpr(Op,R);
            OutOp := MakeBinary(Kind, L,R);
            L := OutOp;
         
  end;
end;

procedure TZc._RelExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp;  Kind : TZcOpKind; 
begin
  _ShiftExpr(InOp,OutOp);
                           L := OutOp; Kind := zcNop; 
  while InSet(CurrentInputSymbol,15) do
  begin
    if (CurrentInputSymbol=ltSym) then
    begin
         Get;
                   Kind := zcCompLT; 
    end
    else if (CurrentInputSymbol=gtSym) then
    begin
         Get;
                   Kind := zcCompGT; 
    end
    else if (CurrentInputSymbol=lteSym) then
    begin
         Get;
                   Kind := zcCompLE; 
    end
    else if (CurrentInputSymbol=gteSym) then
    begin
         Get;
                   Kind := zcCompGE; 
    end
    ;
    _Unary(Op);
    _ShiftExpr(Op,R);
            OutOp := MakeBinary(Kind, L,R );
            L := OutOp;
         
  end;
end;

procedure TZc._ShiftExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                      var Op,L,R : TZcOp; Kind : TZcOpKind; 
begin
  _AddExpr(InOp,OutOp);
                         L := OutOp; Kind := zcNop; 
  while (CurrentInputSymbol in [lshiftSym, rshiftSym]) do
  begin
    if (CurrentInputSymbol=lshiftSym) then
    begin
         Get;
              Kind := zcBinaryShiftL; 
    end
    else if (CurrentInputSymbol=rshiftSym) then
    begin
         Get;
              Kind := zcBinaryShiftR; 
    end
    ;
    _Unary(Op);
    _AddExpr(Op,R);
       OutOp := MakeOp(Kind,[L,R]);
       L := OutOp; 
  end;
end;

procedure TZc._AddExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Op,L,R : TZcOp;  Kind : TZcOpKind;
begin
  _MulExpr(InOp,OutOp);
                           L := OutOp; Kind := zcNop; 
  while (CurrentInputSymbol in [minusSym, plusSym]) do
  begin
    if (CurrentInputSymbol=plusSym) then
    begin
         Get;
                 Kind := zcPlus; 
    end
    else if (CurrentInputSymbol=minusSym) then
    begin
         Get;
                 Kind := zcMinus; 
    end
    ;
    _Unary(Op);
    _MulExpr(Op,R);
            
            if (L=nil) or (R=nil) then
              ZError('Invalid syntax');
            OutOp := MakeBinary(Kind,L,R);
            L := OutOp;
         
  end;
end;

procedure TZc._MulExpr(InOp : TZcOp; var OutOp : TZcOp);
                                                    var Tmp : TZcOp; Kind : TZcOpKind; 
begin
     OutOp := InOp; Kind := zcNop; 
  while (CurrentInputSymbol in [divSym, modSym, timesSym]) do
  begin
    if (CurrentInputSymbol=timesSym) then
    begin
         Get;
                 Kind := zcMul; 
    end
    else if (CurrentInputSymbol=divSym) then
    begin
         Get;
                 Kind := zcDiv; 
    end
    else if (CurrentInputSymbol=modSym) then
    begin
         Get;
                 Kind := zcMod; 
    end
    ;
    _Unary(Tmp);
            OutOp := MakeBinary(Kind,InOp,Tmp);
            InOp := OutOp;
         
  end;
end;

procedure TZc._Primary(var OutOp : TZcOp);

var Op,ConsCall : TZcOp; S : string; V : double;
  Typ : TZcDataType;
  Cls : TZcOpClass;
  Loc : TZcOpLocalVar;

begin
                OutOp := nil; 
  if (CurrentInputSymbol=identSym) then
  begin
       Get;
                OutOp := CheckPrimary( MakeIdentifier(LexString) );  
  end
  else if (CurrentInputSymbol=_atSym) then
  begin
       _InlineComponent(OutOp);
  end
  else if InSet(CurrentInputSymbol,16) then
  begin
       _Literal(Typ);
                    
        if Typ.Kind in [zctString,zctNull] then
          OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
        else
        begin
          try
            S := LexString;
            V := ZcStrToFloat(S);
            OutOp := TZcOpLiteral.Create(Typ.Kind,V)
          except on EConvertError do
            SynError(200);
          end;
        end;
     
  end
  else if (CurrentInputSymbol=lparSym) then
  begin
       Get;
       _Expr(OutOp);
       Expect(rparSym);
  end
  else if (CurrentInputSymbol=reinterpret_underscorecastSym) then
  begin
       _ReinterpretCast(OutOp);
  end
  else if (CurrentInputSymbol=newSym) then
  begin
       Get;
       _Type(Typ);
         if Typ.Kind<>zctClass then
           ZError('new can only be used with Class-types');
         OutOp := MakeOp(zcNew,LexString);
      
       Expect(lparSym);
       if InSet(CurrentInputSymbol,6) then
       begin
         _Argument(Op);
                           OutOp.Children.Add(Op); 
         while (CurrentInputSymbol=commaSym) do
         begin
           Get;
           _Argument(Op);
                              OutOp.Children.Add(Op); 
         end;
       end;
       Expect(rparSym);
        
         //Look for constructor
         Cls := Typ.TheClass as TZcOpClass;
         Op := Cls.FindMethod( MangleFunc(OutOp.Id,OutOp.Children.Count+1) );

         if Assigned(Op) then
         begin
           //Constructor call generates: #inline { temp=new x; temp.constructor(); inlinereturn(temp) }
           Loc := MakeTemp(zctClass);
           Loc.Typ.TheClass := Cls;
           SymTab.Add(Loc.Id,Loc);
           CurrentFunction.AddLocal(Loc);

           ConsCall := MakeOp(zcMethodCall);
           ConsCall.Id := Cls.Id;
           ConsCall.Ref := Cls;
           ConsCall.Children.Add( MakeOp(zcIdentifier,Loc.Id) ); //"this"
           ConsCall.Children.AddRange(OutOp.Children); //rest of constructor arguments

           OutOp := MakeOp(zcInlineBlock);
           OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id), MakeOp(zcNew,Cls.Id)) );
           OutOp.Children.Add( ConsCall );
           OutOp.Children.Add( MakeOp(zcInlineReturn, MakeOp(zcIdentifier,Loc.Id)) );

           if not VerifyFunctionCall(ConsCall,S,CurrentFunction,Cls) then
             ZError(S);
         end else if OutOp.Children.Count>0 then
           ZError('no matching constructor found: ' + OutOp.Id);
      
  end
  else SynError(15);
  while InSet(CurrentInputSymbol,17) do
  begin
    if (CurrentInputSymbol=incSym) then
    begin
         Get;
          OutOp := MakePrePostIncDec(zcPostInc,OutOp); 
    end
    else if (CurrentInputSymbol=decSym) then
    begin
         Get;
            OutOp := MakePrePostIncDec(zcPostDec,OutOp); 
    end
    else if (CurrentInputSymbol=dotSym) then
    begin
         Get;
           IsInIdent := True; 
         Expect(identSym);
                                         

      if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
        ZError('Invalid use of "."');

      Op := MakeOp(zcSelect,LexString);
      Op.Children.Add(OutOp);

      OutOp := CheckPrimary(Op);

      IsInIdent := False;

    
    end
    else if (CurrentInputSymbol=lparSym) then
    begin
         Get;
          
           if (OutOp=nil) then
             ZError('Unexpected "("');
           Cls := nil;
           if (OutOp.Kind<>zcIdentifier) then
           begin
             Typ := OutOp.Children.First.GetDataType;
             if Typ.Kind=zctClass then
             begin
               Cls := Typ.TheClass as TZcOpClass;
               OutOp.Ref := Cls;
             end
             else
               ZError('Unexpected "("');
           end;
           if Assigned(Cls) then
             OutOp.Kind := zcMethodCall
           else
             OutOp.Kind := zcFuncCall;
         
         if InSet(CurrentInputSymbol,6) then
         begin
           _Argument(Op);
                         OutOp.Children.Add(Op); 
           while (CurrentInputSymbol=commaSym) do
           begin
             Get;
             _Argument(Op);
                               OutOp.Children.Add(Op); 
           end;
         end;
          
           if not VerifyFunctionCall(OutOp,S,CurrentFunction,Cls) then
             ZError(S);
        
         Expect(rparSym);
    end
    else if (CurrentInputSymbol=lbrackSym) then
    begin
         Get;
          
           if (OutOp=nil) or (not (OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall])) then
             ZError('Unexpected "["');
           Op := MakeArrayAccess(OutOp);
           OutOp := Op;
         
         _Expr(Op);
                    OutOp.Children.Add( MakeCompatible(Op,zctInt) ); 
         while (CurrentInputSymbol=commaSym) do
         begin
           Get;
           _Expr(Op);
                           OutOp.Children.Add( MakeCompatible(Op,zctInt) ); 
         end;
         Expect(rbrackSym);
    end
    ;
  end;
end;

procedure TZc._InvokeArgument(var OutOp : TZcOp; Ci : TZComponentInfo);

  var
    Op : TZcOp;
    Prop : TZProperty;

begin
     OutOp := nil; Op := nil; 
  Expect(identSym);
          
    Prop := Ci.GetProperties.GetByName(LexString);
    if Prop=nil then
      ZError(LexString + ' is not a property of ' + Ci.ZClassName);
    if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
      ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
    OutOp := MakeOp(zcIdentifier,LexString);
  
  Expect(colonSym);
  _Expr(Op);
     if Op=nil then
       ZError('Missing argument');
     Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
     OutOp.Children.Add(Op);
  
end;

procedure TZc._ReinterpretCast(var OutOp : TZcOp);

var
  Op : TZcOp;
  Typ : TZcDataType;

begin
  Expect(reinterpret_underscorecastSym);
  Expect(ltSym);
  _SimpleType(Typ);
  Expect(gtSym);
  Expect(lparSym);
  _Expr(Op);
  Expect(rparSym);
    
     OutOp := TZcOpReinterpretCast.Create(nil);
     OutOp.Children.Add(Op);
     (OutOp as TZcOpReinterpretCast).Typ := Typ;
  
end;

procedure TZc._InlineComponent(var OutOp : TZcOp);
 var Op : TZcOp;
     Ci : TZComponentInfo;

begin
      OutOp := nil;
      IsInInvokeArg := True;
   
  Expect(_atSym);
  Expect(identSym);
               
       Ci := ComponentManager.GetInfoFromName(LexString);
       OutOp := TZcOpInvokeComponent.Create(nil);
       OutOp.Id := LexString;
    
  Expect(lparSym);
  if (CurrentInputSymbol=identSym) then
  begin
    _InvokeArgument(Op,Ci);
                                        OutOp.Children.Add(Op); 
    while (CurrentInputSymbol=commaSym) do
    begin
      Get;
      _InvokeArgument(Op,Ci);
                                        OutOp.Children.Add(Op); 
    end;
  end;
  Expect(rparSym);
           IsInInvokeArg := False; 
end;

procedure TZc._Literal(var Typ : TZcDataType);
begin
  if (CurrentInputSymbol=intConSym) then
  begin
       Get;
            Typ.Kind :=zctInt; 
  end
  else if (CurrentInputSymbol=realConSym) then
  begin
       Get;
             Typ.Kind := zctFloat; 
  end
  else if (CurrentInputSymbol=stringConSym) then
  begin
       Get;
               Typ.Kind := zctString; 
  end
  else if (CurrentInputSymbol=nullSym) then
  begin
       Get;
              Typ.Kind := zctNull; 
  end
  else SynError(16);
end;



function TZc.TokenToString(n: Integer): String;
const TokenStrings: array[0.._NOSYMB] of String = ('EOF'
	,'intCon'	,'realCon'	,'stringCon'	,'ident'	,'"&"'
	,'"="'	,'":"'	,'","'	,'"--"'	,'"/"'
	,'"."'	,'"=="'	,'">"'	,'">="'	,'"++"'
	,'"{"'	,'"["'	,'"("'	,'"<<"'	,'"<"'
	,'"<="'	,'"-"'	,'"%"'	,'"!="'	,'"!"'
	,'"|"'	,'"+"'	,'"}"'	,'"]"'	,'")"'
	,'">>"'	,'";"'	,'"~"'	,'"*"'	,'"^"'
	,'"Material"'	,'"Sound"'	,'"Shader"'	,'"Bitmap"'	,'"Mesh"'
	,'"Camera"'	,'"Font"'	,'"Sample"'	,'"File"'	,'"Component"'
	,'"private"'	,'"void"'	,'"inline"'	,'"virtual"'	,'"override"'
	,'"class"'	,'"ref"'	,'"float"'	,'"int"'	,'"byte"'
	,'"string"'	,'"model"'	,'"xptr"'	,'"mat4"'	,'"vec2"'
	,'"vec3"'	,'"vec4"'	,'"const"'	,'"if"'	,'"else"'
	,'"switch"'	,'"while"'	,'"do"'	,'"for"'	,'"break"'
	,'"continue"'	,'"return"'	,'"+="'	,'"-="'	,'"*="'
	,'"/="'	,'"|="'	,'"<<="'	,'">>="'	,'"&="'
	,'"case"'	,'"default"'	,'"?"'	,'"||"'	,'"&&"'
	,'"reinterpret_cast"'	,'"@"'	,'"new"'	,'"null"'  ,'not');
begin
  if n in [0.._NOSYMB] then
    Result := TokenStrings[n]
  else Result := '?';
end;

function TZc.ErrorMessage(ErrorType, ErrorCode: Integer; const data: string): String;
begin
  case ErrorCode of
	1 : Result := 'invalid Zc';
	2 : Result := 'invalid GlobalModifier';
	3 : Result := 'invalid Type';
	4 : Result := 'invalid Init';
	5 : Result := 'invalid StructMember';
	6 : Result := 'invalid MemberModifier';
	7 : Result := 'invalid Statement';
	8 : Result := 'invalid Expr';
	9 : Result := 'invalid SimpleType';
	10 : Result := 'invalid EmbeddedStatement';
	11 : Result := 'invalid StatementExpr';
	12 : Result := 'invalid ForInit';
	13 : Result := 'invalid AssignOp';
	14 : Result := 'invalid SwitchLabel';
	15 : Result := 'invalid Primary';
	16 : Result := 'invalid Literal';

              
    200 : Result := 'Not a floating point value';
    201 : Result := 'Name already defined in this scope';
    202 : Result := 'Return value expected';
    203 : Result := 'Function should not return a value';
    204 : Result := 'Only function definitions are allowed here';
    205 : Result := 'Syntax not supported';

    else Result := inherited ErrorMessage(ErrorType, ErrorCode,data);
  end;
end;

(*

procedure TZc.ProcessPragmas;
begin
  case CurrentInputSymbol of
  end;

end;

*)

function TZc.Execute: Boolean;
begin
  Reinit;
  _Zc;
  Result := Successful;
end;


function TZc.CreateScanner: TBaseScanner;
begin
  Result := TZcScanner.Create(Self);
  if ZcST=nil then
  begin
    ZcST := TStartTable.Create;
    with ZcST do
    begin
	  FillRange(49, 57, 39);  FillRange(65, 90, 18);  States[95] := 18;  FillRange(97, 122, 18);
	  States[48] := 40;  States[46] := 41;  States[34] := 16;  States[38] := 57;  States[61] := 42;
	  States[58] := 19;  States[44] := 20;  States[45] := 58;  States[47] := 59;  States[62] := 60;
	  States[43] := 61;  States[123] := 25;  States[91] := 26;  States[40] := 27;  States[60] := 62;
	  States[37] := 29;  States[33] := 43;  States[124] := 63;  States[125] := 31;  States[93] := 32;
	  States[41] := 33;  States[59] := 34;  States[126] := 35;  States[42] := 64;  States[94] := 36;
	  States[63] := 53;  States[64] := 56;
    end;
    ZcLiterals := CreateLiterals(True,
	['Material','Sound','Shader','Bitmap','Mesh','Camera','Font','Sample','File','Component','private','void','inline'
		,'virtual','override','class','ref','float','int','byte','string','model','xptr','mat4','vec2','vec3','vec4','const'
		,'if','else','switch','while','do','for','break','continue','return','case','default','reinterpret_cast','new','null'
		],
	[-MaterialSym,-SoundSym,-ShaderSym,-BitmapSym,-MeshSym,-CameraSym,-FontSym,-SampleSym,-FileSym,-ComponentSym,privateSym,voidSym
		,inlineSym,virtualSym,overrideSym,classSym,refSym,floatSym,intSym,byteSym,stringSym,modelSym,xptrSym,mat_fourSym,vec_twoSym
		,vec_threeSym,vec_fourSym,constSym,ifSym,elseSym,switchSym,whileSym,doSym,forSym,breakSym,continueSym,returnSym,caseSym
		,defaultSym,reinterpret_underscorecastSym,newSym,nullSym]
     );
  end;
  with TZcScanner(Result) do
  begin
      
    noSym := _NOSYMB;
    StartState := ZcST;
    Literals := ZcLiterals;
  end;
end;


constructor TZc.Create(AOwner: TComponent);
begin
              
    ZFunctions := TObjectList.Create(False);
    Self.OnError := OnParserError;

  
  inherited;

  if Length(ZcSymSets)=0 then
  InitSymSets(ZcSymSets,[
    	{ 0} identSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, refSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 1} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lbraceSym, lparSym, minusSym, notSym, scolonSym, tildeSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, constSym, ifSym, switchSym, whileSym, doSym, forSym, breakSym, continueSym, returnSym, reinterpret_underscorecastSym, _atSym, newSym, nullSym, -1,
	{ 2} identSym, lbraceSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, privateSym, voidSym, inlineSym, classSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, constSym, -1,
	{ 3} identSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, privateSym, voidSym, inlineSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 4} identSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 5} MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 6} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lparSym, minusSym, notSym, tildeSym, reinterpret_underscorecastSym, _atSym, newSym, nullSym, -1,
	{ 7} identSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, privateSym, voidSym, inlineSym, virtualSym, overrideSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, -1,
	{ 8} privateSym, inlineSym, virtualSym, overrideSym, -1,
	{ 9} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lbraceSym, lparSym, minusSym, notSym, scolonSym, tildeSym, ifSym, switchSym, whileSym, doSym, forSym, breakSym, continueSym, returnSym, reinterpret_underscorecastSym, _atSym, newSym, nullSym, -1,
	{10} andSym, colonSym, commaSym, divSym, eqSym, gtSym, gteSym, lshiftSym, ltSym, lteSym, minusSym, modSym, neqSym, orSym, plusSym, rbraceSym, rbrackSym, rparSym, rshiftSym, scolonSym, timesSym, xorSym, _querySym, _bar_barSym, _and_andSym, -1,
	{11} assgnSym, _plus_equalSym, _minus_equalSym, _star_equalSym, _slash_equalSym, _bar_equalSym, _less_less_equalSym, _greater_greater_equalSym, _and_equalSym, -1,
	{12} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lbraceSym, lparSym, minusSym, notSym, tildeSym, reinterpret_underscorecastSym, _atSym, newSym, nullSym, -1,
	{13} intConSym, realConSym, stringConSym, identSym, decSym, incSym, lparSym, minusSym, notSym, tildeSym, MaterialSym, SoundSym, ShaderSym, BitmapSym, MeshSym, CameraSym, FontSym, SampleSym, FileSym, ComponentSym, floatSym, intSym, byteSym, stringSym, modelSym, xptrSym, mat_fourSym, vec_twoSym, vec_threeSym, vec_fourSym, reinterpret_underscorecastSym, _atSym, newSym, nullSym, -1,
	{14} decSym, incSym, minusSym, notSym, tildeSym, -1,
	{15} gtSym, gteSym, ltSym, lteSym, -1,
	{16} intConSym, realConSym, stringConSym, nullSym, -1,
	{17} decSym, dotSym, incSym, lbrackSym, lparSym
  ]); 
  SymSets := ZcSymSets;
  
end;

end.
