
Listing
-------
0 errors and 1 warnings
*****  Warning: LL1 warning in EmbeddedStatement:"else" is start & successor of deletable structure
**************************
    1  COMPILER Zc
    2  
    3  FRAME "delphi.frm"
    4  
    5  uses = (. Zc_Ops, Contnrs, uSymTab, ZClasses, Compiler, SysUtils, ZExpressions, ZApplication .)
    6  
    7  public = (.
    8      ZFunctions : TObjectList;
    9      SymTab : TSymbolTable;
   10      AllowInitializer : boolean;
   11      GlobalNames : TObjectList;
   12      ZApp : TZApplication;
   13      InitializerFunction : TZcOpFunctionUserDefined;
   14      destructor Destroy; override;
   15      procedure CheckHomograph(var sym: Integer); override;
   16      procedure ParseEvalExpression;
   17  .)
   18  private = (.
   19      IsInIdent,IsInInvokeArg : boolean;
   20      CurrentFunction : TZcOpFunctionUserDefined;
   21      procedure CleanUp;
   22      procedure ZError(const S : string);
   23      procedure AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   24      procedure OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   25      function IsConst : boolean;
   26      function IdentAndLPar : boolean;
   27      function GetInitializer : TZcOpFunctionUserDefined;
   28      function IsLocalVarDecl : boolean;
   29      function IsPointerOrDims(var PeekIndex : integer) : boolean;
   30      function IsFieldDecl : boolean;
   31      function NotFinalComma : boolean;
   32      .)
   33  precreate = (.
   34      ZFunctions := TObjectList.Create(False);
   35      Self.OnError := OnParserError;
   36  
   37  .)
   38  
   39  semErrors = (.
   40      200 : Result := 'Not a floating point value';
   41      201 : Result := 'Name already defined in this scope';
   42      202 : Result := 'Return value expected';
   43      203 : Result := 'Function should not return a value';
   44      204 : Result := 'Only function definitions are allowed here';
   45      205 : Result := 'Syntax not supported';
   46  .)
   47  
   48  implementation = (.
   49  
   50  procedure TZc.OnParserError(Sender: TObject; ErrorType,ErrorCode, line,col: Integer; const Msg, data: string);
   51  begin
   52    ZError(Msg + ' ' + Data);
   53  end;
   54  
   55  procedure TZc.CheckHomograph(var sym: Integer);
   56  begin
   57    //Only Homographs are name of component datatypes
   58    //If inside identifier "x.y.z" then let it refer to identifier instead
   59    if IsInIdent or IsInInvokeArg then
   60      sym := identSym;
   61  end;
   62  
   63  destructor TZc.Destroy;
   64  begin
   65    inherited;
   66    CleanUp;
   67  end;
   68  
   69  procedure TZc.AddSwitchLabel(SwitchOp : TZcOpSwitch; var Op: TZcOp);
   70  begin
   71    if Op=nil then
   72    begin
   73      if SwitchOp.HasDefault then
   74        ZError('Only one default statement is allowed.');
   75      SwitchOp.HasDefault := True;
   76    end else
   77      Op := MakeCompatible(Op,SwitchOp.ValueOp.GetDataType);
   78    SwitchOp.CaseOps.Last.Children.Add( Op );
   79    Op := nil;
   80  end;
   81  
   82  procedure TZc.CleanUp;
   83  begin
   84    ZFunctions.Free;
   85  end;
   86  
   87  procedure TZc.ZError(const S : string);
   88  var
   89    E : EParseError;
   90    P : TSymbolRec;
   91  begin
   92    E := EParseError.Create(S);
   93    E.Message := S;
   94    Scanner.GetPosition(P);
   95    E.Line := P.Line;
   96    E.Col := P.Col;
   97    if (E.Line<>0) or (E.Col<>0) then
   98      E.Message := E.Message + ' (line: ' + IntToStr(E.Line) + ', col: ' + IntToStr(E.Col) + ')';
   99    raise E;
  100  end;
  101  
  102  function TZc.IsConst : boolean;
  103  begin
  104    Result := (CurrentInputSymbol=constSym) or
  105      ((CurrentInputSymbol=privateSym) and (Symbols[2].Id=constSym));
  106  end;
  107  
  108  function TZc.IdentAndLPar : boolean;
  109  begin
  110    Result := (CurrentInputSymbol=identSym) and (Symbols[2].Id=lparSym);
  111  end;
  112  
  113  // skip: { "[" { "," } "]" | "*" }
  114  // !!! Proceeds from current peek position !!!
  115  function TZc.IsPointerOrDims(var PeekIndex : integer) : boolean;
  116  begin
  117    if Symbols[PeekIndex].Id=lbracksym then
  118    begin
  119      repeat
  120        Inc(PeekIndex);
  121        if PeekIndex>=Self.LookAheadCount then
  122          Exit(True);
  123      until Symbols[PeekIndex].Id=rbrackSym;
  124      Inc(PeekIndex);
  125    end;
  126    Result := True;
  127  
  128  (*
  129    for (;;) {
  130      if (pt.kind == _lbrack) {
  131        do pt = scanner.Peek();
  132        while (pt.kind == _comma);
  133        if (pt.kind != _rbrack) return false;
  134      } else if (pt.kind != _times) break;
  135      pt = scanner.Peek();
  136    }
  137    return true;
  138  *)
  139  end;
  140  
  141  function TZc.IsLocalVarDecl : boolean;
  142  var
  143    PeekIndex : integer;
  144  begin
  145    PeekIndex := 1;
  146  
  147  	if (CurrentInputSymbol in [floatSym,intSym,byteSym,stringSym,modelSym,xptrSym,
  148      mat_fourSym,vec_twoSym,vec_threeSym,vec_fourSym,
  149    	MaterialSym,SoundSym,ShaderSym,BitmapSym,MeshSym,
  150    	CameraSym,FontSym,SampleSym,FileSym,ComponentSym
  151      ]) then
  152      Inc(PeekIndex)
  153    else if (CurrentInputSymbol=identSym) then
  154      Inc(PeekIndex)
  155    else
  156      Exit(False);
  157  
  158    Result := IsPointerOrDims(PeekIndex) and (Symbols[PeekIndex].Id=identSym);
  159  
  160  (*  string ignore;
  161    Token pt = la;
  162    scanner.ResetPeek();
  163  
  164    if (typeKW[la.kind] || la.kind == _void) {
  165      pt = scanner.Peek();
  166      if (la.kind == _void && pt.kind != _times) { return false; }
  167    } else if (la.kind == _ident && !IsQualident(ref pt, out ignore)) {
  168      return false;
  169    }
  170  
  171    return IsPointerOrDims(ref pt) && pt.kind == _ident;*)
  172  
  173  end;
  174  
  175  function TZc.IsFieldDecl : boolean;
  176  // ident ("," | "=" | ";")
  177  begin
  178    Result := (CurrentInputSymbol=identSym) and
  179      (Symbols[2].Id in [commaSym,assgnSym,scolonSym]);
  180  
  181  (*
  182  bool IsFieldDecl () {
  183    int peek = Peek(1).kind;
  184    return la.kind == _ident &&
  185           (peek == _comma || peek == _assgn || peek == _scolon);
  186  }
  187  *)
  188  end;
  189  
  190  function TZc.NotFinalComma : boolean;
  191  begin
  192    Result := (CurrentInputSymbol=commaSym) and
  193      (not (Symbols[2].Id in [rbraceSym,rbrackSym]));
  194  
  195  (*
  196  /* True, if the comma is not a trailing one, *
  197   * like the last one in: a, b, c,            */
  198  bool NotFinalComma () {
  199    int peek = Peek(1).kind;
  200    return la.kind == _comma && peek != _rbrace && peek != _rbrack;
  201  *)
  202  end;
  203  
  204  function TZc.GetInitializer : TZcOpFunctionUserDefined;
  205  begin
  206    if not Self.AllowInitializer then
  207      ZError('Initializers only allowed in ZLibrary components located in App.OnLoaded');
  208    if not Assigned(InitializerFunction) then
  209    begin
  210      Self.InitializerFunction := TZcOpFunctionUserDefined.Create(nil);
  211      Self.ZFunctions.Insert(0,Self.InitializerFunction);
  212    end;
  213    Result := Self.InitializerFunction;
  214  end;
  215  
  216  procedure TZc.ParseEvalExpression;
  217  var
  218    OutOp : TZcOp;
  219    Typ : TZcDataType;
  220    Func : TZcOpFunctionUserDefined;
  221  begin
  222    Reinit;
  223    OutOp := nil;
  224    _Expr(OutOp);
  225    Typ := OutOp.GetDataType;
  226  
  227    Func := TZcOpFunctionUserDefined.Create(nil);
  228    Func.ReturnType := Typ;
  229    Self.CurrentFunction := Func;
  230  
  231    if Typ.Kind<>zctVoid then
  232    begin
  233      OutOp := MakeOp(zcReturn,[OutOp]);
  234    end;
  235    Func.Statements.Add(OutOp);
  236    Self.ZFunctions.Add(Func);
  237  end;
  238  .)
  239  
  240  END
  241  
  242  
  243  CHARACTERS
  244  
  245          tab                = CHR(9). /*  9 = tabulator */
  246          eol                = CHR(10). /* 10 = line feed */
  247          cr                 = CHR(13). /* 13 = carriage return */
  248          newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */
  249  
  250          letter             = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  251          digit              = "0123456789".
  252          hexDigit           = digit + "ABCDEFabcdef".
  253          notDigit           = ANY - digit.
  254  
  255          char               = ANY - "'" - '\' - newLine.
  256          verbatimStringChar = ANY - '"'.
  257          regularStringChar  = ANY - '"' - '\' - newLine.
  258          notNewLine         = ANY - newLine .
  259  
  260  
  261  TOKENS
  262  
  263    /*--------------------------------------------------------------------------------*/
  264          intCon =
  265                  ( digit {digit}
  266                  | ("0x" | "0X") hexDigit {hexDigit}
  267                  )
  268                  /* ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"] */
  269                  .
  270    /*--------------------------------------------------------------------------------*/
  271          realCon =
  272                  "." digit {digit}
  273                  [("e" | "E") ["+" | "-"] digit {digit}]
  274                  ["F" | "f" | "D" | "d" | "M" | "m"]
  275          | digit {digit}
  276                  ( "." digit {digit}
  277                          [("e" | "E" ) ["+" | "-"] digit {digit} ]
  278                          ["F" | "f" | "D" | "d" | "M" | "m"]
  279                  | ("e" | "E") ["+" | "-"] digit {digit}
  280                          ["F" | "f" | "D" | "d" | "M" | "m"]
  281                  | "F" | "f" | "D" | "d" | "M" | "m"
  282                  ).
  283    /*--------------------------------------------------------------------------------*/
  284          stringCon =
  285                  '"'    { regularStringChar
  286            | "\'" | '\"' | "\\" | "\n"
  287            }
  288                  '"'.
  289  
  290          ident = letter { letter | digit }.
  291  
  292  
  293          /*----- operators and special characters needed in LL(1) resolvers --------------*/
  294          and    = "&".
  295          assgn  = "=".
  296          colon  = ":".
  297          comma  = ",".
  298          dec    = "--".
  299          div    = "/".
  300          dot    = ".".
  301          eq     = "==".
  302          gt     = ">".
  303          gte    = ">=".
  304          inc    = "++".
  305          lbrace = "{".
  306          lbrack = "[".
  307          lpar   = "(".
  308          lshift = "<<".
  309          lt     = "<".
  310          lte    = "<=".
  311          minus  = "-".
  312          mod    = "%".
  313          neq    = "!=".
  314          not    = "!".
  315          or     = "|".
  316          plus   = "+".
  317          rbrace = "}".
  318          rbrack = "]".
  319          rpar   = ")".
  320          rshift = ">>".
  321          scolon = ";".
  322          tilde  = "~".
  323          times  = "*".
  324          xor    = "^".
  325  
  326  
  327  
  328  COMMENTS FROM "/*" TO "*/"
  329  COMMENTS FROM "//" TO eol
  330  
  331  IGNORE eol + cr + tab
  332  
  333  HOMOGRAPHS
  334    "Material"
  335    "Sound"
  336    "Shader" 
  337    "Bitmap" 
  338    "Mesh"
  339    "Camera"
  340    "Font"
  341    "Sample"
  342    "File"
  343    "Component"
  344  
  345  PRODUCTIONS
  346  
  347  /*------------------------------------------------------------------------*
  348   *--------------------------- Declarations -------------------------------*
  349   *------------------------------------------------------------------------*/
  350  
  351  ZcFuncRest<Typ : TZcDataType; const Name : string; IsPrivate,IsInline : boolean; Cls : TZcOpClass>
  352  (.
  353  var
  354    Func : TZcOpFunctionUserDefined;
  355    Arg : TZcOpArgumentVar;
  356  .)
  357  =
  358       (.
  359          if (not Assigned(Cls)) or (not SameText(Name,Cls.Id)) then
  360          begin //Check for dup except if name of class constructor
  361            if SymTab.Contains(Name) then
  362              ZError('Name already defined: ' + Name);
  363          end;
  364  
  365          if IsPrivate then
  366            Func := TZcOpFunctionUserDefined.Create(nil)
  367          else
  368            Func := TZcOpFunctionUserDefined.Create(GlobalNames);
  369          Func.Id := Name;
  370          Func.ReturnType := Typ;
  371          Func.IsInline := IsInline;
  372          Func.IsPrivate := IsPrivate;
  373          Self.CurrentFunction := Func;
  374          SymTab.PushScope;
  375          try
  376  
  377            if Assigned(Cls) then
  378            begin //Add implicit "this" argument to method definition
  379              Arg := TZcOpArgumentVar.Create(nil);
  380              Arg.Id := 'this';
  381              Arg.Typ.Kind := zctClass;
  382              Arg.Typ.TheClass := Cls;
  383              Func.MemberOf := Cls;
  384              Func.AddArgument(Arg);
  385              SymTab.Add(Arg.Id,Arg);
  386            end;
  387  
  388       .)
  389      [ FormalParams ] ")"
  390        (.
  391          Func.MangledName := MangleFunc(Name,CurrentFunction.Arguments.Count);
  392          if SymTab.Contains(Func.MangledName) then
  393            ZError('Name already defined: ' + Name);
  394          if Assigned(Cls) then
  395          begin
  396            Cls.Methods.Add(Func);
  397            SymTab.AddPrevious(Func.MangledName,Func);
  398          end
  399          else
  400          begin
  401            if IsPrivate then
  402              SymTab.AddPrevious(Func.MangledName,Func)
  403            else
  404              SymTab.AddPrevious(Func.MangledName,Func,2);
  405            ZFunctions.Add(Func);
  406          end;
  407        .)
  408      "{" ZcFuncBody "}"
  409          (.
  410            finally
  411              SymTab.PopScope;
  412            end;
  413          .)
  414  .
  415  
  416  
  417  Zc (. var
  418          Typ : TZcDataType;
  419          Name : string;
  420          IsPrivate,IsInline : boolean;
  421          Op : TZcOp;
  422      .)
  423  =
  424    {
  425      IF(. IsConst .)
  426        (. IsPrivate := False; .)
  427        [ "private" (. IsPrivate:= True; .) ]
  428        ConstantDeclarationList<IsPrivate>
  429      |
  430        (. IsPrivate := False; .)
  431      /*  [ "private" (. IsPrivate:= True; .) ] */
  432        TypeDecl<IsPrivate>
  433      |
  434        (. IsPrivate := False; IsInline := False; .)
  435        [ "private" (. IsPrivate:= True; .) ]
  436        [ "inline" (. IsInline:= True; .) ]
  437        ("void" (. Typ.Kind := zctVoid; .) | Type<Typ> ) ident (. Name := LexString; .)
  438         /* Need to separate between global variable and method declarations */
  439         (
  440           "(" ZcFuncRest<Typ,Name,IsPrivate,IsInline,nil>
  441           | GlobalVarDecl<Typ,Name,IsPrivate> ";"
  442         )
  443      | /* Library initialization block */
  444        (. CurrentFunction := GetInitializer; .)
  445        Block<Op>
  446        (. GetInitializer.Statements.Add(Op); CurrentFunction := nil; .)
  447    }
  448  
  449  .
  450  
  451  /*------------------------------------------------------------------------*/
  452  Field<Typ : TZcDataType; Cls : TZcOpClass; IsPrivate : boolean>
  453  (.
  454  var
  455    Fld : TZcOpField;
  456    Op,InitOp : TZcOp;
  457  .)
  458  = ident
  459    (.
  460       //todo: check duplicate name in class
  461       Fld := TZcOpField.Create(nil);
  462       Fld.Id := LexString;
  463       Fld.Typ := Typ;
  464       Fld.ByteOffset := Cls.RuntimeClass.SizeInBytes;
  465       Fld.IsPrivate := IsPrivate;
  466       Fld.MemberOf := Cls;
  467       if Fld.Typ.Kind in ManagedTypes then
  468       begin //Managed field
  469         Inc(Cls.RuntimeClass.ManagedFields.Size,4);
  470         ReallocMem(Cls.RuntimeClass.ManagedFields.Data,Cls.RuntimeClass.ManagedFields.Size);
  471         PInteger( pointer(IntPtr(Cls.RuntimeClass.ManagedFields.Data)+Cls.RuntimeClass.ManagedFields.Size-4) )^ := Fld.ByteOffset;
  472       end;
  473  
  474       //todo: field align
  475       Inc(Cls.RuntimeClass.SizeInBytes, GetZcTypeSize(Fld.Typ.Kind) );
  476       Cls.Fields.Add(Fld);
  477  
  478       SymTab.AddPrevious(Fld.Id,Fld);
  479  
  480       InitOp := nil;
  481       CurrentFunction := Cls.Initializer; //Needed so that any temporary locals in init are added to the correct function
  482    .)
  483  
  484    [ "=" Init<InitOp> ]
  485  
  486    (.
  487       Op := nil;
  488       MakeVarInitializer(Fld,InitOp,Op);
  489       if Assigned(Op) then
  490         Cls.Initializer.Statements.Add(Op);
  491       CurrentFunction := nil;
  492    .)
  493  .
  494  /*------------------------------------------------------------------------*/
  495  StructMember<Cls : TZcOpClass; IsPrivate,IsInline : boolean> (.
  496  var
  497    Typ : TZcDataType;
  498    Name : string;
  499  .)
  500  =
  501  (. Typ.Kind := zctVoid; .)
  502  
  503    /*--- void method (procedure) declaration: */
  504    "void" ident (. Name := LexString; .)
  505            (
  506              "(" ZcFuncRest<Typ,Name,IsPrivate,IsInline,Cls>
  507            )
  508  
  509  /*--- constructor or static constructor declaration: */
  510  |
  511    IF (. IdentAndLPar .)
  512    ident (.
  513       Name := LexString;
  514       if not SameText(Name,Cls.Id) then
  515         ZError('Constructor must have same name as class: ' + Name);
  516       .)
  517       "(" ZcFuncRest<Typ,Name,False,IsInline,Cls>
  518  |
  519  
  520  Type<Typ>
  521    (
  522          /*--- field declaration: */
  523          IF (. IsFieldDecl .)
  524            (.
  525              if IsInline then
  526                ZError('Fields cannot be marked with inline' + LexString);
  527              SymTab.PushScope;
  528              try
  529                //Add "this" to scope
  530                SymTab.Add(Cls.Initializer.Arguments.First.Id, Cls.Initializer.Arguments.First);
  531            .)
  532            Field<Typ,Cls,IsPrivate> {"," Field<Typ,Cls,IsPrivate>} ";"
  533            (.
  534              finally
  535                SymTab.PopScope;
  536              end;
  537            .)
  538  
  539          | ident  (. Name := LexString; .)
  540            ( /*--- "not void" method (function) declaration: */
  541              "(" ZcFuncRest<Typ,Name,IsPrivate,IsInline,Cls>
  542            )
  543  
  544    )
  545  .
  546  
  547  /*------------------------------------------------------------------------*/
  548  ClassMember<Cls : TZcOpClass; IsPrivate,IsInline : boolean>
  549  = StructMember<Cls,IsPrivate,IsInline>
  550  /* | "~" ident "(" ")" (Block | ";") */
  551  .
  552  
  553  /*------------------------------------------------------------------------*/
  554  ClassBody<Cls : TZcOpClass>
  555  (.
  556  var
  557    IsPrivate,IsInline : boolean;
  558  .)
  559  = "{" (. try
  560             SymTab.PushScope;
  561        .)
  562        {
  563          (. IsPrivate := False; IsInline := False; .)
  564          [ "private" (. IsPrivate:= True; .) ]
  565          [ "inline" (. IsInline:= True; .) ]
  566          ClassMember<Cls,IsPrivate,IsInline>
  567        }
  568    "}" (.
  569           finally
  570             SymTab.PopScope;
  571           end;
  572        .)
  573  .
  574  
  575  /*------------------------------------------------------------------------*/
  576  TypeDecl<IsPrivate : boolean>
  577  (.
  578  var
  579    Cls : TZcOpClass;
  580  .)
  581  =
  582    "class" ident
  583      (.
  584        if SymTab.Contains(LexString) then
  585          ZError('Name already defined: ' + LexString);
  586        Cls := TZcOpClass.Create(GlobalNames);
  587        Cls.Id := LexString;
  588  
  589        Cls.RuntimeClass := TUserClass.Create(Self.ZApp.UserClasses);
  590        CompilerContext.CurrentClass := Cls;
  591  
  592        SymTab.AddPrevious(Cls.Id,Cls);
  593      .)
  594      ClassBody<Cls> [";"]
  595      (.
  596        ZFunctions.Add(Cls);
  597        CompilerContext.CurrentClass := nil;
  598      .)
  599  /*|
  600    ( "struct" ident [Base] StructBody  [";"]
  601    )*/
  602  .
  603  
  604  /*------------------------------------------------------------------------*/
  605  
  606  ZcFuncBody (. var Op : TZcOp; .)
  607  =  {  (. Op:=nil; .)
  608        Statement<Op>
  609        (. if Op<>nil then
  610             CurrentFunction.Statements.Add(Op);
  611           Op := nil;
  612        .)
  613     }
  614  .
  615  
  616  /*------------------------------------------------------------------------*/
  617  FormalParams
  618  = ( Par ["," FormalParams] )
  619  .
  620  /*------------------------------------------------------------------------*/
  621  Par (.
  622  var
  623    Typ : TZcDataType;
  624    Arg : TZcOpArgumentVar;
  625    IsPtr : boolean;
  626  .)
  627  =  (. IsPtr := False; .)
  628    ["ref" (. IsPtr := True; .) ]
  629    Type<Typ> ident
  630       (.
  631          Typ.IsPointer := IsPtr;
  632          if SymTab.ScopeContains(LexString) then
  633            SynError(201)
  634          else
  635          begin
  636            Arg := TZcOpArgumentVar.Create(nil);
  637            Arg.Id := LexString;
  638            Arg.Typ := Typ;
  639            CurrentFunction.AddArgument(Arg);
  640            SymTab.Add(Arg.Id,Arg);
  641          end;
  642       .)
  643  .
  644  /*------------------------------------------------------------------------*/
  645  
  646  LocalVarDecl<var OutOp : TZcOp> (. var Typ : TZcDataType; .)
  647  = (. OutOp := nil; .)
  648    Type<Typ> LocalVar<Typ,OutOp> {"," LocalVar<Typ,OutOp>}
  649  .
  650  
  651  /*------------------------------------------------------------------------*/
  652  
  653  LocalVar<Typ : TZcDataType; var OutOp : TZcOp>
  654  (.
  655  var
  656    Loc : TZcOpLocalVar;
  657    InitOp : TZcOp;
  658  .)
  659  = ident
  660       (.
  661          if SymTab.ScopeContains(LexString) then
  662            ZError('Name already defined: ' + LexString);
  663  
  664          Loc := TZcOpLocalVar.Create(nil);
  665          Loc.Id := LexString;
  666          Loc.Typ := Typ;
  667       .)
  668       [ "=" Init<InitOp> (. Loc.InitExpression:=InitOp; .) ]
  669       (.
  670          SymTab.Add(Loc.Id,Loc);
  671          CurrentFunction.AddLocal(Loc);
  672  
  673          MakeVarInitializer(Loc,Loc.InitExpression,OutOp);
  674       .)
  675  .
  676  
  677  /*------------------------------------------------------------------------*/
  678  
  679  GlobalVarRest<Typ : TZcDataType; const Name : string; IsPrivate : boolean>
  680  (.
  681  var
  682    V : TDefineVariableBase;
  683    Glob : TZcOpGlobalVar;
  684    InitOp : TZcOp;
  685  .)
  686  =
  687       (.
  688          if SymTab.ScopeContains(Name) then
  689            ZError('Name already defined: ' + Name);
  690  
  691          V := nil;
  692          if not (Typ.Kind in [zctArray,zctMat4,zctVec2,zctVec3,zctVec4]) then
  693          begin  //Stored in global area
  694            if IsPrivate then
  695              Glob := TZcOpGlobalVar.Create(nil)
  696            else
  697              Glob := TZcOpGlobalVar.Create(GlobalNames);
  698            Glob.Lib := CompilerContext.ThisC as TZLibrary;
  699            Glob.Offset := Glob.Lib.GlobalAreaSize;
  700            Glob.Id := Name;
  701            Glob.Typ := Typ;
  702  
  703            Glob.Lib.AddGlobalVar(Typ);
  704  
  705            if IsPrivate then
  706              SymTab.Add(Name,Glob)
  707            else
  708              SymTab.AddPrevious(Name,Glob);
  709          end
  710          else if Typ.Kind=zctArray then
  711          begin
  712            //todo: store arrays in global area too, need to generate initialization code
  713            TDefineArray(Typ.TheArray)._ZApp := Self.ZApp; //must have zapp set to clone
  714            V := TDefineArray(Typ.TheArray).Clone as TDefineVariableBase;
  715            V._ReferenceClassId := Typ.ReferenceClassId;
  716            V._TheClass := Typ.TheClass;
  717            Self.ZApp.GlobalVariables.AddComponent(V);
  718          end
  719          else
  720          begin //zctMat4,zctVec2,zctVec3,zctVec4
  721            V := TDefineVariable.Create(Self.ZApp.GlobalVariables);
  722            V._Type := Typ.Kind;
  723            V._ReferenceClassId := Typ.ReferenceClassId;
  724          end;
  725  
  726          if Assigned(V) then
  727          begin
  728            V.SetString('Name', AnsiString(Name));
  729            V.DesignerReset; //Needed to init managed variables
  730            if IsPrivate then
  731              SymTab.Add(Name,V)
  732            else
  733              SymTab.AddPrevious(Name,V);
  734          end;
  735       .)
  736       [ "=" Init<InitOp> (.
  737         //todo: array initializer of global arrays
  738         GetInitializer.Statements.Add( MakeAssign(atAssign, CheckPrimary( MakeIdentifier(Name) ),InitOp) );
  739         .)
  740       ]
  741  .
  742  
  743  
  744  GlobalVar<Typ : TZcDataType; IsPrivate : boolean>
  745  =
  746    ident GlobalVarRest<Typ,LexString,IsPrivate>
  747  .
  748  
  749  GlobalVarDecl<Typ : TZcDataType; const Name : string; IsPrivate : boolean>
  750  = GlobalVarRest<Typ,Name,IsPrivate> {"," GlobalVar<Typ,IsPrivate>}
  751  .
  752  
  753  /*------------------------------------------------------------------------*/
  754  
  755  Init<var OutOp : TZcOp>
  756  = Expr<OutOp> | ArrayInit<OutOp>
  757  .
  758  
  759  /*------------------------------------------------------------------------*/
  760  ArrayInit<var OutOp : TZcOp>
  761  (.
  762  var
  763    Op : TZcOp;
  764  .)
  765  = "{" (. OutOp := MakeOp(zcBlock); .)
  766    [Init<Op> (. OutOp.Children.Add(Op); .)
  767      {IF (. NotFinalComma .) "," Init<Op> (. OutOp.Children.Add(Op); .)
  768      } [","] ] "}"
  769  .
  770  
  771  
  772  /*------------------------------------------------------------------------*/
  773  Argument<var OutOp : TZcOp>
  774  = /* ["ref" | "out"] */
  775    (. OutOp := nil; .)
  776    Expr<OutOp>
  777    (. if OutOp=nil then ZError('Missing argument'); .)
  778  .
  779  
  780  /*------------------------------------------------------------------------*
  781   *-------------------------------- Types ---------------------------------*
  782   *------------------------------------------------------------------------*/
  783  
  784  ClassType<var Typ : TZcDataType>
  785  (.
  786  var
  787    O : TObject;
  788  .)
  789  = ident
  790      (.
  791         O := SymTab.Lookup(LexString);
  792         if (O=nil) or (not (O is TZcOpClass)) then
  793           ZError('Unknown type: ' + LexString);
  794         Typ.Kind := zctClass;
  795         Typ.TheClass := O;
  796      .)
  797  .
  798  
  799  Type<var Typ : TZcDataType>
  800  (.
  801    var
  802      A : TDefineArray;
  803      SizeOp : TZcOp;
  804      I : integer;
  805  .)
  806  =  (. FillChar(Typ,SizeOf(Typ),0); .)
  807    (
  808      SimpleType<Typ>
  809      | ClassType<Typ>
  810    )
  811    {
  812      (
  813        "["       (.
  814                     A := TDefineArray.Create(nil);
  815                     GlobalNames.Add(A);
  816                     A._Type := Typ.Kind;
  817                     Typ.Kind := zctArray;
  818                     Typ.TheArray := A;
  819                  .)
  820  
  821           [ Expr<SizeOp> (.
  822              SizeOp := SizeOp.Optimize;
  823              if SizeOp.Kind<>zcConstLiteral then
  824                ZError('Array size must be a constant expression');
  825              A.SizeDim1 := Trunc( (SizeOp as TZcOpLiteral).Value );
  826                           .)
  827           ]
  828  
  829           { ","  (. if A.Dimensions=High(TArrayDimensions) then ZError('Too many array dimensions'); Inc(A.Dimensions); .)
  830             [ Expr<SizeOp> (.
  831                  SizeOp := SizeOp.Optimize;
  832                  if SizeOp.Kind<>zcConstLiteral then
  833                    ZError('Array size must be a constant expression');
  834                 I := Trunc( (SizeOp as TZcOpLiteral).Value );
  835                 if (A.Dimensions=dadTwo) then A.SizeDim2 := I else A.SizeDim3 := I;
  836             .) ]
  837           }
  838         "]"
  839      )
  840    }
  841  .
  842  
  843  /*------------------------------------------------------------------------*/
  844  
  845  SimpleType<var Typ : TZcDataType>
  846  (.
  847    var
  848      A : TDefineArray;
  849  .)
  850  /* = IntType | "float" | "double" | "decimal" | "bool" */
  851  = "float" (. Typ.Kind := zctFloat; .)
  852    | "int" (. Typ.Kind := zctInt; .)
  853    | "byte" (. Typ.Kind := zctByte; .)
  854    | "string" (. Typ.Kind := zctString; .)
  855    | "model" (. Typ.Kind := zctModel; .)
  856    | "xptr" (. Typ.Kind := zctXptr; .)
  857  
  858    | "mat4" (.
  859       A := Prototypes.Mat4Array;
  860       Typ.Kind := zctMat4;
  861       Typ.TheArray := A;
  862      .)
  863    | "vec2" (.
  864       A := Prototypes.Vec2Array;
  865       Typ.Kind := zctVec2;
  866       Typ.TheArray := A;
  867    .)
  868    | "vec3" (.
  869       A := Prototypes.Vec3Array;
  870       Typ.Kind := zctVec3;
  871       Typ.TheArray := A;
  872    .)
  873    | "vec4" (.
  874       A := Prototypes.Vec4Array;
  875       Typ.Kind := zctVec4;
  876       Typ.TheArray := A;
  877    .)
  878  
  879    /* Changes below also must be made in homographs-section */
  880    | "Material" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MaterialClassId; .)
  881    | "Sound" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SoundClassId; .)
  882    | "Shader" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ShaderClassId; .)
  883    | "Bitmap" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZBitmapClassId; .)
  884    | "Mesh" (. Typ.Kind := zctReference; Typ.ReferenceClassId := MeshClassId; .)
  885    | "Camera" (. Typ.Kind := zctReference; Typ.ReferenceClassId := CameraClassId; .)
  886    | "Font" (. Typ.Kind := zctReference; Typ.ReferenceClassId := FontClassId; .)
  887    | "Sample" (. Typ.Kind := zctReference; Typ.ReferenceClassId := SampleClassId; .)
  888    | "File" (. Typ.Kind := zctReference; Typ.ReferenceClassId := ZFileClassId; .)
  889  
  890    | "Component" (. Typ.Kind := zctReference; Typ.ReferenceClassId := AnyComponentClassId; .)
  891  .
  892  
  893  /*------------------------------------------------------------------------*/
  894  
  895  /* IntType
  896  = "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
  897  . */
  898  
  899  
  900  ConstantDeclarationList<IsPrivate : boolean>
  901  (.
  902  var
  903    Typ : TZcDataType;
  904  .)
  905  = "const" Type<Typ> ConstantDeclaration<Typ,IsPrivate> {"," ConstantDeclaration<Typ,IsPrivate> }
  906    ";"
  907  .
  908  
  909  ConstantDeclaration<var Typ : TZcDataType; IsPrivate : boolean>
  910  (.
  911  var
  912    Cns : TDefineConstant;
  913    Op : TZcOp;
  914    Lit : TZcOpLiteral;
  915    CnsName : string;
  916  .)
  917  =
  918  ident (. CnsName := LexString; .) "=" Expr<Op>
  919    (.
  920     if not (Typ.Kind in [zctByte,zctInt,zctFloat,zctString]) then
  921       ZError('Only byte, int, float and string constants are allowed');
  922  
  923     Op := Op.Optimize;
  924     if not (Op is TZcOpLiteral) then
  925       ZError('Constant expression expected: ' + Op.ToString);
  926  
  927     Lit := Op as TZcOpLiteral;
  928  
  929     if (Lit.Typ.Kind<>Typ.Kind)
  930       and not ((Typ.Kind=zctByte) and (Lit.Typ.Kind=zctInt))
  931       and not ((Typ.Kind=zctInt) and (Lit.Typ.Kind=zctFloat))
  932       then
  933       ZError('Constant expression is not of the expected type: ' + Op.ToString);
  934  
  935     Cns := TDefineConstant.Create(nil);
  936     Cns.SetString('Name',AnsiString(CnsName));
  937     GlobalNames.Add(Cns);
  938  
  939     case Typ.Kind of
  940       zctByte:
  941         begin
  942           Cns._Type := zctByte;
  943           Cns.ByteValue := Round(Lit.Value);
  944         end;
  945       zctInt:
  946         begin
  947           Cns._Type := zctInt;
  948           Cns.IntValue := Round(Lit.Value);
  949         end;
  950       zctFloat:
  951         begin
  952           Cns._Type := zctFloat;
  953           Cns.Value := Lit.Value;
  954         end;
  955       zctString:
  956         begin
  957           Cns._Type := zctString;
  958           Cns.SetString('StringValue',AnsiString(Lit.StringValue));
  959         end;
  960       else
  961         ZError('Wrong type of constant expression: ' + GetZcTypeName(Typ));
  962     end;
  963     if IsPrivate then
  964       SymTab.Add(CnsName,Cns)
  965     else
  966       SymTab.AddPrevious(CnsName,Cns)
  967    .)
  968  /* {"," ident "=" Expr<Op>} */
  969  .
  970  
  971  /*------------------------------------------------------------------------*
  972   *------------------------------ Statements ------------------------------*
  973   *------------------------------------------------------------------------*/
  974  
  975  Statement<var OutOp : TZcOp>
  976  = (. OutOp := nil; .)
  977  
  978  ConstantDeclarationList<false>
  979  
  980  | IF (. IsLocalVarDecl .)
  981      LocalVarDecl<OutOp> ";"
  982  
  983  | EmbeddedStatement<OutOp>
  984    /* LL(1) confict between LocalVarDecl and StatementExpr: *
  985     * ident {"." ident} { "[" ...                           */
  986  .
  987  
  988  /*------------------------------------------------------------------------*/
  989  EmbeddedStatement<var OutOp : TZcOp>
  990    (. var
  991         SwitchValueOp,Op,IfOp,IfBody,ElseOp : TZcOp;
  992         ForInitOp,ForCondOp,ForIncOp,ForBodyOp : TZcOp;
  993         WhileCondOp,WhileBodyOp : TZcOp;
  994         SwitchOp : TZcOpSwitch;
  995         Loc : TZcOpLocalVar;
  996    .)
  997  = Block<OutOp>
  998  | ";"   (. OutOp := MakeOp(zcNop); .)
  999  | StatementExpr<OutOp> ";"
 1000  | "if" (. ElseOp := nil; .)
 1001    "(" Expr<IfOp> ")" EmbeddedStatement<IfBody> ["else" EmbeddedStatement<ElseOp>]
 1002          (. OutOp := MakeOp(zcIf,[IfOp,IfBody,ElseOp]); .)
 1003   | "switch" "(" Expr<SwitchValueOp> ")"
 1004        (.
 1005           OutOp := MakeOp(zcBlock);
 1006  
 1007           SwitchOp := TZcOpSwitch.Create(nil);
 1008  
 1009           if (SwitchValueOp.Ref is TZcOpVariableBase) or (SwitchValueOp.Kind=zcConstLiteral) then
 1010             SwitchOp.ValueOp := SwitchValueOp
 1011           else
 1012           begin
 1013             Loc := MakeTemp(SwitchValueOp.GetDataType.Kind);
 1014             SymTab.Add(Loc.Id,Loc);
 1015             CurrentFunction.AddLocal(Loc);
 1016             OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id),SwitchValueOp) );
 1017             SwitchOp.ValueOp := MakeIdentifier(Loc.Id);
 1018           end;
 1019  
 1020           OutOp.Children.Add(SwitchOp);
 1021        .)
 1022     "{" {
 1023       (. SwitchOp.CaseOps.Add( MakeOp(zcNop) ); SwitchOp.StatementsOps.Add( MakeOp(zcNop) ); .)
 1024       SwitchSection<SwitchOp>
 1025     } "}"
 1026   | "while"
 1027       (. try
 1028           SymTab.PushScope;
 1029           CurrentFunction.PushScope;
 1030           WhileCondOp := nil; WhileBodyOp := nil; .)
 1031     "(" Expr<WhileCondOp> ")" EmbeddedStatement<WhileBodyOp>
 1032     (.
 1033           OutOp := MakeOp(zcWhile,[WhileCondOp,WhileBodyOp]);
 1034         finally
 1035           SymTab.PopScope;
 1036           CurrentFunction.PopScope;
 1037         end;
 1038     .)
 1039  
 1040   /* | "do" EmbeddedStatement<Op> "while" "(" Expr<Op> ")" ";" */
 1041   | "do"
 1042       (. try
 1043           SymTab.PushScope;
 1044           CurrentFunction.PushScope;
 1045           WhileCondOp := nil; WhileBodyOp := nil; .)
 1046     EmbeddedStatement<WhileBodyOp>
 1047     "while" "(" Expr<WhileCondOp> ")" ";"
 1048     (.
 1049           OutOp := MakeOp(zcDoWhile,[WhileCondOp,WhileBodyOp]);
 1050         finally
 1051           SymTab.PopScope;
 1052           CurrentFunction.PopScope;
 1053         end;
 1054     .)
 1055  
 1056   | "for"
 1057      (. try
 1058           SymTab.PushScope;
 1059           CurrentFunction.PushScope;
 1060           ForInitOp :=nil; ForCondOp := nil; ForIncOp := nil; .)
 1061     "(" [ForInit<ForInitOp>] ";" [Expr<ForCondOp>] ";" [ForInc<ForIncOp>] ")" EmbeddedStatement<ForBodyOp>
 1062     (.
 1063           OutOp := MakeOp(zcForLoop,[ForInitOp,ForCondOp,ForIncOp,ForBodyOp]);
 1064         finally
 1065           SymTab.PopScope;
 1066           CurrentFunction.PopScope;
 1067         end;
 1068     .)
 1069  /* | "foreach" "(" Type ident "in" Expr<Op> ")" EmbeddedStatement<Op> */
 1070   | "break" ";"    (. OutOp := MakeOp(zcBreak); .)
 1071   | "continue" ";" (. OutOp := MakeOp(zcContinue); .)
 1072   | (. Op := nil; .) "return" [ Expr<Op> ] ";"
 1073      (.
 1074          if (Op=nil) then
 1075          begin
 1076            if CurrentFunction.ReturnType.Kind<>zctVoid then
 1077              SynError(202)
 1078            else
 1079              OutOp := MakeOp(zcReturn);
 1080          end else
 1081          begin
 1082            if CurrentFunction.ReturnType.Kind=zctVoid then
 1083              SynError(203)
 1084            else
 1085              OutOp := MakeOp(zcReturn,[ MakeCompatible(Op,CurrentFunction.ReturnType) ]);
 1086          end;
 1087          Inc(CurrentFunction.ReturnCount);
 1088      .)
 1089  .
 1090  /*------------------------------------------------------------------------*/
 1091  
 1092  Block<var OutOp : TZcOp>
 1093    (. var
 1094         Op : TZcOp;
 1095    .)
 1096  = (. Op := nil;
 1097       OutOp := MakeOp(zcBlock);
 1098    .)
 1099    "{" (. SymTab.PushScope;
 1100           CurrentFunction.PushScope;
 1101           try .)
 1102       {Statement<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
 1103    "}" (.
 1104           finally
 1105             SymTab.PopScope;
 1106             CurrentFunction.PopScope;
 1107           end;
 1108        .)
 1109    .
 1110  
 1111  /*------------------------------------------------------------------------*/
 1112  StatementExpr<var OutOp : TZcOp>           (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
 1113  = (. Op1 :=nil; Op2 := nil; .)
 1114    Unary<Op1>
 1115    ( AssignOp<Kind> Expr<Op2>
 1116      (.
 1117        if Op2<>nil then
 1118          OutOp := MakeAssign(Kind,Op1,Op2);
 1119      .)
 1120    |                             (. OutOp := Op1; .)
 1121    )
 1122  .
 1123  
 1124  /*------------------------------------------------------------------------*/
 1125  AssignOp<var Kind : TZcAssignType>
 1126  = "="     (. Kind := atAssign; .)
 1127    | "+="  (. Kind := atPlusAssign; .)
 1128    | "-="  (. Kind := atMinusAssign; .)
 1129    | "*="  (. Kind := atMulAssign; .)
 1130    | "/="  (. Kind := atDivAssign; .)
 1131    | "|="  (. Kind := atOrAssign; .)
 1132    | "<<="  (. Kind := atShiftLeftAssign; .)
 1133    | ">>="  (. Kind := atShiftRightAssign; .)
 1134    | "&="  (. Kind := atAndAssign; .)
 1135  /*  | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" */
 1136  .
 1137  
 1138  /*------------------------------------------------------------------------*/
 1139  
 1140  SwitchSection<SwitchOp : TZcOpSwitch> (. var Op : TZcOp; .)
 1141  = (. Op := nil; .)
 1142    SwitchLabel<Op>   (. AddSwitchLabel(SwitchOp,Op); .)
 1143    {
 1144      SwitchLabel<Op> (. AddSwitchLabel(SwitchOp,Op); .)
 1145    }
 1146    Statement<Op>    (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
 1147    {
 1148       Statement<Op> (. if Assigned(Op) then SwitchOp.StatementsOps.Last.Children.Add(Op); .)
 1149    }
 1150  .
 1151  
 1152  /*------------------------------------------------------------------------*/
 1153  
 1154  SwitchLabel<var OutOp : TZcOp>
 1155  = "case" Expr<OutOp> ":"
 1156  | "default" ":"
 1157  .
 1158  
 1159  /*------------------------------------------------------------------------*/
 1160  
 1161  ForInit<var OutOp : TZcOp>     (. var Op : TZcOp; .)
 1162  = (. Op:=nil; OutOp := MakeOp(zcBlock); .)
 1163  (
 1164  IF (. IsLocalVarDecl .) LocalVarDecl<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
 1165  | (. Op:=nil; .) StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .)
 1166    { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
 1167  )
 1168  .  
 1169  
 1170  /*------------------------------------------------------------------------*/
 1171  
 1172  ForInc<var OutOp : TZcOp>      (. var Op : TZcOp; .)
 1173  = (. Op:=nil;
 1174       OutOp := MakeOp(zcBlock);
 1175    .) 
 1176  (
 1177  StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) 
 1178  { (. Op:=nil; .) "," StatementExpr<Op> (. if Assigned(Op) then OutOp.Children.Add(Op); .) }
 1179  )
 1180  . 
 1181  
 1182  
 1183  /*------------------------------------------------------------------------*
 1184   *----------------------------- Expressions ------------------------------*
 1185   *------------------------------------------------------------------------*/
 1186  
 1187  
 1188  Expr<var OutOp : TZcOp>   (. var Op1,Op2 : TZcOp; Kind : TZcAssignType; .)
 1189  = (. Op1 :=nil; Op2 := nil; .)
 1190    Unary<Op1>
 1191    ( OrExpr<Op1,OutOp>
 1192        ["?" Expr<Op1> ":" Expr<Op2>
 1193           (. if (OutOp=nil) or (Op1=nil) or (Op2=nil) then
 1194                SynError(205)
 1195              else
 1196                OutOp := MakeOp(zcConditional,[OutOp,Op1, MakeCompatible(Op2,Op1.GetDataType) ]);
 1197           .)
 1198        ]
 1199    | AssignOp<Kind> Expr<Op2>    (. OutOp := MakeAssign(Kind,Op1, Op2); .)
 1200    )
 1201  .
 1202  /*------------------------------------------------------------------------*/
 1203  OrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
 1204  = AndExpr<InOp,OutOp>   (. L := OutOp; .)
 1205      {"||" Unary<Op> AndExpr<Op,R>
 1206        (. OutOp := MakeOp(zcOr,[L,R]);
 1207           L := OutOp; .)
 1208      }
 1209  .
 1210  
 1211  
 1212  /*------------------------------------------------------------------------*/
 1213  AndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
 1214  = BitOrExpr<InOp,OutOp>  (. L := OutOp; .)
 1215      {"&&" Unary<Op> BitOrExpr<Op,R>
 1216        (. OutOp := MakeOp(zcAnd,[L,R]);
 1217           L := OutOp; .)
 1218      }
 1219  .
 1220  /*------------------------------------------------------------------------*/
 1221  BitOrExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
 1222  = BitXorExpr<InOp,OutOp> (. L := OutOp; .)
 1223    {"|" Unary<Op> BitXorExpr<Op,R>
 1224      (. OutOp := MakeOp(zcBinaryOr,[L,R]);
 1225         L := OutOp; .)
 1226    }
 1227  .
 1228  
 1229  /*------------------------------------------------------------------------*/
 1230  BitXorExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
 1231  = BitAndExpr<InOp,OutOp> (. L := OutOp; .)
 1232    {"^" Unary<Op> BitAndExpr<Op,R>
 1233      (. OutOp := MakeOp(zcBinaryXor,[L,R]);
 1234         L := OutOp; .)
 1235    }
 1236  .
 1237  
 1238  /*------------------------------------------------------------------------*/
 1239  BitAndExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; .)
 1240  = EqlExpr<InOp,OutOp> (. L := OutOp; .)
 1241    {"&" Unary<Op> EqlExpr<Op,R>
 1242      (. OutOp := MakeOp(zcBinaryAnd,[L,R]);
 1243         L := OutOp; .)
 1244    }
 1245  .
 1246  
 1247  /*------------------------------------------------------------------------*/
 1248  EqlExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
 1249  = RelExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
 1250    {( "!="   (. Kind := zcCompNE; .)
 1251     | "=="   (. Kind := zcCompEQ; .)
 1252     )
 1253     Unary<Op> RelExpr<Op,R>
 1254           (. OutOp := MakeBinary(Kind, L,R);
 1255              L := OutOp;
 1256           .)
 1257    }
 1258  .
 1259  /*------------------------------------------------------------------------*/
 1260  RelExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind; .)
 1261  = ShiftExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
 1262    { ( "<"       (. Kind := zcCompLT; .)
 1263      | ">"       (. Kind := zcCompGT; .)
 1264      | "<="      (. Kind := zcCompLE; .)
 1265      | ">="      (. Kind := zcCompGE; .)
 1266       )
 1267      Unary<Op> ShiftExpr<Op,R>
 1268           (. OutOp := MakeBinary(Kind, L,R );
 1269              L := OutOp;
 1270           .)
 1271    }
 1272  .
 1273  /*------------------------------------------------------------------------*/
 1274  ShiftExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp; Kind : TZcOpKind; .)
 1275  = AddExpr<InOp,OutOp> (. L := OutOp; Kind := zcNop; .)
 1276    { ("<<"  (. Kind := zcBinaryShiftL; .)
 1277      | ">>" (. Kind := zcBinaryShiftR; .)
 1278      )
 1279      Unary<Op> AddExpr<Op,R>
 1280      (. OutOp := MakeOp(Kind,[L,R]);
 1281         L := OutOp; .)
 1282    }
 1283  .
 1284  /*------------------------------------------------------------------------*/
 1285  AddExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Op,L,R : TZcOp;  Kind : TZcOpKind;.)
 1286  = MulExpr<InOp,OutOp>   (. L := OutOp; Kind := zcNop; .)
 1287      {( "+"    (. Kind := zcPlus; .)
 1288       | "-"    (. Kind := zcMinus; .)
 1289       ) Unary<Op> MulExpr<Op,R>
 1290           (. 
 1291              if (L=nil) or (R=nil) then
 1292                ZError('Invalid syntax');
 1293              OutOp := MakeBinary(Kind,L,R);
 1294              L := OutOp;
 1295           .)
 1296      }
 1297  .
 1298  /*------------------------------------------------------------------------*/
 1299  MulExpr<InOp : TZcOp; var OutOp : TZcOp>         (. var Tmp : TZcOp; Kind : TZcOpKind; .)
 1300  = (. OutOp := InOp; Kind := zcNop; .)
 1301    { ("*"      (. Kind := zcMul; .)
 1302      | "/"     (. Kind := zcDiv; .)
 1303      | "%"     (. Kind := zcMod; .)
 1304      ) Unary<Tmp>
 1305           (. OutOp := MakeBinary(Kind,InOp,Tmp);
 1306              InOp := OutOp;
 1307           .)
 1308      }
 1309  .
 1310  /*------------------------------------------------------------------------*/
 1311  Unary<var OutOp : TZcOp>         (. var LastOp,Tmp : TZcOp; Kind : TZcOpKind; .)
 1312  =       (. LastOp := nil; Kind := zcNop; .)
 1313    {
 1314      (
 1315        /* "+" | */
 1316        "-"   (. Kind := zcNegate; .) |
 1317        "++"  (. Kind := zcPreInc; .) |
 1318        "--"  (. Kind := zcPreDec; .) |
 1319        "!"   (. Kind := zcNot; .)    |
 1320        "~"   (. Kind := zcBinaryNot; .)
 1321        /* | "~" | "*" */
 1322      )
 1323      (.
 1324         if Kind in [zcNot,zcBinaryNot] then
 1325         begin
 1326           Tmp := MakeOp(Kind);
 1327           if LastOp<>nil then
 1328             LastOp.Children.Add(Tmp);
 1329           LastOp := Tmp;
 1330         end else if Assigned(LastOp) then
 1331           ZError('- ,-- and ++ cannot be combined with other unary ops');
 1332      .)
 1333    }
 1334    Primary<Tmp>
 1335      (.
 1336         if Kind=zcNegate then
 1337           OutOp := MakeBinary(zcMinus, TZcOpLiteral.Create(Tmp.GetDataType.Kind,0), Tmp)
 1338         else if Kind in [zcNop,zcNot,zcBinaryNot] then
 1339         begin
 1340           if LastOp<>nil then
 1341           begin
 1342             LastOp.Children.Add(Tmp);
 1343             OutOp := LastOp;
 1344           end else
 1345             OutOp := Tmp;
 1346         end else
 1347         begin
 1348           OutOp := MakePrePostIncDec(Kind,Tmp);
 1349         end;
 1350      .)
 1351  .
 1352  
 1353  
 1354  
 1355  /*------------------------------------------------------------------------*/
 1356  InvokeArgument<var OutOp : TZcOp; Ci : TZComponentInfo>
 1357  (.
 1358    var
 1359      Op : TZcOp;
 1360      Prop : TZProperty;
 1361  .)
 1362  = (. OutOp := nil; Op := nil; .)
 1363    ident (.
 1364      Prop := Ci.GetProperties.GetByName(LexString);
 1365      if Prop=nil then
 1366        ZError(LexString + ' is not a property of ' + Ci.ZClassName);
 1367      if not (Prop.PropertyType in [zptFloat,zptInteger,zptByte,zptBoolean,zptString,zptComponentRef]) then
 1368        ZError(LexString + ' property of ' + Ci.ZClassName + ' is of a datatype that cannot be set using inline component invokation syntax');
 1369      OutOp := MakeOp(zcIdentifier,LexString);
 1370    .)
 1371    ":" Expr<Op>
 1372    (. if Op=nil then
 1373         ZError('Missing argument');
 1374       Op := MakeCompatible(Op, PropTypeToZType(Prop.PropertyType));
 1375       OutOp.Children.Add(Op);
 1376    .)
 1377  .
 1378  
 1379  
 1380  /*------------------------------------------------------------------------*/
 1381  ReinterpretCast<var OutOp : TZcOp>
 1382  (.
 1383  var
 1384    Op : TZcOp;
 1385    Typ : TZcDataType;
 1386  .)
 1387  = "reinterpret_cast" "<" SimpleType<Typ> ">"
 1388    "(" Expr<Op> ")"
 1389    (.
 1390       OutOp := TZcOpReinterpretCast.Create(nil);
 1391       OutOp.Children.Add(Op);
 1392       (OutOp as TZcOpReinterpretCast).Typ := Typ;
 1393    .)
 1394  .
 1395  
 1396  /*------------------------------------------------------------------------*/
 1397  InlineComponent<var OutOp : TZcOp>
 1398  (. var Op : TZcOp;
 1399       Ci : TZComponentInfo;
 1400  .)
 1401  =  (. OutOp := nil;
 1402        IsInInvokeArg := True;
 1403     .)
 1404     "@" ident (.
 1405         Ci := ComponentManager.GetInfoFromName(LexString);
 1406         OutOp := TZcOpInvokeComponent.Create(nil);
 1407         OutOp.Id := LexString;
 1408      .)
 1409      "("
 1410          [InvokeArgument<Op,Ci>       (. OutOp.Children.Add(Op); .)
 1411            {"," InvokeArgument<Op,Ci> (. OutOp.Children.Add(Op); .)
 1412            }
 1413          ]
 1414      ")" (. IsInInvokeArg := False; .)
 1415  .
 1416  
 1417  /*------------------------------------------------------------------------*/
 1418  Primary<var OutOp : TZcOp>
 1419  (.
 1420  var Op,ConsCall : TZcOp; S : string; V : double;
 1421    Typ : TZcDataType;
 1422    Cls : TZcOpClass;
 1423    Loc : TZcOpLocalVar;
 1424  .)
 1425  =            (. OutOp := nil; .)
 1426    (
 1427      ident    (. OutOp := CheckPrimary( MakeIdentifier(LexString) );  .)
 1428    | InlineComponent<OutOp>
 1429    | Literal<Typ>  (.
 1430          if Typ.Kind in [zctString,zctNull] then
 1431            OutOp := TZcOpLiteral.Create(Typ.Kind,LexString)
 1432          else
 1433          begin
 1434            try
 1435              S := LexString;
 1436              V := ZcStrToFloat(S);
 1437              OutOp := TZcOpLiteral.Create(Typ.Kind,V)
 1438            except on EConvertError do
 1439              SynError(200);
 1440            end;
 1441          end;
 1442       .)
 1443    | "(" Expr<OutOp> ")"
 1444  /*  | ( "bool"   | "byte"   | "char" | "decimal" | "double"
 1445      | "float"  | "int"    | "long" | "object"  | "sbyte"
 1446      | "short"  | "string" | "uint" | "ulong"   | "ushort"
 1447      ) "." ident */
 1448    | ReinterpretCast<OutOp>
 1449    | "new" Type<Typ>
 1450      ( /*--- object creation expression */
 1451        (. if Typ.Kind<>zctClass then
 1452             ZError('new can only be used with Class-types');
 1453           OutOp := MakeOp(zcNew,LexString);
 1454        .)
 1455        "(" [Argument<Op> (. OutOp.Children.Add(Op); .)
 1456           {"," Argument<Op> (. OutOp.Children.Add(Op); .) }] ")"
 1457  
 1458        (.
 1459           //Look for constructor
 1460           Cls := Typ.TheClass as TZcOpClass;
 1461           S := MangleFunc(OutOp.Id,OutOp.Children.Count+1);
 1462           for Op in Cls.Methods do
 1463           begin
 1464             if SameText((Op as TZcOpFunctionUserDefined).MangledName,S) then
 1465             begin
 1466               //Constructor call generates: #inline { temp=new x; temp.constructor(); inlinereturn(temp) }
 1467               Loc := MakeTemp(zctClass);
 1468               Loc.Typ.TheClass := Cls;
 1469               SymTab.Add(Loc.Id,Loc);
 1470               CurrentFunction.AddLocal(Loc);
 1471  
 1472               ConsCall := MakeOp(zcMethodCall);
 1473               ConsCall.Id := Cls.Id;
 1474               ConsCall.Ref := Cls;
 1475               ConsCall.Children.Add( MakeOp(zcIdentifier,Loc.Id) ); //"this"
 1476               ConsCall.Children.AddRange(OutOp.Children); //rest of constructor arguments
 1477  
 1478               OutOp := MakeOp(zcInlineBlock);
 1479               OutOp.Children.Add( MakeAssign(atAssign, MakeOp(zcIdentifier,Loc.Id), MakeOp(zcNew,Cls.Id)) );
 1480               OutOp.Children.Add( ConsCall );
 1481               OutOp.Children.Add( MakeOp(zcInlineReturn, MakeOp(zcIdentifier,Loc.Id)) );
 1482  
 1483               if not VerifyFunctionCall(ConsCall,S,CurrentFunction,Cls) then
 1484                 ZError(S);
 1485               Break;
 1486             end;
 1487           end;
 1488        .)
 1489      )
 1490    )
 1491  
 1492    {
 1493    "++" (. OutOp := MakePrePostIncDec(zcPostInc,OutOp); .)
 1494    | "--" (. OutOp := MakePrePostIncDec(zcPostDec,OutOp); .)
 1495  
 1496  /*  | "->" ident */
 1497  
 1498    | "." (. IsInIdent := True; .) ident (.
 1499  
 1500        if not (OutOp.Kind in [zcIdentifier,zcSelect,zcFuncCall,zcArrayAccess]) then
 1501          ZError('Invalid use of "."');
 1502  
 1503        Op := MakeOp(zcSelect,LexString);
 1504        Op.Children.Add(OutOp);
 1505  
 1506        OutOp := CheckPrimary(Op);
 1507  
 1508        IsInIdent := False;
 1509  
 1510      .)
 1511  
 1512    | "(" (.
 1513             if (OutOp=nil) then
 1514               ZError('Unexpected "("');
 1515             Cls := nil;
 1516             if (OutOp.Kind<>zcIdentifier) then
 1517             begin
 1518               Typ := OutOp.Children.First.GetDataType;
 1519               if Typ.Kind=zctClass then
 1520               begin
 1521                 Cls := Typ.TheClass as TZcOpClass;
 1522                 OutOp.Ref := Cls;
 1523               end
 1524               else
 1525                 ZError('Unexpected "("');
 1526             end;
 1527             if Assigned(Cls) then
 1528               OutOp.Kind := zcMethodCall
 1529             else
 1530               OutOp.Kind := zcFuncCall;
 1531           .)
 1532          [Argument<Op> (. OutOp.Children.Add(Op); .)
 1533            {"," Argument<Op> (. OutOp.Children.Add(Op); .)
 1534            }
 1535          ]
 1536          (.
 1537             if not VerifyFunctionCall(OutOp,S,CurrentFunction,Cls) then
 1538               ZError(S);
 1539          .)
 1540      ")"
 1541  
 1542    | "[" (.
 1543             if (OutOp=nil) or (not (OutOp.Kind in [zcIdentifier,zcSelect,zcArrayAccess,zcFuncCall])) then
 1544               ZError('Unexpected "["');
 1545             Op := MakeArrayAccess(OutOp);
 1546             OutOp := Op;
 1547           .)
 1548  
 1549          Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .)
 1550            {"," Expr<Op> (. OutOp.Children.Add( MakeCompatible(Op,zctInt) ); .) }
 1551          "]"
 1552    }
 1553  .
 1554  /*------------------------------------------------------------------------*/
 1555  Literal<var Typ : TZcDataType>
 1556  = intCon (. Typ.Kind :=zctInt; .) |
 1557    realCon (. Typ.Kind := zctFloat; .) |
 1558    stringCon (. Typ.Kind := zctString; .)
 1559    | "null" (. Typ.Kind := zctNull; .)
 1560    /* | "true" | "false"  */
 1561  .
 1562  
 1563  END Zc.



